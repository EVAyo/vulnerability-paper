<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Qu6S3wz7v_xnbRF4fOxTcQ)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

免责声明

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者及本公众号不为此承担任何责任。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

原型链污染原理

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

原型链污染的成因往往都是因为用户可以控制如下形式的输入:

```
obj[a][b] = value;

```

攻击者设定 a 为”proto”，设定 b 为任何已存在的属性或方法 (比如上文所述的 filter 方法)，那么，就可以通过 value 值实现对值 b 的污染。

当然，这样的形式也是可以实现污染的:

```
obj[a][b][c] = value;

```

攻击者设定 a 为属性 “constructor”，b 为”prototype”，就实现了跟上面 obj[proto][b]=value 的效果。

现实代码中，常见的有三种情况能实现上述的原型链污染过程:

1.  递归合并对象的属性和方法
    
2.  克隆对象
    
3.  路径定义输入可控
    

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

递归合并对象的属性和方法

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

典型的源码如下：

```
function merge(target, source) {
    for (let key in source) {
        if (key in source && key in target) {
            merge(target[key], source[key])
        } else {
            target[key] = source[key]
        }
    }
}

```

我如传入形如:'{"__proto__":{"test":123\}\}'的输入，那么就会得到 target[”__**proto**__”][”test”] = 123 的执行:

![](https://mmbiz.qpic.cn/sz_mmbiz_png/FVvAFkxoh9BT4pcxlnjkgY2o0s0Ov56f5c418ExFI5nNDYGsowrWj2ZKWhqlPfudyp9uGpEDTmmicMOKic7RYaZg/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

克隆对象

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

典型的源码如下：

```
function clone(obj) {
  return merge({}, obj);
}

```

本质上还是利用了 merge 的功能，只不过此处的 target 是一个空对象，用于克隆 source 对象。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/FVvAFkxoh9BT4pcxlnjkgY2o0s0Ov56feibNgO9ZUdiaicUWtC3ca6kTX7KZxsfAcgFM3HXxFGaiaCSvUgsaC0tVnQ/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

路径定义输入可控

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

典型源码如下:

```
function theFunction(obj, path, value) {
    let parts = path.split('.');
    let last = parts.pop();
    let current = obj;
    for(let part of parts) {
        if(!current[part]) current[part] = {};
        current = current[part];
    }
    current[last] = value;
}

```

我们通过设计 path 为__proto__.myValue 和 value 实现对 obj 的污染，典型的污染输入:

```
let attackerControlledValue = '__proto__.myValue';
let obj = {};
theFunction(obj, attackerControlledValue, 'This is a controlled value');

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/FVvAFkxoh9BT4pcxlnjkgY2o0s0Ov56fa4xFMaNxIkR4XeyeevcoZibyI1jEXX3REeLN84r43MNs9lw7Ns3XWMA/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

利用方法

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

常见的三种利用方法：

1.  Denial-of-service 攻击
    
2.  属性注入
    
3.  代码执行
    

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

Denial-of-service 攻击

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

prototype 中包含了许多内置的方法供开发者直接使用，其中就有我们前文中提到的 Array.prototype.filter()，Array.prototype.map()，更常见的还有 toString() 等函数，只要我们污染了这些常用的函数，使其不可用，那么就可以直接导致整个程序瘫痪。

可以看下面的 Express 代码，它使用了存在漏洞的 lodash 库，在代码的第 12 行，我们进行了一次对象克隆，存在原型链污染漏洞。提交如下的 payload:'{"__proto__":{"toString":"123","valueOf":"123"\}\}'，toString() 和 valueOf() 两个方法受到污染，变为不可用。又因为 Express 中使用了大量的 toString() 和 valueOf()，直接导致了之后的所有请求均无法处理，返回 500 错误码。

```
1. var _ = require('lodash');
2. var express = require('express');
3. var app = express();
4. var bodyParser = require('body-parser');
5.
6. app.use(bodyParser.json({ type: 'application/*+json' }))
7. app.get('/', function (req, res) {
8.     res.send("Use the POST method !");
9. });
10.
11. app.post('/', function (req, res) {
12.    _.merge({}, req.body);
13.    res.send(req.body);
14. });
15.
16. app.listen(3000, function () {
17.     console.log('Example app listening on port 3000!')
18. });

```

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

属性注入

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

对于特定的程序，我们可以污染程序中一些有价值的属性来控制程序的运行。以 Express 程序为例，Express 程序存在属性 cookie，也就是我们熟知的 Http Cookie。我们通过污染 Express 的 cookie 属性，就可以让所有的访问都使用我们污染的 cookie。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

代码执行

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

假设我们上述的 Express 程序中存在如下代码，通过 for 循环获取所有的属性，如果__proro__中也包含属性，会一同获取。

```
1.var execSync = require('child_process').execSync;
2.
3.function runJobs() {
4.    var commands = {
5.        "script-1" : "/bin/bash /opt/my-script-1.sh",
6.        "script-2" : "/bin/bash /opt/my-script-2.sh"
7.    };
8.
9.    for (var scriptname in commands) {
10.        console.log("Executing " + scriptname);
11.        execSync(commands[scriptname]);
12.    }
13.}

```

那么，我们只需要提交这样的 payload:'{"__proto__":{"payload":"whoami> output"\}\}'，就可实现代码执行。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

总结

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

本章介绍了 JavaScript 原型链攻击的原理和利用方法，并且每个方法都给出了样例。下一章我们将介绍漏洞 CVE-2019-10744 的原理，以及自动化刷 JavaScript 原型链漏洞的方法。自动化刷洞的方法已经放在 Github，点击原文链接可以直达。