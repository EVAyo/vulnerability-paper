<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Gab2bg5YIAZY6ulKwTs2Dg)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

免责声明

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者及本公众号不为此承担任何责任。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

引言

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

最近在研究开源软件供应链安全问题时，发现一个有意思的漏洞：**CVE-2019-10744**。JavaScript 的`lodash`库在调用函数`defaultsDeep`时，攻击者可以精心构造一个 Json 输入，实现对目标系统的 DoS，属性注入，甚至是代码执行，**这就是 JS 原型链污染漏洞**。

进一步研究后我发现，不仅仅是`lodash`库曾经存在过这个漏洞，许多使用了 merge 功能的 JS 库还有 CTF 比赛中也存在这个问题。熟悉原型链污染的原理和利用方法，以及防御手段，十分必要。

本文中用于自动化检测 JS 原型链污染的代码已上传至 GitHub：https://github.com/fatmo666/Proton-pollution-check，也可以点击阅读原文获取。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

JavaScript 原型

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

原型和原型链，其实就是 JS 中对象的 prototype，__proto__两个属性，可以如下表格帮助认识：

<table><thead><tr><th><br></th><th width="131.33333333333334">属性名</th><th width="362.3333333333333">作用</th></tr></thead><tbody><tr><td>原型</td><td width="64.00000000000001">prototype</td><td width="342.3333333333333">所有 JS 对象都有的属性，Object 类型，可包含属性和方法</td></tr><tr><td>原型链</td><td width="64.00000000000001">proton</td><td width="342.3333333333333">所有 JS 对象都有的属性，Object 类型，指向该对象构造函数的 prototype</td></tr></tbody></table>

可以把原型和原型链理解成 JS 用于实现继承的一种方式 (JS 中没有类似 C++ 的继承机制)。我的**构造函数这个对象** (JS 中，函数也是一个对象) 的 prototype 中携带了通用的属性和方法，我使用构造函数 New 出一个新对象时，可以通过新对象的__proton__找到构造函数的 protontype 对象，从而使用构造函数中携带的属性和方法，实现继承。

文字叙述比较绕，用一个简单的例子说明：

1.  我们都知道，JS 的 Array() 类型的对象有 map 和 filter 两个方法:
    

```
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(n => n * 2);
console.log(doubled); // Outputs: [2, 4, 6, 8, 10]
let doubled1 = [1, 2, 4, 6, 7, 8, 10];
let even = doubled1.filter(n => n % 2 === 0);
console.log(even); // Outputs: [2, 4, 6, 8, 10]

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/FVvAFkxoh9BT4pcxlnjkgY2o0s0Ov56fiaVaLUVYV9GzUEflODOpIDWXIicenMBq203aLwEwrIfibfvicLaErXicJTQ/640?wx_fmt=png)

2. 我们初始化了两个 Array，分别是 numbers 和 doubled1，它们就天然可以使用 map 和 filter 两个方法，就是因为 Array() 对象的 protontype 中实现了这两个方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/FVvAFkxoh9BT4pcxlnjkgY2o0s0Ov56fgDaplTERmJQIhlHmhMT7go8kxrqOjS6wLRg4nNodIwmeiaW45gUEZiaw/640?wx_fmt=png)

3. 在代码里，我们执行了 doubled1.filter(n => n % 2 === 0);，此时在 doubled 对象中不存在 filter 方法，就会顺着__proto__去找它构造函数是否有__proto__方法，如果没有，继续往上找，找到后，就会调用该方法，这就是原型链，通过__proto 不断向上寻找而形成的链条。

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Op7Y2S0HyKx4Sibx9mxsrz68yfgLOMCxU05FFBGZtaHqGlp9uPhdwKhs0vLnxgibBpLrwfGhQVWpIHdjxlfhDyLg/640?wx_fmt=png)

总结

![](https://mmbiz.qpic.cn/mmbiz_png/yRDp2K3ZBpKOicaBvhSTPZYqTVq8ku50NMtfAqkWhJw2cyMfYEhzIZHlVGLH0Wl2tQ8usSOv6xbZxBiabe1XiaLhA/640?wx_fmt=png)

  

本章讲述了 JavaScript 中原型和原型链的原理，本质上就是 prototype，__proto__两个属性，而这正是 JavaScript 中的关键属性。下一章我们将介绍如何利用原型链污染进行攻击。