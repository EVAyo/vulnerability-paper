<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/CTmprsOdt7vHq2Z6er1B-w)

**一**

  

**前  言**

在 IoT 小设备中由于运行资源（CPU、存储、内存等）受限，通常会使用轻量级的 Web server，例如 uHTTPd、lighttpd、micro_httpd、mini_httpd、GoAhead、boa 等，其中 uHTTPd、lighttpd 此类 Web server 通常不会由开发者修改源码新增功能代码，而是纯粹作为一个类似流量转发的框架；而 micro_httpd、mini_httpd、GoAhead、boa 此类通常是由开发者将一些业务代码集成到 Web server 中，导致在 server 代码中产生漏洞的概率增大。

本文由于篇幅原因，仅仅针对 IoT 小设备（光猫、路由器、摄像头等）中常见的两个开源 Web server 框架 GoAhead 和 mini_httpd，分别从源码处理数据、漏洞存在点、经典 CVE 漏洞分析这三个方面，浅析其漏洞挖掘思路。

本文不会完全分析 Web server 代码实现、架构，而是聚焦于安全研究较为关注、通常由开发者实现的数据包处理部分。文章的大概阐述思路如下：

1.  首先结合源码说明数据包处理特性，主要涉及鉴权、路由处理；
    
2.  简述数据包处理中可能存在的漏洞点；
    
3.  结合经典漏洞进行分析。
    

**二**

  

**GoAhead 篇**

GoAhead 是一个轻量化、适用于嵌入式设备的 Web server，采用 C 语言编写，代码量不大，具有高度的可移植性和扩展性。GoAhead 支持多进程、多线程，能够处理大量的并发连接，支持 SSL/TLS 加密和基本的身份认证，支持 CGI、ASP，满足了绝大部分的 Web server 业务场景。

GoAhead 由 Embedthis Software LLC 开发，早年间是完全开源的，可以直接在 Github 上下载到源码。但是在 2022 年的时候，似乎转为了商业定制，官方在 Github 删除了代码库，因此在 Github 上无法下载，但是在 Gitee 上还有镜像库。下载地址：GoAhead: GoAhead WebServer。

在 D-Link 的主流路由器中，例如 DIR 系列，很多使用了 GoAhead 作为 Web Server；除此之外还有 Tenda、NETGEAR、BEC 等许多厂家都有在其设备中使用 GoAhead。

**01**

**数据包处理逻辑**

  

GoAhead 会对数据包按照优先级进行顺序处理，处理方式是通过注册的回调函数：

*   优先级为 1 注册的回调函数：所有数据包都需要首先经过该回调函数进行处理，此处也通常被用来做数据包鉴权、请求路径合法性判断、未授权访问路径定义等等；
    
*   优先级为 0 注册的回调函数：通常用来定义认证后可访问到的接口逻辑实现；
    
*   优先级为 2 注册的回调函数：处理没有匹配到注册路径的数据包，也就是非法路径的数据包。
    

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKFYYv7Po3fYOBwsibbCUDz6ibu8CDdsTkB9en4M9C1OqS095UOwZQB8Vw/640?wx_fmt=png&from=appmsg)

重要的参数：

*   char_t *urlPrefix：指定 URL 的前缀，也就是需要处理的 URL 开头部分；
    
*   int (*handler)：URL 对应的回调函数；
    
*   int flags：URL 处理优先级标志，有如下的两个选择：
    

*   #define WEBS_HANDLER_FIRST 0x1：所有的数据包都会通过该回调函数进行处理；
    
*   #define WEBS_HANDLER_LAST 0x2：没有回调函数匹配的数据包会通过该回调函数进行处理。
    

如下是一个设备 DIR-878，固件版本 1.02B02 中的 GoAhead 反编译代码，可以看到 GoAhead 对于数据包是否已经通过认证，是通过注册一个 flags=WEBS_HANDLER_FIRST=1 的回调函数 websSecurityHandler 来进行验证的，这意味着所有的数据包都会通过函数 websSecurityHandler 进行处理，验证数据包发送者的权限。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKJs5AwQjxYpzMvibYSria9NBWVZ0R8wBRJQymBia8ic9iaeU6fputsIAI9Ug/640?wx_fmt=png&from=appmsg)

例如对一个请求的完整处理过程：使用 POST 请求访问 /HNAP1/

1. 首先数据包会进入函数 webAuthHandler：请求路径鉴权、请求路径合法性判断等

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bK9l69TrJrE9Z2KS00EPuyRGRGAsIdGUxianjh6QyMYQnCRg3YznWiczsw/640?wx_fmt=png&from=appmsg)

2. 根据一层路径 /HNAP1/，匹配回调函数 websFormHandler：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKNuDqO7HILeZqDhUSQr6wzJQKDwsIlBbnuQ2ueEM2Ey6MsPpPg1vOFw/640?wx_fmt=png&from=appmsg)

3. 然后在回调函数 websFormHandler 进行进一步的业务代码处理。

**02**

**漏洞挖掘思路**

  

对于 GoAhead 的漏洞挖掘，一般的思路是：

1.  根据关键字符串定位到 GoAhead 的版本，看是否收到历史漏洞的影响，其中 CVE-2017-17562 和 CVE-2021-42342 都是发生在由于对 CGI 环境变量处理不当导致的远程代码执行；
    
2.  分析路径鉴权模块，例如 websUrlHandlerDefine 中对路径鉴权是否存在绕过、缓冲区溢出；
    
3.  分析其他路径定义函数，看路径的回调函数中参数处理是否存在漏洞。
    

根据笔者对 GoAhead 的处理经验，其一般都存在认证后相关的命令注入、缓冲区溢出等常见漏洞，但 GoAhead 的鉴权是一个比较难绕过的点，使用的鉴权方式越简单、额外判定越少，越难绕过。

**03**

**案例分析**

  

**案例 1：GoAhead 环境变量注入漏洞（CVE-2017-17562）**

CVE-2017-17562 是发生在版本 3.6.5 之前的远程代码执行，当 CGI 功能被启用且采用了动态 so 加载，由于处理环境变量时直接将请求参数键值对设置并传递到 CGI，如果使用了 LD_PRELOAD，使用 POST 请求方式可以将代码通过标准输入传递到 CGI 的 / proc/self/fd/0，然后导致远程代码执行。

Goahead 的版本号确定，可以通过搜索字符串 GoAhead-Webs，可以确定版本，从而判断是否受到历史漏洞的影响。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmThRgDZhs5TZOffguFnDFD8uocNIpPcJj9eKKl15UtXAruE8bcDEJp1Z4apxGaojf24HZEticMmbAg/640?wx_fmt=png&from=appmsg)

版本字符串定位

漏洞发生的本质是因为使用了不可信任的 HTTP 请求参数作为初始化 CGI 脚本的环境变量。GoAhead 调用 CGI 之前，会使用函数 cgiHandler 将用户提交的参数存入环境变量数组 envp 中，并只使用了简单的黑名单过滤 REMOTE_HOST 和 HTTP_AUTHORIZATION 两个环境变量。CVE-2021-42342 是对补丁的绕过，此处不再详细阐述。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKibdkz69Dk1a8hYjiaVUVxGJ2VbFVnFSEkzeaOUVvLHM6qTZu0vAxlx7w/640?wx_fmt=png&from=appmsg)

对于此漏洞的利用，先补充下 CGI 调用的相关基础知识。Web server 为了增加自身数据处理的可扩展性，会采用 CGI（Common Gateway Interface，通用网关接口）标准启动外部程序处理用户的请求，并将外部程序处理数据的结果通过 Web server 返回给用户。Web server 会将用户提交的数据通过环境变量和标准输入传递给程序，程序执行完毕之后通过标准输出传递给 Web server，然后 Web server 再返回给用户。

因此，针对该漏洞的一种利用方式就是通过 POST 请求头设置环境变量 LD_PRELOAD 为 CGI 程序自身的标准输入（即 POST 请求体），CGI 程序运行时就会自动加载请求体中构造的动态链接库。

如下，先定义一个构造函数，该函数会先于 CGI 程序的 main 函数被调用。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKjHoR2ibic95BQpsMwlCiaGOxKAl4IrnxjdLIa0icf6jaQdWlyFHDEIeMew/640?wx_fmt=png&from=appmsg)

使用如下命令构造出动态链接库，使用 cat 命令测试，的确能够运行。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKiaVc2Pb45ia6GyiaIavB4uKYcq5z8Pc1XIWXUUoxjNq4JNhibUcMy6hlHw/640?wx_fmt=png&from=appmsg)

然后使用 curl 构造 POC 如下，发送请求后可以看到的确执行了动态链接库中的函数并输出结果。此处对 POC 简单解释下，GoAhead 调用 CGI 程序前，会对 CGI 程序的环境变量和标准输入进行设置。data-binary 参数是将 payload.so 作为 CGI 程序的标准输入；LD_PRELOAD=/proc/self/fd/0，则是让 CGI 程序在运行时从自身的标准输入加载动态链接库，也就是 POST 请求体中传入的 payload.so。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKkODoib5Xv7FUDibAQ9Sia6v2bmFvHpfm6arqCOAgQXiaQZYqs3EGjziaEJQ/640?wx_fmt=png&from=appmsg)

#### **案例 2：发生在 websSecurityHandler 中的认证绕过（CVE-2020-15633）**

该漏洞是发生在 LAN 口的一个登录认证绕过漏洞，影响设备 DIR-867、DIR-878、DIR-882，固件版本 1.20B10_BETA。漏洞产生的原因是在处理 HNAP 请求的过程中，验证用户登录逻辑时处理不当，使用 strstr 函数来检查无需验证权限的接口，导致可以构造特定 URI 来绕过身份认证，从而访问敏感接口。

设备采用 lighttpd 作为 Web server，根据配置会将 HNAP 请求转发到程序 /bin/prog.cgi 进行处理，prog.cgi 是基于 GoAhead 开发。在文章开头提到过使用 lighttpd 作为 Web server，将流量根据业务场景通过规则进行转发，此处就是一个典型的示例：将所有 HNAP1 相关的流量使用 fastcgi 转发到了 /bin/prog.cgi 中进行处理，这样使得架构更加模块化、处理逻辑更清晰。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKE4lqYKpLEK3trd3IS6AdQ5h1BqicvZiaZrxffUwW2q4VFOVrhEj9sxAA/640?wx_fmt=png&from=appmsg)

漏洞触发过程的函数调用如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKD5clEAkX6hPPfyrTaGicCMPdqvLJ2LndxuMGjBrFx3ib3icnmXmSsw2VQ/640?wx_fmt=png&from=appmsg)

1. 在函数 sub_423ECC 中，会使用函数 strstr 比较环境变量 REQUEST_URI（也就是请求路径）中是否含有字符串列表 actions_list 中的字符串，然后触发到 return 0；

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKnPVMbykdSzT3aqZjQeUj1zIRaDth39iaX3JBGWTiac2m4gsorzGrbC1Q/640?wx_fmt=png&from=appmsg)

actions_list 中的字符串表如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmThRgDZhs5TZOffguFnDFD8DIlIoEgFIodd3MLI2niaOGk9ruHiajont4U4MBVJA6qG1JgyJkbzqVVA/640?wx_fmt=png&from=appmsg)

2. 然后返回到函数 sub_4249EC，触发该函数继续返回 0；

3. 再返回到函数 websSecurityHandler 中，使得该认证函数返回 0，达到认证绕过；

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKchLRBkCQN7OdK7aV4QJawv1icfDq3EdhTAJD7iaSCLmflwmHiaDwaxaMg/640?wx_fmt=png&from=appmsg)

综上所述，对于路由 /HNAP1/，只需要在 uri 后添加?GetCAPTCHAsetting 或者任意其他字符串列表的中字符串，就可以达到认证绕过访问该接口的目的，参考 POC 如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bK9ib0VOichuV9GaoVSOKsNA5icgiaRCFHYiamYFyBTwrGCUYIHYmuCkzniceQ/640?wx_fmt=png&from=appmsg)

**案例 3：发生在函数 websSecurityHandler 中的认证绕过（CVE-2020-8864）**

CVE-2020-8864 是发生在固件版本为 1.10B04 的 D-Link DIR-867、DIR-878 和 DIR-882 路由器的认证绕过漏洞。该漏洞是由于 HNAP 请求中处理登录密码时缺乏对空密码的正确处理而导致的，攻击者可以利用该漏洞进行命令执行。

此处同样采用固件版本为 1.10B02 的 D-Link DIR 878 中的 prog.cgi 对漏洞进行分析。触发漏洞的函数调用路径如下，比上一个漏洞深入了一层函数调用。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKxhicE6TzJUicicDnZf3JAugSIdK8SGDbOAjSbnm2OCpeycf6NIQldSlsQ/640?wx_fmt=png&from=appmsg)

在函数 sub_423304 中会根据请求参数调用不同的函数，当 action=login 的时候，进入函数 hnap_login 进行认证处理。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKSLQWtzYfKDLmU8duVwyFIuJQbErcNb7hcwzUVrVc4UUBj5ZZbWetvg/640?wx_fmt=png&from=appmsg)

函数 hnap_login 是寻常的账号、密码验证流程，大概简化的流程就是先从请求中获取账号、密码，然后比较账号是否为 Admin/admin，先获取密码长度然后调用 strncmp 比较密码是否正确。但是如果输入密码为空则会导致 strncmp 比较通过。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKLLaPD5sSN6MIC56xUh8aK2kfEMF6AibSr0RGX0SEibhlXiboK94bEZUUQ/640?wx_fmt=png&from=appmsg)

参考 POC 构造如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKdENDrNexib3xSYvfZQ6GsqBxw7AQTPkH0ptX0PiacTcIGx9oWsPFj1AA/640?wx_fmt=png&from=appmsg)

#### **其他漏洞**

GoAhead 中由于很多业务代码是通过定义接口 + 回调函数的形式集成到自身，代码量增多导致发生漏洞的可能增大，如下是一些典型的 GoAhead 认证后漏洞，包含常见的漏洞缓冲区溢出、命令执行。

*   CVE-2021-43474：D-Link DIR 823G 中的认证后命令注入
    
*   CVE-2020-10987：Tenda AC15 中的认证后命令执行
    
*   CVE-2018-11013：D-Link DIR 816A2 中的认证后缓冲区溢出
    

**三**

  

**mini_httpd 篇**

mini_httpd 是一个小型的 HTTP 服务器，它的代码非常小巧，仅有几千行代码，其可以在多种操作系统上运行，包括 Linux、FreeBSD、Solaris、Windows 等。mini_httpd 支持动态内容的生成，包括 CGI、SSI 以及 FastCGI，同时它也支持虚拟主机和基本的身份验证，这满足了绝大部分的 IoT Web server 应用场景，结合其小体量的代码，被广泛应用于嵌入式设备和低功耗系统中。

mini_httpd 的代码下载地址：mini_httpd，目前在 NETGEAR 的路由器中常见 mini_httpd 作为 Web server。

**01**

**数据包处理逻辑**

  

mini_httpd 收到一个数据请求包后会 fork 创建一个子进程来进行处理，这种方式如果在高并发场景会在进程创建、销毁过程中消耗大量的资源，但是在并发量低的嵌入式设备已经够用了。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKJoexZqgkTum6CBxEKpfhYdy3NhrhoBFGLRq1c5nqia7YaccB6zQMLyQ/640?wx_fmt=png&from=appmsg)

子进程中主要是通过 handle_request 函数来对数据进行处理的，主要是先解析请求行、再解析请求头。

*   读取请求的第一行，获取到请求行，然后从行中解析到请求方法 protocol、请求路径 path 和查询参数 query；
    
*   随后解析 header，主要实现是通过 while 循环继续逐行解析 header 中的字段，包括 Authorization、Content-Length、Content-Type、Cookie、User-Agent 等等常见的字段。
    

如下是 handle_request 函数中读取请求行，获取到请求 method_str、path、query、protocol。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKQCCS44RkiaAHjYDCpzuK8Ehsgg487Tfk2SrsfVLA9BGH83Knsnk77Kw/640?wx_fmt=png&from=appmsg)

然后是 while 循环处理 header，获取字段。在源码中包括：Authorization、Content-Length、Content-Type、Cookie、Host、If-Modified-Since、Referer、Referrer、User-Agent 这些字段。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKzNNpXSeVdb2BH4RM1swqXTYPen9Mj1iazJ26CT4xVMIiafebIj9IUb7w/640?wx_fmt=png&from=appmsg)

获取到了如上的重要字段后，就开始对数据包的合法性进行判断，例如：

*   请求方法 method 是否合理：GET、HEAD、POST、PUT、DELETE、TRACE；
    
*   请求路径 path 必须以反斜杠 / 开头、对 path 进行目录穿越相关字符进行处理、检查文件是否存在；
    
*   然后根据 path 是文件夹或文件，分别调用 do_dir 和 do_file 进行处理，二者最终都会进行权限检查函数 auth_check。
    

在权限检查函数 auth_check 中，输入为请求的 path 转换的实际路径 file 所在的文件夹 dirname，如果权限检查通过，则继续直接随后的数据包处理流程；如果权限检查是否，则通过 send_authenticate 函数返回 401，然后结束当前连接的生命周期。

权限检查的流程则是：

1.  如果 dirname 中没有.htpasswd 文件，那么直接认证通过。就相当于是在需要授权访问的文件夹中添加该文件，不需要授权访问的文件夹中没有该文件；
    
2.  源码中采用的校验方式是 BASIC 认证，请求包中带上 username 和 base64 编码的 password，然后和.htpasswd 文件中保存的账号信息进行对比，如果比较通过则直接返回。
    

**02**

**漏洞挖掘思路**

  

因此，平常漏洞挖掘中比较关心的登录认证流程就非常清晰：main -> handle_request -> do_file/do_dir -> auth_check。一般情况下，厂商会根据自己的业务逻辑修改相关的函数，但是根据源码我们还是能通过一些字符串特征来定位到关键函数，例如：

*   通过搜索 index 相关的页面字符串，可以定位到 handle_request；
    

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKJxqiaJE1IbnzibnPKWLc16GF6oGlM8o70tLeKnC3nYMTYhHawkWcPFDw/640?wx_fmt=png&from=appmsg)

*   函数 handle_request 中的逻辑是由开发者定义，因此可能发生缓冲区溢出、命令注入等常见漏洞形式；
    
*   通过搜索字符串.htpasswd 可以直接定位到 do_file、auth_check 函数。do_file 函数中会检查请求文件是否为.htpasswd，auth_check 函数则是需要读取账号信息、调用字符串比较函数等。
    

除此之外，mini_httpd 1.30 之前的版本存在一个任意文件读取漏洞 CVE-2018-18778，当设备开启虚拟主机模式的时候，可以通过构造空的 HOST 请求头和想要读取的文件作为请求资源，便能任意文件读取，随后将从源码简单分析漏洞原理。

总之，mini_httpd 主要容易发生漏洞的地方就是在处理数据包的函数 handle_request 处，因为此处是开发者主要添加自己代码的地方，例如对 header 的处理、认证的自我实现方式等等。

**03**

**案例分析**

  

**案例 1：mini_httpd 任意文件读取漏洞（CVE-2018-18778）**

CVE-2018-18778 是 mini_httpd 自身的一个任意文件读取漏洞，1.30（最新版本）之前的版本都会收到影响。在 mini_httpd 开启虚拟主机模式的情况下，用户请求 http://HOST/FILE 将会访问到当前目录下的 HOST/FILE 文件。

漏洞发生在数据包处理函数 handle_request 中。当处理完毕请求头后，获取到请求文件 path，并根据请求文件 path 构造实际在磁盘中的文件路径 file。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKY5jmT0T3vxGNHgYVpxedEhSiczcn9AyIHEWDExiaZk2qf7V4nFmuMtJw/640?wx_fmt=png&from=appmsg)

当设备开启虚拟主机模式的情况下，调用函数 virtual_file 进行处理。该函数中使用了 snprintf 构造路径，而且没有对参数 f 进行校验，因此当 req_home 如果等于空，那么就相当于直接访问请求文件路径 f 了。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bK436kw8gjpqQwMxyRdMp5tdI8jcqHAcZBgiag7xViaOKGAU2VjjMLlNlg/640?wx_fmt=png&from=appmsg)

此处补充下关于虚拟主机相关的概念。虚拟主机（Virtual Hosting）模式是 Web 服务器配置的一种方式，它允许服务器在同一物理服务器上托管多个网站域名。

在虚拟主机模式下，Web 服务器在收到 HTTP 请求时会检查请求的 Host 头部，根据这个头部确定请求意图访问的是哪个虚拟主机。也就是说，攻击者可以向存在漏洞的 mini_httpd 发送 HOST 为空的请求头，并将想要读取的文件放在请求行的路径中，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKEFH3D57egt3TcPe1STRs02aLLPLcszjkuzJLLOy66rlibdsBMw1heFQ/640?wx_fmt=png&from=appmsg)

在 mini_httpd 1.30 版本中，对该漏洞进行了修补，大概就是在函数 handle_request 处理请求头的时候对 HOST 新增了一个检查，检查 HOST 是否为空，如果为空则同样返回 400 错误。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKXew0CoMnqLFSJViaqbwaC6W6ECMwXohib6iagjW4EOWmicWowcObeaKqjA/640?wx_fmt=png&from=appmsg)

**案例 2：发生在函数 auth_check 中的认证绕过（CVE-2021-35973）**

发生在 netgear wac104 设备、固件版本 1.0.4.15 之前的身份认证绕过漏洞，漏洞产生的原因是在鉴权过程中，使用了 strstr 来判断：如果请求 uri 中包含 currentsetting.htm，设置无需认证标志。因此攻击者可以在需要鉴权的 uri 中包含 currentsetting.htm 标志，从而达到认证绕过的目的。

通过之前的源代码梳理，也明白了 mini_httpd 的登录认证流程，那么可以通过搜索字符串的技巧直接定位到 auth_check 函数。auth_check 函数开头有一段导致后续认证绕过的逻辑，其中有一个 g_bypass_flag=1 时可以直接通过认证。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKo4YbzkGkNPJ4x5baQKrYnU5ufQbv3gL31qC3AiaN9pELDaib6jXMBkWg/640?wx_fmt=png&from=appmsg)

查看变量 g_bypass_flag 的交叉引用，赋值的地方一共包含如下的三处：

1. 当请求 path 中包含 currentsetting.htm 的时候；

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKQVsJwpsOvyecTAdB7LNB78cwrFoKDjSwdgxHrsnHYUVBEZewlu0HjA/640?wx_fmt=png&from=appmsg)

2. SOAPAction 相关，设计的初衷应该是可以访问任意 SOAP 的 xml；

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKCfrA9JbtZKnosrzXiclhIukknwNvibOpS165XVcHPjzO49qKcT2MOZMg/640?wx_fmt=png&from=appmsg)

3. 请求 path 中包含 setupwizard.cgi，但是随后的处理逻辑会调用 exit 退出，因此无法利用。这个可能是当设备首次启动、开始安装向导触发的。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKJtNKbXhu1lSAjw3bMxVe5VwQjnVcH7INrAcECjnFzicd06VKDlSBNYw/640?wx_fmt=png&from=appmsg)

再次返回到 mini_httpd 的源代码中，结合固件中的反汇编

*   首先通过查找 method 后的第一个空格、换行、制表符的方式，获取到 path。但是随后没有对 path 中是否包含 %00 进行判断；
    

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKqnL8YSa6dsIEGOw2Hsl4OiaEm7jRKZTaUCrjyial9a2GmrVzCcW0yHEw/640?wx_fmt=png&from=appmsg)

*   获取到的 path 在内存中大概是：uri\0currentsetting.htm，这导致，strstr 函数返回一个非空值，就设置了 g_bypass_flag，从而通过了 auth_check。
    

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKMcmu4w1vuTt6xvepCqwY18hPrGSdK5gwmYTttibJnylsIK6lvDQ8VQg/640?wx_fmt=png&from=appmsg)

**案例 3：发生在函数 handle_request（CVE-2021-34979）**

发生在 NETGEAR R6260，固件版本 V1.1.0.78_1.0.1 中，处理 SOAPAction 标头由于未判断全局数组 spapServiceName 的边界，导致越界写。写入的数据会以环境变量的形式传递到 setupwizard.cgi 中，进而造成缓冲区溢出。

越界写：发生在处理数据包的函数 handle_request 中，未判断边界。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bK4GM5ByP9nUhM6dx9OvNH51NPJ7mU0Uq6WGKMUZQvg7XLoo5bZS4ib8w/640?wx_fmt=png&from=appmsg)

后续调用 setupwizard.cgi 时，环境变量会传入，并且造成缓冲区溢出。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKNnG5fgwCuOR7fWlkPDAZ0FHuCRP8NeaKEIAC8NSBGLlnf7VMgPcB6Q/640?wx_fmt=png&from=appmsg)

**四**

  

**总  结**

本文选取了 GoAhead 和 mini_httpd 两个 IoT 小设备中常见的 Web server，结合源代码和经典 CVE 对其漏洞挖掘思路进行浅析。但是实际的漏洞挖掘过程中，可能开发者会对 Web server 的代码结合实际业务场景进行较大的改动，本文的浅显思路仅仅作为简单参考。

本文的漏洞示例基本上都是分析了 server 自身存在的漏洞以及认证时可能存在的漏洞，因为认证后相关的漏洞和设备的具体业务代码相关，和 server 原生的代码结构相关行不高。

回想刚开始挖小设备漏洞的时候，都是先找一些关键字符串、然后交叉引用找调用函数、调用函数再一层层交叉引用查看，这个逻辑对于找认证后漏洞没问题，但是如果想要找到认证前相关的漏洞，就要对 server 自身的代码结构有一定的了解，这样才能快速、精确定位到可能的漏洞点处。

进一步展开的话，对于 GoAhead、mini_httpd 此类集成业务代码的 Web server，分析其数据包处理流程、鉴权处理流程对于漏洞自动化挖掘也是非常有帮助的，例如：

*   当开发者去除掉 server 的函数符号时，我们也可以根据函数调用图特征、关键字符串特征等快速判定具体是哪个开源 server、版本是什么，进一步找到源代码为逆向分析提供帮助；
    
*   在静态分析的时候，确定好数据包的 source 点、鉴权函数路径、可能存在漏洞的 sink 点，通过污点快播快速判断指定 Web server 是否可能存在认证前的某些漏洞。
    

  

  

  

  

【版权说明】

本作品著作权归 **OneShell** 所有

未经作者同意，不得转载

![](https://mmbiz.qpic.cn/mmbiz_jpg/9EP6QFMcTmQCQpLkkDAKbEiadDrdAZ8bKyAFn0GUy44dyO75O31J4LDUO9ALJ1nkOevdicGnicncKhC8kazWmfmgA/640?wx_fmt=jpeg&from=appmsg)

**OneShell**

  

天工实验室安全研究员

专注于 IOT 设备的漏洞挖掘和利用。

**往期回顾**

  

**0****1**

[探索 D-Bus 跨进程消息传递中的安全风险](http://mp.weixin.qq.com/s?__biz=Mzk0OTU2ODQ4Mw==&mid=2247484862&idx=1&sn=679fcde9bcd407548872e81202288bb1&chksm=c3571332f4209a240a1f0067b7fb281c2781598080c219150a52f81576d2249737a98d11e616&scene=21#wechat_redirect)

**0****2**

[Windows Hypervisor & 内核调试的几种常见 / 不常见方法](http://mp.weixin.qq.com/s?__biz=Mzk0OTU2ODQ4Mw==&mid=2247484836&idx=1&sn=f0e776483fc492d277b30fa72a063b00&chksm=c3571328f4209a3eb71302c5cb53068ee904ff8f800df3093a19e530b86d5aea4cf4ddb613cc&scene=21#wechat_redirect)

**0****3**

[FortiGate SSLVPN CVE-2024-21762 漏洞利用分析](http://mp.weixin.qq.com/s?__biz=Mzk0OTU2ODQ4Mw==&mid=2247484811&idx=1&sn=2e0407a32ba0c2925d6d857f4cdf7cbb&chksm=c3571307f4209a110d6b28cea9fe59ac0f0a2079c998a682e919860f397ea647fa0794933906&scene=21#wechat_redirect)

**0****4**

[Ghidra 脚本编写：从 IR 到反编译 C](http://mp.weixin.qq.com/s?__biz=Mzk0OTU2ODQ4Mw==&mid=2247484755&idx=1&sn=32ebb9c87513cedf2c9fc4b62752b2e4&chksm=c35713dff4209ac923fc7aea8a54c60360693a303b53784219418b4a3b741593a1d00992bf6d&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_png/oJZWTpJpiae90UpibicIKeZgQTNjebiaOwStfe6MJ5J6RC7F9JDFdX2kaEwibFz7GewNtNyDek6SdENJrXjf0KXA2kg/640?wx_fmt=png)

**每周三更新一篇技术文章  点击关注我们吧！**