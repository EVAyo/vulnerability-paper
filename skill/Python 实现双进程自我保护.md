<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ypWp8MBXWfTfvGcJTYoBow)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/REwWx1OBrpgoILCbCJtoRpu2YCjmo2Dtbez2Bw8VZHyBticY23kBCt3YysHky7AibMxOM8GQIOsibiaHpqKfb022NQ/640?wx_fmt=jpeg)

```
import os
import sys
import ctypes
import subprocess
class DEBUG_EVENT(ctypes.Structure):
    _fields_ = [
        ("dwDebugEventCode", ctypes.c_ulong),
        ("dwProcessId", ctypes.c_ulong),
        ("dwThreadId", ctypes.c_ulong),
        ("u", ctypes.c_ulong * 1024)
    ]
def debug_main():
    # 调试进程主函数
    filename = sys.executable  # 获取自身文件名
    startupinfo = subprocess.STARTUPINFO()
    startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
    process_info = subprocess.STARTUPINFO()
    process_info.dwFlags |= subprocess.CREATE_NEW_CONSOLE
    while True:
        try:
            process = subprocess.Popen([filename], startupinfo=startupinfo, creationflags=subprocess.CREATE_NEW_CONSOLE)
        except Exception as e:
            return
        debug_event = DEBUG_EVENT()
        continue_debugging = ctypes.c_ulong()
        while_do_flag = True
        # 等待调试事件
        ctypes.windll.kernel32.WaitForDebugEvent(ctypes.byref(debug_event), ctypes.c_ulong(-1))
        # 处理调试事件
        if debug_event.dwDebugEventCode == ctypes.c_ulong(1):  # CREATE_PROCESS_DEBUG_EVENT
            continue_debugging.value = 65536  # DBG_CONTINUE
        elif debug_event.dwDebugEventCode == ctypes.c_ulong(5):  # EXIT_PROCESS_DEBUG_EVENT
            while_do_flag = False
        elif debug_event.dwDebugEventCode == ctypes.c_ulong(3):  # EXCEPTION_DEBUG_EVENT
            if debug_event.u.Exception.ExceptionRecord.ExceptionCode == ctypes.c_ulong(80000003):  # EXCEPTION_BREAKPOINT
                continue_debugging.value = 65536  # DBG_CONTINUE
        # 继续调试事件
        ctypes.windll.kernel32.ContinueDebugEvent(debug_event.dwProcessId, debug_event.dwThreadId, continue_debugging)
        if not while_do_flag:
            break
    ctypes.windll.kernel32.CloseHandle(process_info.hProcess)
    ctypes.windll.kernel32.CloseHandle(process_info.hThread)
def main():
    # 主函数
    if not ctypes.windll.kernel32.IsDebuggerPresent():  # 区分调试进程与被调试进程
        debug_main()
    else:
        while True:
            # 被调试进程的主要逻辑
            ctypes.windll.user32.MessageBoxW(None, "微信公众号蓝胖子之家--自我保护进程", "TraceMe", 0)
            # 当被调试进程结束时，重新启动被调试进程
            os.execl(sys.executable, sys.executable, *sys.argv)
if __name__ == "__main__":
    main()

```

**首先，这段代码用于实现一个调试进程的主函数。调试进程是指一个程序能够监视和控制另一个程序的执行过程，常用于调试和分析程序。**

**代码的第一部分是导入模块和库，包括****`o`****`s`****、`sys`、`ctypes`****和****`subprocess`****。这些模块和库提供了操作系统相关的功能和对动态链接库中函数的调用。**

**接下来是定义调试事件结构体****`DEBUG_EVENT`****。这个结构体用于保存调试事件的相关信息，包括调试事件代码、进程 ID、线程 ID 和其他信息。**

**然后是定义调试进程的主函数****`debug_main()`****。这个函数使用一个无限循环来创建子进程并等待调试事件的发生。**

**在循环开始时，获取当前脚本的文件名作为子进程的可执行文件。**

**然后设置子进程的启动信息，包括窗口显示标志和进程信息。**

**在一个无限循环中，尝试创建子进程。如果创建失败，说明无法继续调试，函数返回。**

**在循环内部，定义了调试事件和调试继续标志。调试事件使用****`ctypes.windll.kernel32.WaitForDebugEvent`****函数等待调试事件的发生。**

**根据不同的调试事件代码进行相应的处理：**

*   **如果是创建进程事件，设置调试继续标志为****`DBG_CONTINUE`****，表示继续调试。**
    
*   **如果是退出进程事件，退出循环，结束调试。**
    
*   **如果是异常事件且异常代码为断点，设置调试继续标志为****`DBG_CONTINUE`****，表示继续调试。**
    

**在处理完调试事件后，使用****`ctypes.windll.kernel32.ContinueDebugEvent`****函数继续调试事件。**

**如果退出循环，则关闭进程和线程的句柄，结束调试。**

**接下来是定义主函数****`main()`****。这个函数是程序的入口函数。**

**首先通过****`ctypes.windll.kernel32.IsDebuggerPresent()`****函数判断当前进程是否处于调试状态。**

**如果不是调试进程，则调用****`debug_main()`****函数进入调试进程。**

**如果是调试进程，则进入一个无限循环：**

*   **弹出一个消息框显示提示信息，用于提示用户当前进程正在被调试。**
    
*   **当被调试进程结束时，使用****`os.execl()`****函数重新启动被调试进程，实现自我保护的功能。**
    

**最后，在****`__name__ == "__main__"`****的判断下，执行主函数****`main()`****。**

**运行效果：**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/REwWx1OBrpgoILCbCJtoRpu2YCjmo2DthCh7WFAHfx89g3hoopsr9ABjIOHznVP8yR59w8B4IMVhppQrO6aOlg/640?wx_fmt=jpeg)

**具体来说，它创建了两个进程：一个是被调试进程，另一个是调试进程。被调试进程是要被保护的主要进程，而调试进程则用于监视和保护被调试进程的执行。**  

**被调试进程的主要逻辑在****`main()`****函数中，它会在一个无限循环中执行。当被调试进程处于被调试状态时，会弹出一个消息框显示提示信息，并在被调试进程结束后使用`os.execl()`函数重新启动被调试进程。**

**调试进程的主要逻辑在`debug_main()`函数中，它也在一个无限循环中执行。调试进程会创建子进程，并等待调试事件的发生。根据不同的调试事件进行相应的处理，如创建进程事件、退出进程事件和异常事件。调试进程通过监视和控制被调试进程的执行，实现了对被调试进程的保护。**

**通过这种双进程的机制，被调试进程可以在被调试状态下正常运行，而调试进程可以监控和保护被调试进程的执行，提高了被调试进程的安全性和稳定性。**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/REwWx1OBrpgoILCbCJtoRpu2YCjmo2DtI9vnahQkaZNAyvQDrFxnRl1hAWiaCCaTS1OricjGwfO8to85lm5demibA/640?wx_fmt=jpeg)

**后台回复** **11.11** **获取文章工具**

<table width="677"><tbody><tr><td width="557" valign="top" data-style="outline: 0px; word-break: break-all; hyphens: auto; border-color: rgb(76, 76, 76);"><strong>非常重要的一点是，我们要明确使用计算机和编程技术的目的是为了学习和测试，而不是进行非法攻击或者违法行为。编写和使用代码时，我们必须遵守法律法规，并且获得相关授权。如果您有合法的目的和授权，那么可以继续进行测试和使用。但是，如果您违反了法律法规或者未经授权使用，后果将由您自己承担。请务必谨慎行事，遵守法律规定，以确保计算机和网络的安全。</strong></td></tr></tbody></table><table width="677"><tbody><tr><td width="557" valign="top" data-style="outline: 0px; word-break: break-all; hyphens: auto; border-color: rgb(76, 76, 76);">小黑板：非法攻击计算机系统是一种违法行为，违反了计算机安全法规。根据中华人民共和国刑法，非法攻击计算机系统可能构成非法侵入计算机信息系统罪、非法获取计算机信息系统数据、非法控制计算机信息系统罪、提供侵入、非法控制计算机信息系统程序、工具罪等罪名。根据《中华人民共和国刑法》规定，违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚。单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚<br></td></tr></tbody></table>