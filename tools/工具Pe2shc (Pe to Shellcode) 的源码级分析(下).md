<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/AuqNCHvORPHJj8wOiM3jyw)

    上一篇不知道大家有没有看糊涂。那个老外作者提出了一种新的运行方式的技巧，确实让我眼前一亮。我以前没有关注过这个问题，也超出了我的认知范围。但现在我该考虑下：“Exe怎么运行”这个问题了？

  

    **一、PE运行原理**

    PE文件本身是无法直接在内存中执行的，windows操作系统需要将PE文件按照规则映射到内存中，并将指令指针指向程序入口就可以执行了，这就是PE loader的工作流程。PE文件本身并不重要，它的执行依赖于PE loader；PE文件功能个个不同，但是PE loader 功能固定，我们只要通过shellcode实现PE loader，就可以达成目标。

  

模型如图：  

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpKYMNkKfMSvH4icgUibGmHwWuwhEs1l1CYEBlibrwex952SZuRGLvOQia564SIDPicw1Z8Fr344KfC8Kxw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

将Stub是附加在PE文件后面，并对PE文件头部进行修改实现跳转，从而实现PE文件“创新突破”。

  

在新模型中，Stub可以不用改变，直接附加在PE文件的最后，对PE文件的头部添加一段跳转shellcode，而且这段shellcode必须以"MZ"开头，这样才能被识别为正常的PE文件。PE文件的头部是DOS头，其结构如下，比较重要的是00H处的e_magic和3CH处的e_lfanew，而其他的位置内容改变不太受影响：  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

紧跟着E_lfanew的是一个MS-DOS程序。那是一个运行于MS-DOS下的合法应用程序。当可执行文件（一般指exe、com文件）运行于MS-DOS下时，这个程序显示“This program cannot be run in DOS mode（此程序不能在DOS模式下运行）”这条消息。

  

### **二、PE loader的实现**

**1、kernel基地址**

  实现PE Loader需要找到GetProcAddress，LoadLibraryA，VirtualAlloc 三个关键API的地址:

1.  LoadLibraryA 用来加载动态链接库；
    
2.  GetProcAddress 用来获取动态链接库中的API函数地址；
    
3.  VirtualAlloc 用于为PE文件分配内存空间；
    

    这三个API位于kernel32.dll中，而每个进程启动都会自动加载kernel32.dll，因此需要先找到进程中的kernel32.dll基址，然后再通过偏移量找到API的入口地址。寻找进程中的kernel32.dll基地址,分为三个步骤：

  

**(1)TEB and PEB**

    TEB(线程环境块)中保存频繁使用的线程相关的数据。进程中的每个线程都有自己的一个TEB。一个进程的所有TEB都以堆栈的方式，PEB(进程环境块)存放进程信息，每个进程都有自己的PEB信息。

  

    通过FS寄存器可以获取TEB的基址：在FS存储的是TEB在GDT 中的序号，通过GDT获取TEB的基址。PEB结构体在TEB偏移0x30处，即FS:[0x30]。

  

**(2)Ldr**

    在PEB偏移0x0c处是Ldr，Ldr的类型为PEB_LDR_DATA结构体指针。

  

    Ldr的作用是存储进程已加载的模块(Module)信息。Module是指PE格式的可执行映像，包括EXE映像和DLL映像。

  

    Ldr通过3个队列存储进程加载的Module信息，即InLoadOrderModuleList、InMemoryOrderModuleList、和InInitializationOrderModuleList，我们选择的是InLoadOrderModuleList，加载的模块顺序如下：

```
自身.exe -> ntdll.dll -> kernel32.dll ->KERNELBASE.DLL -> NULL

```

```
  mov ebx, fs:[ 0x30 ]       // 获得PEB
  mov ebx, [ ebx + 0x0C ]    // 获得PEB_LDR_DATA
  mov ebx, [ ebx + 0x0C ]    // InLoadOrderModuleList第一项
  mov ebx, [ ebx ]           // InLoadOrderModuleList第二项
  mov ebx, [ ebx ]           // InLoadOrderModuleList第三项


  mov ebx, [ ebx + 0x18 ]    // 获得完整的路径地址，此时偏移0x18




同理，InMemoryOrderModuleList也可以发现类似的规律。




```

**(3)****LDR_DATA_TABLE_ENTRY**

    每当为本进程装入一个模块时，就要为其分配、创建一个LDR_DATA_TABLE_ENTRY数据结构，并将其挂入InLoadOrderModuleList和InMemoryOrderModuleList，完成对这个模块的动态链接以后，就把它挂入InInitializationOrderModuleList队列，以便依次调用模块的初始化函数。由此可见进程加载的每个模块都会有一个LDR_DATA_TABLE_ENTRY，其作用为存储模块的基本信息，DLL基址在其偏移0x18处。

typedef struct _LDR_DATA_TABLE_ENTRY {

```
LIST_ENTRY     InLoadOrderModuleList;
//代表按加载顺序构成的模块链表
LIST_ENTRY     InMemoryOrderModuleList;
//代表按内存顺序构成的模块链表
LIST_ENTRY     InInitializationOrderModuleList;
//代表按初始化顺序构成的模块链表
PVOID      BaseAddress;
//该模块的基地址
PVOID      EntryPoint;
//该模块的入口
ULONG      SizeOfImage;
//该模块的影像大小
UNICODE_STRING FullDllName;
//包含路径的模块名
UNICODE_STRING BaseDllName;
//不包含路径的模块名
ULONG      Flags;
SHORT LoadCount;
//该模块的引用计数
SHORT      TlsIndex;
HANDLE     SectionHandle;
ULONG      CheckSum;
ULONG      TimeDateStamp; 
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

```

这三步看似复杂，但最终的汇编代码 很简单：

push    tebProcessEnvironmentBlock 

pop     eax 

fs mov  eax, dword [eax];定位PEB 

mov     eax, dword [eax + pebLdr] ;找到ldr 

mov     esi, dword [eax + ldrInLoadOrderModuleList];找到ldrInLoadOrderModuleList 

lodsd    ；不断的向后寻找kernel

xchg    eax, esi 

lodsd 

mov     ebp, dword [eax + mlDllBase];kernel dll的基地址 

call    parse_exports

####   

几者间的关系：

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

#### **2、定位API**

    我们找到了kernel32.dll的基地址，接下来通过偏移量找到kernel32.dll的导出表，最后通过导出表找到api的入口地址。导出表的结构如下，最终要找到AddressOfFunctions。

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

mov edi, ebp

mov eax, ebp

add edi, dword [ebx + _IMAGE_EXPORT_DIRECTORY.edAddressOfNameOrdinals]

movzx edi, word [edi + edx * 2]

add eax, dword [ebx + _IMAGE_EXPORT_DIRECTORY.edAddressOfFunctions]

mov eax, dword [eax + edi * 4]

add eax, ebp

push    eax

lodsd

sub cl, byte [esi]

jnz walk_names

  

#### **3、映射PE文件到内存**

1.  使用VirtualAlloc分配内存
    
2.  映射map MZ header, NT Header, FileHeader, OptionalHeader, all section headers；
    
3.  映射sections data；
    

#### **4、导入dll 并重定向地址**

    使用LoadLibraryA循环加载PE文件导入表中的dll；

        pushad

        mov     cl, IMAGE_DIRECTORY_ENTRY_IMPORT

        mov     ebp, dword [ecx + ebp]  

        test    ebp, ebp    ;check if PE has import table

        je      import_popad     ;if import table not found, skip loading

        add     ebp, edi

import_dll:

        mov     ecx, dword [ebp + _IMAGE_IMPORT_DESCRIPTOR.idName]

        jecxz   import_popad

        add     ecx, dword [ebx]

        push    ecx

        call    dword [ebx + mapstk_size + krncrcstk.kLoadLibraryA]

        xchg    ecx, eax

        mov     edi, dword [ebp + _IMAGE_IMPORT_DESCRIPTOR.idFirstThunk]

        mov     esi, dword [ebp + _IMAGE_IMPORT_DESCRIPTOR.idOriginalFirstThunk]

        test    esi, esi    ;if OriginalFirstThunk is NULL... 

        cmove   esi, edi    ;use FirstThunk instead of OriginalFirstThunk

        add     esi, dword [ebx]

        add     edi, dword [ebx]

import_thunks:

        lodsd

        test    eax, eax

        je      import_next

        btr     eax, 31

        jc      import_push

        add     eax, dword [ebx]

        inc     eax

        inc     eax

import_push:

        push    ecx

        push    eax

        push    ecx

        call    dword [ebx + mapstk_size + krncrcstk.kGetProcAddress]

        pop     ecx

        stosd

        jmp     import_thunks

import_next:

        add     ebp, _IMAGE_IMPORT_DESCRIPTOR_size

        jmp     import_dll

import_popad:

        popad

####   

#### **5、设置入口点并执行**

xor  ecx, ecx

mov     eax, dword [ebp + _IMAGE_NT_HEADERS.nthOptionalHeader + _IMAGE_OPTIONAL_HEADER.ohAddressOfEntryPoint]

add eax, dword [ebx]

call eax

  
    临近结尾，我将一个《PE to ShellCode》的源码分析完了，其中涉及到大量的PE结构等，光是各种链表就花去很多时间。虽然辛苦一点，但好歹用三个篇章跟上作者的思路，解开了这个谜底，实在是收获良多。总体感觉是：在深层次技术细节创新上，老外还是有很多好的奇思妙想，在运用上有很独到的理解，值得我学习。希望你们读完这三个章节，也能有所收获。  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)