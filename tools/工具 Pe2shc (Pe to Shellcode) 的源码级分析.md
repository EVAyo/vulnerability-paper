<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/molkMtcwxB8IwCL6m6UEvQ)

    **导读：**在本篇中，我将会对到由 C++ 和汇编组合而成的源码级工具进行分析讲解，学习到如何将 EXE 转化成 Shellcode。通过学习，我们为能窥见天才高手们天马行空般的思维而欢呼雀跃，彼时我们也是非常愉悦的，因为我们离天才是如此的近。    

    shellcode 一直是无文件执行的主题，我们经常要生成 shellcode，但用 msf 生成的一般免杀效果不尽人意。如何能让提取 shellcode 变得简单，是大家的共同想法。

    有人提出了 “将 PE 直接转为 shellcode”，因为编写 PE 是相对简单得多。在 Git 上有人给出了这么个程序，直接可以将 PE/ELF 转化为 shellcode，我们来看看。

    这个项目很有意思, 通过加壳的方式将 exe 文件转为了 shellcode，且转化后的文件依然是完整的 PE 文件，不仅可以单独运行，也可以通过 shellcode 的方式运行。为什么会这样，它采用了病毒的方式，将 stub 加在 shellcode 的尾部，在头部设置，最后加载完整的 PE。

下载地址：https://github.com/hasherezade/pe_to_shellcode

**一、演示**

   共有三部分程序：pe2shc.exe、runshc32.exe 和 runshc64.exe。

用 calc 来演示，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyM9tc6PmOEwcGVXL55PRNB7F4bhl9huNeyyvTZEjcqpFV2UqMvFsUzFw/640?wx_fmt=png)

执行 pe2shc calc64.exe calc64_modify.exe，生成 calc 的加了 shellcode 的新程序，运行看看，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMhXV7sOfic7dXzcKHMk7YqPtYsjQUrKOnZBXeU772DwPguVmR2lfpQGw/640?wx_fmt=png)

可以运行，弹出计算器。 

**二、分析过程**

 **这里，我主要是对 runshc、pe2shc 进行分析，**涉及到 PE 头格式，**全是干货；stub.asm 放在下一篇中，涉及到 PEB。**

    我们用 runshc64.exe calc_modify.exe 也可以执行后弹出计算器，

1、分析 runshc 的源码，发现：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyM6xTxRvia3svw6Hlx86B8Bf5jjErrheaSyAiaFJicvubdfC9o4FPmhZzdA/640?wx_fmt=png)

在上述代码中，主要做了三件事：

A、读取 exe 文件到缓冲区

B、给 exe 文件分配可读可写可执行的内存，并将缓冲区中的内容复制到这段内存中

C、从内存中执行代码

2、我们来分析下怎么生成 shellcode 的，即 pe2shc 的源码，

这里面有个重要的代码段 shellcodify，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMVShRRK6pIzlIiaQhTlvB0yibAt8ZHHZrkD0Vxd0f7hWPa27SQL3kCasw/640?wx_fmt=png)

我进行了注释，解释了每个含义，这里面又涉及到一个重要的函数 overwrite_dhr，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMugmqqcM5VhcVqGKrRcCcTtl7GlcbUZevRWSsrzuiaknK3r8YvPpib53Q/640?wx_fmt=png)

在作者源码中，加入了红框的汇编含义，但黄框中的 4D5A 暴露了这是 EXE 的头，所以这些汇编解释压根就是无意义的，只能乱人思维，误导读代码的人。去掉这些干扰，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMC9uZqIYGZM1IWPhcwTgxEj7fJuDCbicCd3D2g3LicEHlEYF5PmzPoA8w/640?wx_fmt=png)

原来是将后面 stub 的位置偏移写入到 Initial Ip Value 处，我们来看下 calc_modify.exe 的 PE 头的此处，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMwpWIvlnqiaJ7f1WWjqs9rbGDj7XiaIus48xGErB3q4tdYAFcpQco3paQ/640?wx_fmt=png)

跟设定值比较，只能这里发生了变化，说明填入了 stub 偏移的值。

这里是 B000H，我们来看看 calc_modify.exe 的 B000H 处是什么？

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMNNficfjgtjbVr4ytLysDAyib3ic055JR13PF3Sd7zc5vq9gibpib4WCqEkg/640?wx_fmt=png)

B000H 处开头有个 “53 56 57” 开头的一段，可能是加入的 stub，我们来看看 stub64.bin 的十六进制，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMulA8M3qVwTs8qghBI63Q9TFURC5temq8icZQO64J4yREYL5kqibsXb9Q/640?wx_fmt=png)

果然如此，stub 确实加入在了 exe 的尾部。

将 stub 的十六进制转化为汇编看看，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMsB41BtMbDkgYJMN4GtiapTPXxYY6Bg9yEZSYy9GUKu5QqmjmI8957Uw/640?wx_fmt=png)

3、汇编代码

源代码中提供了这段 stub，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLNpwzIrBvicctH3hTOThoyMPWgr1yAXbNtDpoey3ufZicY20YwLrfibypbHcqOz1aejbpN4MicBAAx1Q/640?wx_fmt=png)

将汇编写的这段单列出来，供学习，  

bits 64

%include "hldr64.inc"

;-----------------------------------------------------------

;here begins HLDR64

;-----------------------------------------------------------

hldr64_begin:

        push    rbx

        push    rsi

        push    rdi

        push    r12

        push    r8

        push    r9

regstksize      equ     30h

;-----------------------------------------------------------

;recover kernel32 image base

;-----------------------------------------------------------

        push    tebProcessEnvironmentBlock

        pop     rsi

        gs lodsq

        mov     rax, qword [rax + pebLdr]

        mov     rsi, qword [rax + InMemoryOrderModuleList]

        lodsq

        xchg    rax, rsi

        lodsq

        mov     rbp, qword [rax + mDllBase]

        call    parse_exports

        dd      0C97C1FFFh               ;GetProcAddress

        dd      03FC1BD8Dh               ;LoadLibraryA

        db      0

;-----------------------------------------------------------

;parse export table

;-----------------------------------------------------------

parse_exports:

        pop     rsi

        mov     eax, dword [rbp + lfanew]

        mov     ebx, dword [rbp + rax + IMAGE_DIRECTORY_ENTRY_EXPORT]

        add     rbx, rbp

        cdq

walk_names:

        inc     edx

        mov     eax, dword [rbx + _IMAGE_EXPORT_DIRECTORY.edAddressOfNames]

        add     rax, rbp

        mov     edi, dword [rax + rdx * 4]

        add     rdi, rbp

        or      eax, -1

crc_outer:

        xor     al, byte [rdi]

        push    8

        pop     rcx

crc_inner:

        shr     eax, 1

        jnc     crc_skip

        xor     eax, 0edb88320h

crc_skip:

        loop    crc_inner

        inc     rdi

        cmp     byte [rdi], cl

        jne     crc_outer

        not     eax

        cmp     dword [rsi], eax

        jne     walk_names

;-----------------------------------------------------------

;exports must be sorted alphabetically, otherwise GetProcAddress() would fail

;this allows to push addresses onto the stack, and the order is known

;-----------------------------------------------------------

        mov     edi, dword [rbx + _IMAGE_EXPORT_DIRECTORY.edAddressOfNameOrdinals]

        add     rdi, rbp

        movzx   edi, word [rdi + rdx * 2]

        mov     eax, dword [rbx + _IMAGE_EXPORT_DIRECTORY.edAddressOfFunctions]

        add     rax, rbp

        mov     eax, dword [rax + rdi * 4]

        add     rax, rbp

        push    rax

        lodsd

        sub     cl, byte [rsi]

        jne     walk_names

;-----------------------------------------------------------

;allocate space for mapstk, and make stack frame

;allocate space for shadow stack only once then align stack because at this time

;we don't know if aligned for sure

;---------------------------------------------------------- 

        push    rcx

        push    rcx

        push    rsp

        pop     rbx

        sub     rsp, 40h                 ;only 20h bytes required for shadow stack

        and     rsp, -10h                ;align on 16-byte boundary

;-----------------------------------------------------------

;save the pointers to the PE structure

;-----------------------------------------------------------

        mov     rsi, qword [rbx + mapstk_size + krncrcstk_size + regstksize + 8]

        mov     ebp, dword [rsi + lfanew]

        add     rbp, rsi

        mov     rax, rsi

        mov     qword [rbx], rsi

        mov     rdi, rsi

;-----------------------------------------------------------

;import DLL

;-----------------------------------------------------------

         mov     r12, rbp

        mov     cl, IMAGE_DIRECTORY_ENTRY_IMPORT

        mov     ebp, dword [rcx + rbp]

        test    ebp, ebp                 ;check if PE has import table

        je      import_poprbp            ;if import table not found, skip loading

        add     rbp, rax

import_dll:

        mov     ecx, dword [rbp + _IMAGE_IMPORT_DESCRIPTOR.idName]

        jecxz   import_poprbp

        add     rcx, qword [rbx]

        call    qword [rbx + mapstk_size + krncrcstk.kLoadLibraryA]

        mov     qword [rbx + mapstk.hModule], rax

        mov     edi, dword [rbp + _IMAGE_IMPORT_DESCRIPTOR.idFirstThunk]

        mov     esi, dword [rbp + _IMAGE_IMPORT_DESCRIPTOR.idOriginalFirstThunk]

        test    esi, esi

        cmove   esi, edi                 ;if OriginalFirstThunk is NULL, esi = edi = FirstThunk

        add     rdi, qword [rbx]

        add     rsi, qword [rbx]

        add     rbp, _IMAGE_IMPORT_DESCRIPTOR_size

import_thunks:

        lodsq

        test    rax, rax

        je      import_dll

        btr     rax, 63

        jc      import_mov

        add     rax, qword [rbx]

        inc     rax

        inc     rax

import_mov:

        push    rax

        pop     rdx

        mov     rcx, qword [rbx + mapstk.hModule]

        call    qword [rbx + mapstk_size + krncrcstk.kGetProcAddress]

        stosq

        jmp     import_thunks

import_poprbp:

        mov     rbp, r12                 ;restore because r12 uses prefix

;-----------------------------------------------------------

;apply relocations

;-----------------------------------------------------------

        mov     edi, dword [rbp + IMAGE_DIRECTORY_ENTRY_RELOCS]

        add     rdi, qword [rbx]

reloc_block:

        push    IMAGE_BASE_RELOCATION_size

        pop     rdx

reloc_addr:

        movzx   rax, word [rdi + rdx]

        push    rax

        and     ah, 0f0h

        cmp     ah, IMAGE_REL_BASED_DIR64 << 4

        pop     rax

        jne     reloc_abs                ;another type not DIR64

        and     ah, 0fh

        add     eax, dword [rdi + IMAGE_BASE_RELOCATION.rePageRVA]

        add     rax, qword [rbx]         ;new base address        

        mov     rsi, qword [rax]

        sub     rsi, qword [rbp + _IMAGE_NT_HEADERS.nthOptionalHeader + _IMAGE_OPTIONAL_HEADER.ohImageBasex]

        add     rsi, qword [rbx]

        mov     qword [rax], rsi

        xor     eax, eax

reloc_abs:

        test    eax, eax                 ;check for IMAGE_REL_BASED_ABSOLUTE

        jne     hldr_exit                ;not supported relocation type

        inc     edx

        inc     edx

        cmp     dword [rdi + IMAGE_BASE_RELOCATION.reSizeOfBlock], edx

        jg     reloc_addr

        add     ecx, edx

        add     rdi, rdx

        cmp     dword [rbp + IMAGE_DIRECTORY_ENTRY_RELOCS + 4], ecx

        jg     reloc_block

reloc_finished:

;-----------------------------------------------------------

;call entrypoint

;-----------------------------------------------------------

        mov     eax, dword [rbp + _IMAGE_NT_HEADERS.nthOptionalHeader + _IMAGE_OPTIONAL_HEADER.ohAddressOfEntryPoint]

        add     rax, qword [rbx]

        call    rax

;-----------------------------------------------------------

;if fails or returns from host, restore stack and registers and return (somewhere)

;-----------------------------------------------------------

hldr_exit:

     lea     rsp, qword [rbx + mapstk_size + krncrcstk_size]

        pop     r9

        pop     r8

        pop     r12

        pop     rdi

        pop     rsi

        pop     rbx

        ret     8

    至于这段汇编的作用，我放在下一讲中讲解。要不然就太长了。

    明天就大年三十了，在这里祝广大的朋友们新年快乐，身体健康，万事如意，心想事成！！！

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpKT5McvSHT7LobibdKeCmJq58XibMLC9iaEnpmHhwI49WqibNGMtQJ4mCxrpj47OP3XUxt4SF3Jb4HjBw/640?wx_fmt=jpeg)