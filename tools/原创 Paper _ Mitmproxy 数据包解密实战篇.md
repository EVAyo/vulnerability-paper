<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/MK6dgJq8PPVwi6s8Hgrhvw)

**作者：********Sunflower**@知道创宇 404 实验室****

**时间：**2024 年 6 月 17 日****

  

  

  

**1 前言**

mitmproxy 是一组工具，提供用于 HTTP/1、HTTP/2 和 WebSocket 的交互式、支持 SSL/TLS 的拦截代理。[1]。

一般提到的 mitmproxy 指代了 mitmproxy、mitmweb 和 mitmdump，尽管它们提供的功能相同，但接口不同，分别适用于不同的使用场景。

<table><thead><tr><th width="86">名称</th><th width="132">描述</th></tr></thead><tbody><tr><td width="106">mitmproxy</td><td width="112">一个交互式的、支持 SSL/TLS 的拦截代理，具有用于 HTTP/1、HTTP/2 和 WebSockets 的控制台界面。</td></tr><tr><td width="106">mitmweb</td><td width="112">mitmproxy 的基于网页的界面。</td></tr><tr><td width="106">mitmdump</td><td width="112">mitmproxy 的命令行版本。可以将其理解为 HTTP 的 tcpdump。</td></tr></tbody></table>

对于安全研究人员来说，mitmproxy 可以用于拦截加密数据包，然后通过解密数据并代理到 BurpSuite，得到的明文数据包更方便进行安全研究和渗透测试。

  

  

**2 安装**

macOS 安装 mitmproxy 如下，其他系统可以从官网下载 [2]

```
brew install mitmproxy

```

  

  

**3 基本使用**

上文介绍过 mitmproxy、mitmweb、mitmdump 三者的区别，对于想要持久化修改流量的场景 mitmdump 更适合，下面将用 mitmdump 做演示。

使用 mitmdump 的 2 个步骤如下：

### **3.1 编写插件**

官方提供了部分插件编写的例子 [3]，例如 http-add-header.py：

如下代码主要实现了在每个 response 中添加 HTTP 头。

```
class AddHeader:
    def __init__(self):
        self.num = 0

    def response(self, flow):
        self.num = self.num + 1
        flow.response.headers["count"] = str(self.num)

addons = [AddHeader()]

```

### **3.2 命令行启动**

```
mitmdump -s http-add-header.py -p 6666

```

此时将浏览器代理设置为 6666 端口，如图 1，就可以实现正常的改包了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibY0brTsOQ0Nce0fKuaiaDSWyovpFia6BgS2SfY5fZ3RSZiaVdTwY1vY2Cyw/640?wx_fmt=png&from=appmsg)

图 1 配置浏览器代理

  

  

  

**4 应用实战**

  

参考资料

某应用接口数据加密（如图 2 所示），这导致不太方便对数据包内容进行直接判断，这种情况可以通过 mitmproxy 实现查看和编辑明文数据。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYUMfMw8sVCDaz4VdphMia3zjzOnYSM2ypIxwwiaCqdzDLf0b2v1wEp93Q/640?wx_fmt=png&from=appmsg)

图 2 应用数据包

### **4.1 应用加密 / 解密分析**

在应用程序的 jar 包中查找对应的加密类，类中方法的部分代码如下：

```
public static String[] decode(String data) {
      byte[] dataByte = CodeHandler.strToByteArrayByUTF8(data);
      dataByte = CodeHandler.deCode(dataByte);
      String decodedData = CodeHandler.byteArrayToStrByUTF8(dataByte);
      ......

```

从上述代码可以看出，代码首先将 str 转换为 byte，然后使用解密函数进行解密，最后再将 byte 转换回 str。

继续跟进到 CodeHandler.deCode，其代码如下：

```
public byte[] decode(byte[] dataByte) {
    int i = 0;

    for(int j = 0; j < dataByte.length; ++j) {
        byte tmp = dataByte[i];
        if (tmp > 0 && tmp < decodeArray.length) {
            byte encodeChar = decodeArray[tmp];
            if (encodeChar != 0) {
                dataByte[i] = encodeChar;
            }
        }

        ++i;
    }

    return dataByte;
}

```

所以根据 java 代码写出的 python 加密解密脚本如下：

```
import logging
import re

class Mimit():
    decode_array = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        32, 87, 0, 0, 0, 47, 0, 56, 97, 89, 84, 43, 0, 103, 106, 37, 113, 49, 121, 78, 114, 112, 110, 48,
        76, 55, 123, 0, 0, 0, 0, 0, 0, 40, 88, 120, 115, 41, 77, 107, 71, 104, 53, 52, 80, 54, 51, 65,
        33, 117, 105, 108, 68, 90, 66, 83, 122, 81, 86, 93, 0, 91, 0, 102, 0, 69, 119, 73, 109, 126, 45,
        118, 100, 99, 82, 116, 75, 57, 39, 79, 101, 46, 72, 42, 67, 50, 74, 111, 70, 95, 85, 58, 0, 0, 98, 0
    ]

    def request(self, flow):
        if flow.request.path.endswith("/RMIServlet") and flow.request.method == "POST":
            req = flow.request.get_text()
            logging.info("requestData：" + req)
            match = re.search(r'encode=([^&]+)', req)
            decoded_str = ""
            if match:
                encode_value = match.group(1)
                data_byte = bytearray(encode_value, "UTF-8")
                decoded_byte = self.decode(data_byte)
                decoded_str = decoded_byte.decode("UTF-8")
                logging.info(decoded_str)
            else:
                logging.info("Encode value not found")
            array = decoded_str.split("+")
            data = f'className={array[0]}&methodName={array[1]}¶ms={array[2]}'
            flow.request.set_text(data)

    def response(self, flow):
        if flow.request.path.endswith("/RMIServlet") and flow.request.method == "POST":
            response = flow.response.get_text()
            data_byte = bytearray(response, "UTF-8")
            encoded_byte = self.encode(data_byte)
            encoded_str = encoded_byte.decode("UTF-8")
            flow.response.set_text(encoded_str)

    def decode(self, data_byte):

        for i in range(len(data_byte)):
            tmp = data_byte[i]
            if 0 < tmp < len(self.decode_array):
                encode_char = self.decode_array[tmp]
                if encode_char != 0:
                    data_byte[i] = encode_char
        return data_byte

    def encode(self, data_byte):
        for i in range(len(data_byte)):
            tmp = data_byte[i]
            if 0 < tmp < len(self.decode_array) and tmp not in (37, 47):
                encode_char = self.decode_array[tmp]
                if encode_char != 0:
                    data_byte[i] = encode_char
        return data_byte


addons = [Mimit(), ]

```

### **4.2 代理配置**

使用`--mode upstream:`来设置上游代理联动 BurpSuite，加上`--ssl-insecure`忽略 SSL 证书验证：

```
mitmdump -p 6666 -s main.py  --mode upstream:http://127.0.0.1:6662 --ssl-insecure

```

浏览器插件配置和图 1 同理，BurpSuite 配置 Proxy listeners，如图 3 所示。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYtGm4QgibPaAQzrzP0grvIR8zds7KicRfrKwOthiauljDWuGXuyUEJEZEw/640?wx_fmt=png&from=appmsg)

图 3 BurpSuite 配置

浏览器发送数据包的顺序如图 4 所示。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYHc7wnnSzI9QyqRCaD379Lgic7gUTeHKcDyQWtI0WJa6kZmAtPmcvATw/640?wx_fmt=png&from=appmsg)

图 4 数据包流程图

有人可能会对流程图感到困惑：为何要在解密后将数据传递给 BurpSuite 和服务器，再对返回结果进行加密后再提供给浏览器？这是因为该程序的服务器端能够识别类似于`className=xxx&methodName=xxx`的明文传递，但服务器返回的结果也是明文，如图 5。如果结果是明文，该程序前端 JavaScript 代码将无法识别返回值，导致网页加载失败。因此，需要对服务器返回的明文数据进行加密处理。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYD2TN7mibJHWt8ETO7FGTNEyFMu9zIGn2AoTy92icQJiacibgrdJ3ZJiaPQA/640?wx_fmt=png&from=appmsg)

图 5 明文传递数据包

所以当根据上文配置好后，便可以成功拦截到明文数据包了，如图 6。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYgTHia8p3loMYBtT1OIUmaGwianNWyiaHJgZ2LYhyqb3icjcWjVGBN7tALA/640?wx_fmt=png&from=appmsg)

图 6 明文数据包

  

  

  

 **5 其他方式**

  

参考资料

在某些情况下，我们需要的数据包流程图如图 7，这种情况是在某些服务器只支持识别密文时，让我们也能够在 BurpSuite 上捕获并编辑明文数据，再将其加密后发送给服务器。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYtzxXWw7EibF0OFROLqF88VibLM6eoicZBiafBoESMkibgSoxGia0JBje6xBQ/640?wx_fmt=png&from=appmsg)

图 7 流程图

这种情况配置内容应该如下：

1、首先启动第一个 mitmdump，定义好自己的解密脚本并将解密后的内容传递给 BurpSuite。

```
mitmdump -p 6666 -s dec.py  --mode upstream:http://127.0.0.1:6662 --ssl-insecure

```

2、再启动第二个 mitmdump，定义好加密脚本。

```
mitmdump -p 7777 -s enc.py

```

同时配置好 BurpSuite 的 UpStream proxy servers，如图 8。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT00KJ5jeiaA8qZ4Nfy6xJGibYvaKxibpEjYxQkn7k24LCYIF95FZNJrBsUVDFMADG2oCZLmicIHYKc3nA/640?wx_fmt=png&from=appmsg)

图 8 BurpSuite 配置 UpStream proxy servers

这样就能将从 BurpSuite 出来的流量再次进行加密了。

**6 参考链接**

  

参考资学完了前面三个程序后，可以说已经入门了单片机开发，能进行以下几种基础操作：控制端口输出，编写中断函数，通过 uart 口输出调试信息。

[1] https://mitmproxy.org/

[2] https://mitmproxy.org/downloads/

[3] https://docs.mitmproxy.org/stable/addons-examples/

[4] https://xz.aliyun.com/t/13218

  

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0mSRTxbY7fsoLUFViaxk1nhQByibgTdbwbMqNibWMKbHKrjwUUY8GNZlAoUlcic5ibVhyCebVwoNialnow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

  

  

  

**作者名片**

  

  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/3k9IT3oQhT0EJSbibGUh8VN6G4K6Peok7lDa0wDaBABAljmdwl0iaticu0Fd9WY2w2qmcIjpZBMEibcibZTzV00XaTQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT0Z79Hq9GCticVica4ufkjk5xiarRicG97E3oEcibNSrgdGSsdicWibkc8ycazhQiaA81j3o0cvzR5x4kRIcQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

**往 期 热 门**

(点击图片跳转）

[![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT3vAI84tepnCZXM6icBicx9QP9sGI4cMrJSDQibMiabetuib2yzebaqV1cibddQVV2J6Ho1n6IVAib39ULkw/640?wx_fmt=png&from=appmsg)](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650979026&idx=1&sn=7aa8dce637a665cd7f929f18a665dd69&chksm=8079f8e0b70e71f6fcaed5ab7cbe556fe427b66f9c40a19bea137686b9d56fc7387b15dd3685&scene=21#wechat_redirect)[![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/3k9IT3oQhT1UBDUqTNfPvb7WRR7tlfo2GBGdrJJ4ujjcicQf33qVf52D1NxXqfPbeHwUrM8YVz3dX3xS72FhsBw/640?wx_fmt=jpeg&from=appmsg)](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650978895&idx=1&sn=9a46e408102150a096c3bb4e47368636&chksm=8079f87db70e716bbe82d72b7ab9516ef348beccc4bc094e1a111c647bff8fad9f81963fd6ca&scene=21#wechat_redirect)[![](https://mmbiz.qpic.cn/sz_mmbiz_png/3k9IT3oQhT3iccoaic56A3wgDBG6icIMMtKdHoS1NST0XGZboSxQrxl222TVHw8rCiajUlxhZBic4yrPKTwj2qQdLicw/640?wx_fmt=png&from=appmsg)](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650978890&idx=1&sn=15850b0b2614848b4eb122f3f10171ff&chksm=8079f878b70e716ece3de65bda914b84e789d858df4a23d59c8fc0a8452f01e29551a95f5ed6&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT3XlD8Odz1EaR5icjZWy3jb8ZZPdfjQiakDHOiclbpjhvaR2icn265LYMpu3CmR1GoX707tWhAVsMJrrQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

戳 “阅读原文” 更多精彩内容!