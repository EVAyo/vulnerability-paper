<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/vQZGZeiqt4tvdoKxiA8Igg)

> ❝
> 
> 最近温习了一下移动端端相关测试，整理了一下平常使用最多的一些命令，在这里做个记录，仅做常用记录，部分需要拓展的粘贴有 URL

安装 python 虚拟环境
==============

```
# 安装virtualenv
pip3 install virtualenv
# 安装拓展包
pip3 install virtualenvwrapper

# 环境配置，文件：~/.bashrc
export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/Devel
export VIRTUALENVWRAPPER_PYTHON=</usr/local/bin/python3:python的运行环境>
source </usr/local/bin/virtualenvwrapper.sh:virtualenvwrapper脚本安装位置>

# 创建虚拟环境
mkvirtualenv <环境名称>
# 推出虚拟环境
deactivate
# 列出虚拟环境
lsvirtualenv
# 删除虚拟环境
rmvirtualenv <环境名称>


```

adb 的使用【工具】
===========

```
# 远程连接adb
adb connect IP:PORT
# 获取手机shell
adb shell

# 获取远程的apk包名
# 列出手机安装的软件
adb shell pm list packages
# 提取手机端安装的软件
adb shell pm path <包名>

# 从手机端下载文件
adb pull <文件路径> <./:需要下载的目录,当前为当下目录>
# 推送文件到手机端
adb push <需要推送的文件> <手机端目录>

# 使用adb进行端口转发
adb forward tcp:28042 tcp:28042


```

安卓任意门
-----

```
# 进入指定的Activity：<包名>/.ui.xxxActivity
adb shell am start -n <包名>/.ui.certificate.CertificateManagerActivity


```

objection【工具】
=============

objection 的使用：https://bbs.kanxue.com/thread-277929.htm

```
# -P加载插件目录
objection -N -h x.x.x.x -p 6666 -g 包名 explore -P ~/.objection/plugins


```

objection-Hook 使用
-----------------

_安卓_

```
# 注入进程
objection -g 包名 explore

# 列出内存中所有的类
android hooking list classes
# 列出类的所有方法
android hooking list class_methods <包名.类名>
# 列出（枚举）activity
android hooking list activities

# 在内存中所有已加载的类中搜索包含特定关键词的类
android hooking search classes <包含的关键词>

# hook类的所有方法
android hooking watch class <包名.类名>
# hook方法的参数、返回值和调用栈 --dump-args:参数、--dump-return:返回值、--dump-backtrace:调用栈
android hooking watch class_method <包名.类名.方法名> --dump-args --dump-return --dump-backtrace
# hook 类的构造方法
android hooking watch class_method <包名.类名.$init>
# hook 类的方法，默认会Hook方法的所有重载
android hooking watch class_method <包名.类名.方法>
# 如果只需hook其中一个重载函数 指定参数类型 多个参数用逗号分隔
android hooking watch class_method <包名.类名.方法 "参数1,参数2">

# 查看hook了多少个类
jobs list
# 把正在hook的任务关闭
jobs kill jobid
# 查看内存中加载的库
memory list modules
# 查看库的导出函数
memory list exports <libssl.so>


```

Frida 进阶：Objection 内存漫游、hook anywhere、抓包 [1] -> https://www.cnblogs.com/lxh2cwl/p/14842544.html

objection 插件
------------

*   wallbreaker：可用插件 (https://github.com/hluwa/Wallbreaker/tree/41adab6fb00b7c943e234501016a15ea1b7769c2)、基于 frida 的 objection 及其插件 wallbreaker 命令列表 (https://www.cnblogs.com/ningskyer/articles/14611822.html)
    
*   frida-dexdump：可用插件 (https://github.com/hluwa/FRIDA-DEXDump/tree/20926afdea60c6a161cb4b26b4b0dfabcb5d3db3)
    

frida 的使用【工具】
=============

frida-server
------------

```
# 启动远程方式，修改端口，可绕过对端口的检测
frida-server -l 0.0.0.0:6666


```

IOS frida-trace
---------------

```
# 盲打
frida-trace -U xx银行  -m "-[CSIIEncrptyTool encrptyDataWithDict:]"


```

frida 基础使用方法
------------

```
# 列出USB连接方式下的所有进程
frida-ps -U
# 列出远程方式下的所有进程
frida-ps -H x.x.x.x 6666
# 服务端启动远程连接方式
frida-server - /data/local/tmp/frida-server-xxx -l 0.0.0.0:6666
./frida-server_16.0.11 -l 0.0.0.0:6666 &
# 测试端使用远程hook
frida -H x.x.x.x:6666 -f 包名 -l 2.1.1.js -o fridaHook.txt


```

apktool 使用【工具】
==============

文章：[新版数字壳 app 过检测及重打包初探](https://mp.weixin.qq.com/s?__biz=MzkzMDY1MDg4MA==&mid=2247483751&idx=1&sn=1cdf409eedc2f9dbb08faed0a18d8bac&scene=21#wechat_redirect)反编译 Apk 文件，反编译 apk 文件分为四步：

*   解包 apk 文件
    
*   对解包后的 apk 文件进行修改
    
*   重新打包 apk 文件
    
*   对 apk 文件进行签名（签名以后才能够安装到手机）
    

```
# 解包apk文件
apktool d app-release.apk

# 打包Apk文件(META-INF文件夹，这里面包含旧的签名文件，用不到该文件夹，因此删除它)
apktool b app-release

# 签名Apk文件(生成密钥库文件，即keystore文件,使用以下命令生成keystore文件,生成了一个android.keystore文件)
keytool -genkey -alias android_keystore -keyalg RSA -validity 20000 -keystore android.keystore

# 将刚刚生成的android.keystore文件，拷贝到未签名的apk文件同级目录下，切换到该路径下，输入以下命令，进行签名
jarsigner -verbose -keystore android.keystore -signedjar app-release-signed.apk app-release.apk android_keystore


```

drozer 使用【工具】
=============

> ❝
> 
> drozer 工具可测试本地的相关漏洞

```
# 连接到手机端，需要手机端app开启服务
drozer console connect --server 192.168.31.22

# 遍历包名
run app.package.list -f sieve

# 脆弱性检测
run app.package.attacksurface <包名>

# 识别activity
run app.activity.info -a <包名>

# 攻击
run app.activity.start --component <包名> <activity>
run app.provider.info -a com.guoshi.httpcanary

# Drozer 提供了一个扫描器模块，该模块汇集了各种方法来猜测路径并神圣化可访问内容 URI 列表
run scanner.provider.finduris -a com.guoshi.httpcanary
run app.provider.query content://com.guoshi.httpcanary.provider --vertical


```

安卓系统及应用目录
=========

```
# 系统目录
/system/: 存储 Android 系统的核心文件和库，包括系统应用、框架和配置文件。
/system/app/: 存储系统应用程序，这些应用在设备启动时自动加载。
/system/priv-app/: 存储具有系统级权限的应用程序，通常包括系统服务和核心功能应用。
/system/framework/: 存储系统框架文件，包括 Android 系统的核心库文件（如 `framework.jar`）。
/vendor/: 存储硬件供应商提供的库和驱动文件，通常由设备制造商提供。
/product/: 存储产品特定的文件和配置，主要用于支持设备的特定功能。
/cache/: 存储系统的临时缓存数据，包括系统和应用的缓存文件。
/sdcard/: 通常表示外部存储（如 SD 卡或内部存储的模拟外部存储），用于存储用户文件和应用数据。
/mnt/sdcard/: 旧版 Android 的外部存储目录，用于存储用户数据和应用生成的文件（在现代 Android 版本中已被 `/storage/emulated/0/` 替代）。
/root/: 超级用户目录，系统的根目录，通常只有具有 root 权限的用户或进程可以访问。

# 应用目录
/data/app/: 存储已安装应用的 APK 文件，包含应用的实际安装文件和相关数据。
/data/user/0/<package_name>/cache/: 存储应用的临时缓存数据，可以被系统在空间不足时清除。
/data/user/0/<package_name>/code_cache/: 存储应用编译后的代码缓存数据，用于优化运行效率。
/data/user/0/<package_name>/files/: 存储应用的私有文件，应用可以在此目录下创建和管理文件。
/data/user/0/<package_name>/databases/: 存储应用的 SQLite 数据库文件。
/data/user/0/<package_name>/shared_prefs/: 存储应用的 SharedPreferences 文件，用于保存简单的键值对数据。
/storage/emulated/0/Android/data/<package_name>/cache/: 存储应用在外部存储上的缓存数据。
/storage/emulated/0/Android/data/<package_name>/files/: 存储应用在外部存储上的私有文件。
/storage/emulated/0/Android/obb/<package_name>/: 存储应用的大型附加数据文件（OBB 文件），如游戏资源包。
/data/app/<package_name>/lib/: 存储应用使用的本地共享库（`.so` 文件）。
/data/user/0/<package_name>/no_backup/: 存储不需要备份的数据或缓存文件。
/data/user/0/<package_name>/files/: 存储应用的私有文件（此目录在之前已提到）。
/data/user/0/<package_name>/databases/: 存储应用的数据库文件（此目录在之前已提到）。


```

壳的历史
====

第一代加固技术—动态加载 第一代 Android 加固技术用于保护应用的逻辑不被逆向与分析，最早普遍在恶意软件中使用，其主要基于 Java 虚拟机提供的动态加载技术。

第二代加固技术—不落地加载 相对第一代加固技术，第二代加固技术在 APK 修改方面已经完善，能做到对开发的零干扰。开发过程中不需要对应用做特殊处理，只需要在最终发布前进行保护即可。而为了实现这个零干扰的流程，Loader 需要处理好 Android 的组件的生命周期。

第三代加固技术—指令抽离 由于第二代加固技术仅仅对文件级别进行加密，其带来的问题是内存中的 Payload 是连续的，可以被攻击者轻易获取。第三代加固技术对这部分进行了改进，将保护级别降到了函数级别。

第四代加固技术：指令转换 / VMP 第三代加固技术在函数级别的保护，使用 Android 虚拟机内的解释器执行代码，带来可能被记录的缺陷，第四代加固技术使用自己的解释器来避免第三代的缺陷。而自定义的解释器无法对 Android 系统内的其他函数进行直接调用，必须使用 JAVA 的 JNI 接口进行调用。

壳
-

```
娜迦：libchaosvmp.so , libddog.solibfdog.so
爱加密：libexec.so, libexecmain.so
梆梆：libsecexe.so, libsecmain.so , libDexHelper.so
360：libprotectClass.so, libjiagu.so
通付盾：libegis.so
网秦：libnqshield.so 
*百度：libbaiduprotect.so


```

Reference

[1]

发布于 2021-06-02 19:10: https://www.cnblogs.com/lxh2cwl/p/14842544.html

* * *

如有疑问请微信公众号留言，术业有专攻，闻道有先后，获取更多内容点击左下角`阅读原文`

![](https://mmbiz.qpic.cn/mmbiz_png/ic5ERMY2ib5RvnBeKhsMA56BVWW2ibdXTgJbLzVUsCqLqtLQVzRuFDZr7kVcpGg9GrSvfIHWaNLyQImiaUbHDI3TAg/640?wx_fmt=png&from=appmsg)