<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/QhajdCTLbk9I3ijfy3YQBA)

    我记得在往前介绍过个 “Dll To Exe”（前翻），今天介绍个反向的 “Exe To Dll”，想想都觉得有趣，老外还是挺有意思的。其实，这对学深、学透很有帮助。

    “Dll To Exe” 这个工具，用处还是挺大的，解决了 Dll 不能单独运行而 Exe 可以单独运行的问题，可想而知，这个需求还是很实用的。而 “Exe To Dll” 将 Exe 转换成 Dll 可能就不是刚需了，也许是一些特殊需求或是一种学习细节。因为，作为一个 Dll，它有个很有用的功能是它的导出函数供其它程序，但用 “Exe To Dll” 这个转换后的 Dll 是没有那些导出函数的，这块是缺失的。不管那么多了，还是推荐给大家。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpfx5CC72OZJ8V5Siad8zyaexAricvbSwzfRGCicNNdmrA9rlQvUCG4gBXA/640?wx_fmt=png)

（无糖反诈宣传图）  

**一、源码**

源码：  

https://github.com/hasherezade/exe_to_dll

我编译好的程序：

链接：https://pan.baidu.com/s/1Dwo3-hrXckxs39Os40bRyw

提取码：uvsu

**二、分析**

    在 “为什么这么做” 的动机解释中，老外如是说：“带有目标函数的 dll 将允许我们方便地检查和测试函数。唯一的问题是，我们要检查的函数通常驻留在 exe 中，而不是 dll 中。将一个 exe 文件转换成一个 dll 文件是一个可解决的挑战。毕竟,Exe 和 dll 共享相同的内容。”

**两个挑战：**

1、文件头 - 这两种文件类型具有相同的 PE 头格式，但有一个特定的标志是唯一的 dll。

2、入口点代码 - 两种文件类型都有代码，一旦文件被加载，就会运行，但是这两种文件类型之间的代码 (在用途、集成和结构上) 有根本的不同。

**第一步: 修改文件头**
--------------

    通过 PE 头文件中的 “ Characteristics” 字段区分 exe 和 dll。  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpmBFp2aSNuJAzn1CG22vCF1XE8JmrHiaQ98rJngZ0ztWu9sV8AicEUv4w/640?wx_fmt=jpeg)

（https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics）

这个 py 程序可以设置 Exe 中的 Dll 标志。如下：

链接：https://pan.baidu.com/s/1TSogugb3bUSwTZCJ3sO4Eg

提取码：jt30 

**第二步: 修补入口**
-------------

 加载 PE 文件后，将执行该文件的入口点代码，该代码由 PE 头的 AddressOfEntryPoint（https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-standard-fields-image-only）。对于 exe 文件，入口点是调用 main 函数，但是对于 dll 文件，入口点是 DllMain。

    exe 的入口点不会使用栈上的任何参数来调用。相反，封装 main() 的入口点的代码使用 Windows 函数来准备 main() 的参数 (argv、argc 和 envp)，如图所示:

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpUxq3m4ibNsca3xfHzVXmCUoJayrKgaxGMs9pr35gAayWm2vvuVUvLwQ/640?wx_fmt=jpeg)

    但 DllMain 却不是这样。DllMain 有 3 个参数 (hinstDLL, fdwReason, lpvReserved)，根据它的 stdcall 调用约定，它必须在返回之前从堆栈中清除这些参数，以确保代码的稳定延续。

**补丁：**  

    我们可以纠正这 3 个差异之间的 exe 和 dll 入口点与一个简单的补丁: 覆盖代码在 exe 入口点简单地 “返回 True”。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpILibW62MfUS42ibZUTbUVLf3YQNfbhx8dIH4dGOiaoYZmIibbnlWvla1SQ/640?wx_fmt=jpeg)

新的入口代码

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpPCUfzaH8AibGHxITnk2m3BuFUjSUQ3kkfvrWhwmO6K1qLsR8rwNc2ug/640?wx_fmt=png)

补丁程序覆盖. exe 入口点  

    这个补丁将入口点代码更改为 “立即返回一个成功的代码并清除堆栈变量”。

    在这一步之后，我们就完成了对目标文件的修补。现在，我们将重点编写调用对新 “DLL” 的调用的代码。

**第三步: 调用 Call**
----------------

    现在我们有了一个行为类似于 DLL 的文件，我们可以用 LoadLibrary() 加载它。LoadLibrary() 将把修改后的 exe 加载到进程的地址空间中，并运行入口点代码。

### **计算 RVA：**

    接下来，要调用目标函数，我们需要计算它的 RVA(相对虚拟地址)，即函数与文件基址的偏移量。这只需从程序的基地址 (ImageBase，下图) 中减去函数的偏移量 (在 IDA 中显示的地址) 即可完成。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpALKKzuZcpXWKhhrIWwou9DRwHLT5kkxMYcr58fNbKDYekGYgXmq4xw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpVfUDPReflhGKpicl3cOSqgB8R2icWeqPBjVVjArPgE8JKKOfy0iaAenUQ/640?wx_fmt=png)

    通过从目标函数的偏移量减去基地址，我们计算出该函数的 RVA = 0x401040 - 0x400000 = 0x1040。  

    最后，剩下的就是执行对 LoadLibrary() 的调用，并应用令人困惑的 C 函数指针语法来调用目标函数。如果我们的 exe 更复杂，在直接调用目标函数之前，我们可能需要额外的调用 - 参见下面的改进实现部分。然而，有了这个简单的 exe 示例，我们就都完成了。

    点击下面的图片放大它或查看代码在 Github 这里。我使用了额外的注释来详细解释每一行到底做了什么。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpeqejCnUB2KKLr8e6KRAU175xzrdiclM3gAme7Ak2hKyMJViaBnQGO6Xw/640?wx_fmt=jpeg)

下面是运行代码的结果:

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpJS8hW1heLdvJAsb209lXatgjogiaAgJjIIkMA2Rl5dPBuVKFEzMicZUw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLouEaUpBs5Cgxvqhucz9cpoCwPeMbHtVDNC7UC256cyM2YwbsjQB8TW32IGSOZcicviaMl0dOsrVFg/640?wx_fmt=png)

（无糖反诈宣传图）

    我们把. exe 文件变成了. dll，并成功地从它运行了一个函数。我希望你学习一个新技巧，用 LoadLibrary 将. exe 作为. dll 使用，在可执行文件中运行任意函数!

    如果你对上面说得不知所云，还是看代码来加深理解吧！毕竟，代码写得非常得清爽，有一种美感！