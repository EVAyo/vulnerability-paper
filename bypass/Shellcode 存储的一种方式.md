<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/9BUvzCBS5oLDh8VU4YjLZA)

**shellcode 存储在证书表中**

这里的 shellcode 存储在证书表中，其实和我们的白加黑是差不多的，我们白加黑其实都是通过白程序 + 黑 dll+shellcode 的这种方式，基本上 loader 会直接在黑 dll 中编写，除了白加黑的方式，我们也可以将 shellcode 存储在 pe 文件的证书表中，当我们将 shellcode 存储在证书表中之后，我们就可以通过黑 dll 去读取该白程序中的 shellcode 并加载它，这样其实就少了一个文件了。

这里我们介绍一款工具，它可以将我们的 shellcode 嵌入到白程序中。

```
https://github.com/med0x2e/SigFlip

```

我们都知道，一般修改文件的话，会导致 hash 值发生改变，进而签名会直接失效，这个工具就是为了解决这个问题。

这个工具可以修改已经通过 Authenticode 签名的 PE 文件（如 exe, dll, sys 等）而不破坏签名的完整性。这听起来违反常理，因为如前所述，任何对 PE 文件的修改，都会导致其哈希值变化，进而破坏签名验证。然而，SigFlip 通过精妙的方式实现了对 PE 文件的修改，且不会影响 Authenticode 签名。

他的工作原理我们需要去简单解释一下。

SigFlip 的核心思想其实就是利用 Authenicode 签名验证过程中的一个特征，有些字段和部分数据在签名验证时被**有意忽略**。通过在这些被忽略的字段中嵌入数据，可以修改文件内容，而不影响 Authenticode 签名的验证。

**工作原理如下:**

利用签名忽略的 PE 数据部分，在 Authenticode 的签名验证过程中，某些 PE 文件的字段和节并不包含在签名验证的范围内。例如：

PE 文件的 **证书表（Certificate Table）**。某些特定的填充区域或未使用的部分。这个工具其实就是利用了这些忽略验证的部分，在其中插入数据，以便在不破坏签名的情况下修改其行为。

使用方式如下:

根据作者介绍，我们可以修改 PE 文件的哈希值从而不破坏其签名或证书的有效性，这使得我们可以绕过基于哈希值的检测。

```
SigFlip.exe -b "<PE_FILE_PATH>" "<OUTPUT_PE_FILE_PATH (with extension)>"

```

```
SigFlip.exe -b "C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe" "c:\Users\Administrator\Desktop\ms.exe"

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1BwlcDx11J20GP2cVtnbSDx1cPECuAiapbBPicmBAayTJVo0WysibMVibIaNA/640?wx_fmt=png&from=appmsg)

修改成功之后会打印出哈希值，我们可以查看 ms.exe 签名是否是有效的。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1Bw82YnJbvMIukcgYBNRGnmYF6tRSIflrpadzmC3QSQSFB64pgNsVZD8A/640?wx_fmt=png&from=appmsg)

紧接着我们可以将 shellcode 嵌入进去。其签名有效。

```
SigFlip.exe -i [exe/dll file path] [shellcode file path] [output_file_path (with extension)] [Encryption Key]

```

**`-i`**：指定注入模式，表示将 shellcode 注入到目标文件中。

**`[exe/dll file path]`**：目标 PE 文件的路径，通常是一个 `.exe` 或 `.dll` 文件。这个文件是带有有效签名的白文件。

**`[shellcode file path]`**：要注入的 shellcode 文件路径，通常是一个包含恶意代码的二进制文件（如 `shellcode.bin`）。

**`[output_file_path (with extension)]`**：注入完成后生成的新 PE 文件的路径和文件名。输出文件会保持目标文件的签名有效，同时带有加密后的 shellcode。

**`[Encryption Key]`**：用于加密 shellcode 的密钥，这个密钥稍后需要在加载 shellcode 时解密用。

```
SigFlip.exe -i "c:\Users\Administrator\Desktop\ms.exe" "c:\Users\Administrator\Desktop\payload.bin" "C:\Users\Administrator\Desktop\ms-payload.exe" "0xDEADBEEF"

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1BwXsbypou6WuNOIkDicA3Dia3vI6VAqD9voJYENvDCPcHjPLTjxpC7Ss4g/640?wx_fmt=png&from=appmsg)

最后会生成一个 ms-payload.exe 新的文件，密钥为 0xDEADBEEF。

可以看到签名依旧是有效的。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1BwbcIPcFz2x4gHGDMQbnLjfY4JfBceGCH2mWNkGibrTKZsyrqciawXib7CQ/640?wx_fmt=png&from=appmsg)

紧接着我们就可以使用 Loader 去进行加载了。

```
Loader.exe "c:\Users\Administrator\Desktop\ms1-payload.exe" "0xDEADBEEF"

```

成功上线。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1BwqH2seyIOr4eVowwpRvuaNiadz6yzwUcFXT9DR41ETNDicU8vDllZ4fGQ/640?wx_fmt=png&from=appmsg)

那么其实我们是可以去扩展思路的，

比如说我们可以和白加黑进行配合，其实就相当于让某个白程序作为了 shellcode 的载体。

我们在某个白程序的黑 dll 这里写:

需要注意的是我这里将 360-payload.exe 这个程序作为了 shellcode 的载体，打开这个文件读取到 shellcode 之后，对其进行解密。

代码大家可以自行发挥。

当我们点击白程序的时候成功上线。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpJG4E8gyjDFXHEJL9BK1BwP7Q4p3C4Ejw49kXZkOpukXKqRfp6wuRPYsBa8icPRianV9JO889gDnmg/640?wx_fmt=png&from=appmsg)

其他的一些方式大家可以自由的去发挥。

其实说的简单的这就是 shellcode 存储的一种方式。