<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/HBHJeTTNEQ5AVfarBenZZQ)

```
一





环境搭建

```

学习一下利用修改物理内存来跨进程内存读写。

> 系统：win10 21h1 x64
> 
> 编译环境: vs2022 详情见附录

```
一





基础

```

### 虚拟地址转物理地址

虚拟地址也称线性地址，一个**线性地址 + 进程的 DirBase 地址**可以转换成物理地址。先来看线性地址的含义。

> 在 x64 体系中只实现了 48 位的 virtual address，高 16 位被用作符号扩展，这高 16 位要么全是 0，要么全是 1。  
> 不同于 x86 体系结构，每级页表寻址长度变成 9 位，由于在 x64 体系结构中，普通页大小仍为 4KB, 然而数据却表示 64 位长，因此一个 4KB 页在 x64 体系结构下只能包含 512 项内容，所以为了保证页对齐和以页为单位的页表内容换入换出，在 x64 下每级页表寻址部分长度定位 9 位。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FYLUfNfmH9X0scKfOjRdQDkIjUnsXRGGUHYX6NBXb3KO6keEOiaJwz22hJ2PdOCHia97OicvJgRVyuw/640?wx_fmt=png&from=appmsg)

从 Page Map Level 4(PML4) 开始到最后的物理地址，每一个都可以理解成一层页表的索引，索引值就是线性地址上不同的部分，分别缩写是 PML4, PDPE, PDE,PTE。

> 注意，并不是取出来的值就直接指向一下一个页表，个人 PC 上一般是取值的 12-35bit 的值，其他置 0。具体的后面见代码，或参考看雪的文章（https://bbs.kanxue.com/thread-203391.htm）。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FYLUfNfmH9X0scKfOjRdQDpDvkHsoeNcd5xDWtRzYQYV7qqRCKIhOKELxVlpfDn3DOria96Z5b1iaA/640?wx_fmt=png&from=appmsg)

使用 windbg 可以先查看进程对应的 DirBase 地址，然后再使用`!vtop Dirbase地址 虚拟地址`查看虚拟地址对应的物理地址，如下：

```
3: kd> !process 258c 0
Searching for Process with Cid == 258c
PROCESS ffffc40d2ab48340
    SessionId: 1  Cid: 258c    Peb: a6e35cd000  ParentCid: 1250
    DirBase: 235ae6000  ObjectTable: ffff998138d4ee00  HandleCount:  38.
    Image: test.exe

3: kd> !vtop 235ae6000 0000A6E334FB00
Amd64VtoP: Virt 000000a6e334fb00, pagedir 0000000235ae6000
Amd64VtoP: PML4E 0000000235ae6008
Amd64VtoP: PDPE 00000001087fb4d8
Amd64VtoP: PDE 000000010f7fc8c8
Amd64VtoP: PTE 00000000ad207a78
Amd64VtoP: Mapped phys 000000011b10cb00
Virtual address a6e334fb00 translates to physical address 11b10cb00.


```

上面得到 DirBase 的值是`235ae6000`，然后需要查看物理地址的虚拟地址是`0x0000A6E334FB00`，就使用命令

```
!vtop 235ae6000 0000A6E334FB00


```

得到最后对应的物理地址是 0x11b10cb00。

简单例子代码如下：

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    char flag[] = {"flag{b7285d748dd042a4929d3dbec778e637}"};

    printf("value addr: %p", flag);
    getchar();

    return 0;
}


```

运行后可以打印出来字符串的虚拟地址`0000A6E334FB00`，然后通过上述步骤得到物理地址。

我们尝试看看物理内存中的字符串，现在已经确定物理内存的地址是`0xD0000147`，使用`!db 0xD0000147`来查看物理内存，记住要`!`, 没有感叹号的是查看虚拟内存的。

```
3: kd> !db 0x11b10cb00
#11b10cb00 66 6c 61 67 7b 62 37 32-38 35 64 37 34 38 64 64 flag{b7285d748dd
#11b10cb10 30 34 32 61 34 39 32 39-64 33 64 62 65 63 37 37 042a4929d3dbec77
#11b10cb20 38 65 36 33 37 7d 00 00-f8 82 20 82 f7 7f 00 00 8e637}.... .....
#11b10cb30 00 00 00 00 00 00 00 00-20 13 1f 82 f7 7f 00 00 ........ .......
#11b10cb40 00 00 00 00 00 00 00 00-99 13 1f 82 f7 7f 00 00 ................
#11b10cb50 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
#11b10cb60 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
#11b10cb70 00 00 00 00 00 00 00 00-44 73 d3 08 fe 7f 00 00 ........Ds......


```

可以看到物理内存上的字符串内容。

### DirBase 地址获取

DirBase 地址除了通过上述 windbg 直接得到这个值以外，还可以通过 EPROCESS 来得到，这个是代码比较需要的。

```
3: kd> dt _eprocess ffffc40d2ab48340
nt!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x438 ProcessLock      : _EX_PUSH_LOCK
   +0x440 UniqueProcessId  : 0x00000000`0000258c Void
   +0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffffc40d`2cb43788 - 0xffffc40d`2cd444c8 ]
   +0x458 RundownProtect   : _EX_RUNDOWN_REF
   .....
3: kd> dx -id 0,0,ffffc40d23c95040 -r1 (*((ntkrnlmp!_KPROCESS *)0xffffc40d2ab48340))
(*((ntkrnlmp!_KPROCESS *)0xffffc40d2ab48340))                 [Type: _KPROCESS]
    [+0x000] Header           [Type: _DISPATCHER_HEADER]
    [+0x018] ProfileListHead  [Type: _LIST_ENTRY]
    [+0x028] DirectoryTableBase : 0x235ae6000 [Type: unsigned __int64]


```

DirectoryTableBase 的值就是 DirBase 地址了，实际上就是 EPROCESS + 0x28 的偏移。

还可以通过获取 CR3 寄存器的值，CR3 寄存器中的值就是页目录表的物理地址，也就是 DirBase。

```
二





思路

```

目的：进程 B 可以通过修改物理内存的内容来修改进程 A 内存中的数据

实验设置：进程 A 泄露一个变量地址，然后等待进程 B 修改，修改后再回复执行，打印变量值看是否修改成功。

内核部分思路：

◆将 R3 的虚拟地址转换为物理地址

◆使用 MmCopyMemory 复制物理地址内容

◆修改内容

◆使用 mmMapIoSpaceEx 将修改后的内容映射回物理地址

```
三





代码实现

```

### 被修改进程代码

这里写一个例子来充当被攻击（修改内存）的进程。主要就是打印变量内容和地址，然后暂停程序等待一段时间（等待被驱动修改），然后再打印变量内容，看看是否被驱动修改内存成功。

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    char flag[] = {"flag{b7285d748dd042a4929d3dbec778e637}"};

    printf("value addr: %p\r\n", flag);
    printf("flag data: %s\r\n", flag);
    getchar();

    printf("flag data Now: %s\r\n", flag);
    return 0;
}


```

### 驱动代码

这里就是主要逻辑，通过驱动代码取修改目标进程的内存内容，做到跨进程内存读取，修改。

定义一个读取物理内存函数。

```
/// @brief 读取物理地址的内存内容
/// @param address 物理地址
/// @param buffer 复制内存地址到buffer
/// @param size 复制大小
/// @param BytesTransferred 读取的字节数
/// @return
NTSTATUS ReadPhysicalAddress(IN PVOID64 address, OUT PVOID64 buffer,
                             IN SIZE_T size, OUT SIZE_T* BytesTransferred)
{
    MM_COPY_ADDRESS Read          = {0};
    Read.PhysicalAddress.QuadPart = (LONG64)address;
    return MmCopyMemory(
        buffer, Read, size, MM_COPY_MEMORY_PHYSICAL, BytesTransferred);
}


```

再定义一个写入物理内存的函数。

```
/// @brief 写入指定内容到物理内存中
/// @param address 被写入的物理地址
/// @param buffer 需要写入的缓冲区指针
/// @param size 需要写入的大小
/// @param BytesTransferred 写入成功后的大小
/// @return
NTSTATUS WritePhysicalAddress(IN PVOID64 address, IN PVOID64 buffer,
                              IN SIZE_T size, OUT SIZE_T* BytesTransferred)
{
    PVOID            map;
    PHYSICAL_ADDRESS Write = {0};

    if (!address) {
        kprintf("Address value error. \r\n");
        return STATUS_UNSUCCESSFUL;
    }

    Write.QuadPart = (LONG64)address;
    map            = MmMapIoSpaceEx(Write, size, PAGE_READWRITE);

    if (!map) {
        kprintf("Write Memory faild.\r\n");
        return STATUS_UNSUCCESSFUL;
    }
    RtlCopyMemory(map, buffer, size);
    *BytesTransferred = size;
    MmUnmapIoSpace(map, size);
    return STATUS_SUCCESS;
}


```

我们需要将虚拟地址转换成物理地址，那么首先需要**线性地址 + DirBase** 地址，DirBase 地址获取是通过 PEPROCESS+0x28 偏移读取的。

```
/// @brief 通过EPROCESS获取DirBase值
/// @param pid 进程PID
/// @param pDirbase 一个UINT64指针，获取成功后返回值
/// @return
NTSTATUS GetDirBaseByEprocess(IN UINT64 pid, OUT PUINT64 pDirbase)
{
    PEPROCESS pEprocess;
    NTSTATUS  status;

    status = PsLookupProcessByProcessId((HANDLE)pid, &pEprocess);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Get Pid=%d _EPROCESS failed!", pid);
        return STATUS_UNSUCCESSFUL;
    }

    *pDirbase =
        *(PUINT64)((PUCHAR)pEprocess + WIN10_21H1_EPROCESS2DIRBASE_OFFSET);
    kprintf("[+] uDirBase ==> %llx\r\n", *pDirbase);

    return STATUS_SUCCESS;
}


```

得到 DirBase 后，就可以虚拟地址转换物理地址。

传入虚拟地址后，取后 48bit，然后将这 48bit 分成 4 个 9bit 和最后 12bit，分别是 PML4，PDPE，PDE，PTE 和页内偏移 offset。需要注意的是 DirBase 就已经是物理内存了，所以读取 DirBase 内容并且一层一层读取都要用自定义函数 **ReadPhysicalAddress**。

每一层都是**基地址 + 8 * 偏移**，读取的内容，取 **12-35bit** 就是下一层的基地址。

```
/// @brief 传入DirBase值和虚拟地址后，回转化成一个物理地址返回
/// @param DirBase DirBase地址，传入一个UINT64值
/// @param addr 传入一个指向虚拟地址的指针，转化成物理地址后会修改这个指针的值
/// @return
NTSTATUS TranslateAddress(IN UINT64 DirBase, _Inout_ PUINT64 addr)
{
    UINT16   PML4, PDPE, PDE, PTE, offset;
    UINT64   mask = 0x7fffff000;
    UINT64   uTmp;
    SIZE_T   BytesTransferred;
    NTSTATUS status;

    offset = *addr & 0xfff;
    PTE    = (*addr >> 12) & 0x1ff;
    PDE    = (*addr >> (12 + 9)) & 0x1ff;
    PDPE   = (*addr >> (9 * 2 + 12)) & 0x1ff;
    PML4   = (*addr >> (9 * 3 + 12)) & 0x1ff;

    status = ReadPhysicalAddress(
        (PVOID64)(DirBase + PML4 * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PML4(%x) ==> %llx\r\n", PML4, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PDPE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PDPE(%x) ==> %llx\r\n", PDPE, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PDE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PDE(%x) ==> %llx\r\n", PDE, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PTE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PTE(%x) ==> %llx\r\n", PTE, uTmp);

    *addr = uTmp + offset;
    kprintf("[+] physical address: %llx\r\n", *addr);
    return STATUS_SUCCESS;
}


```

最后再主函数中定义一下逻辑。这里直接手动指定进程号和目标进程打印出来的变量地址，然后将虚拟地址转化成物理地址，读取物理地址上的内容并打印出来看看是否正确。再修改物理地址上的内容。

```
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING path)
{
    NTSTATUS status;
    UINT64   pid, uAddr, uDirBase;
    SIZE_T   BytesTransferred;
    UCHAR    charArry[40] = {0};
    UCHAR    example[40] = {"Yes I change memory by physical"};

    pid   = 10276;
    uAddr = 0x3629FAFB80;

    pDriver->DriverUnload = DriverUnload;
    // 手动指定进程号
    status = GetDirBaseByEprocess(pid, &uDirBase);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Get DirBase address failed!\r\n");
        return STATUS_UNSUCCESSFUL;
    }

    // 将虚拟地址转化成物理地址
    status = TranslateAddress(uDirBase, &uAddr);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Translate address failed!\r\n");
        return STATUS_UNSUCCESSFUL;
    }

    // 读取物理地址内容, 然后修改内容
    ReadPhysicalAddress((PVOID64)uAddr, charArry, 40, &BytesTransferred);
    kprintf("[+] data is %s\r\n", charArry);

    // 将example字符串写入物理内存
    WritePhysicalAddress((PVOID64)uAddr, example, 40, &BytesTransferred);
    kprintf("[+] Write end\r\n");

    return STATUS_SUCCESS;
}


```

```
四





结果

```

目标进程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FYLUfNfmH9X0scKfOjRdQDSibDzDbib5mzuYTJQ6Q9CfMz7HQ8L0sT62nMia8YZxstmP6w2HCeN7CSQ/640?wx_fmt=png&from=appmsg)

驱动

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FYLUfNfmH9X0scKfOjRdQDLPVVhPetkFyIb5OQnib1Ulrnotia4RJjZqORQEHHOVH3bAxR6lA9aJdg/640?wx_fmt=png&from=appmsg)

可以看到目标进程的指定内存被修改，同时驱动也跨进程读取，修改内存成功。

```
五





参考

```

使用 CR3 切换实现读取指定进程内存数据 | pnpon.com

（https://www.pnpon.com/article/detail-607.html）  

c/c++/ 易语言驱动内存无痕读写源码 | csdn.net

（https://blog.csdn.net/a772336300/article/details/129107452）  

将虚拟地址转换为物理地址 | learn.microsoft.com

（https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/converting-virtual-addresses-to-physical-addresses）

X64 下的虚拟地址到物理地址的转换 | bbs.kanxue.com

（https://bbs.kanxue.com/thread-203391.htm）  

几种挖掘任意读写驱动的方法 | myzxcg.com/

（https://myzxcg.com/2024/03/%E5%87%A0%E7%A7%8D%E6%8C%96%E6%8E%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/）
===================================================================================================================================================

```
六




附录

```

驱动全部代码
------

```
#include <ntifs.h>
#include <ntddk.h>
#include <intrin.h>
#include <ntdef.h>

#define WIN10_21H1_EPROCESS2DIRBASE_OFFSET 0x28

#define kprintf(...) \
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, __VA_ARGS__))


NTSTATUS GetDirBaseByEprocess(IN UINT64, OUT PUINT64);
NTSTATUS TranslateAddress(IN UINT64, _Inout_ PUINT64);
NTSTATUS ReadPhysicalAddress(IN PVOID64, OUT PVOID64, IN SIZE_T, OUT SIZE_T*);
NTSTATUS WritePhysicalAddress(IN PVOID64, IN PVOID64, IN SIZE_T, OUT SIZE_T*);
NTKERNELAPI PPEB NTAPI  PsGetProcessPeb(IN PEPROCESS Process);
NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process(IN PEPROCESS Process);

VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
    kprintf("驱动已卸载.\r\n");
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING path)
{
    NTSTATUS status;
    UINT64   pid, uAddr, uDirBase;
    SIZE_T   BytesTransferred;
    UCHAR    charArry[40] = {0};
    UCHAR    example[40] = {"Yes I change memory by physical"};

    pid   = 10276;
    uAddr = 0x3629FAFB80;

    pDriver->DriverUnload = DriverUnload;
    // 手动指定进程号
    status = GetDirBaseByEprocess(pid, &uDirBase);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Get DirBase address failed!\r\n");
        return STATUS_UNSUCCESSFUL;
    }

    // 将虚拟地址转化成物理地址
    status = TranslateAddress(uDirBase, &uAddr);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Translate address failed!\r\n");
        return STATUS_UNSUCCESSFUL;
    }

    // 读取物理地址内容, 然后修改内容
    ReadPhysicalAddress((PVOID64)uAddr, charArry, 40, &BytesTransferred);
    kprintf("[+] data is %s\r\n", charArry);

    // 将example字符串写入物理内存
    WritePhysicalAddress((PVOID64)uAddr, example, 40, &BytesTransferred);
    kprintf("[+] Write end\r\n");

    return STATUS_SUCCESS;
}

/// @brief 读取物理地址的内存内容
/// @param address 物理地址
/// @param buffer 复制内存地址到buffer
/// @param size 复制大小
/// @param BytesTransferred 读取的字节数
/// @return
NTSTATUS ReadPhysicalAddress(IN PVOID64 address, OUT PVOID64 buffer,
                             IN SIZE_T size, OUT SIZE_T* BytesTransferred)
{
    MM_COPY_ADDRESS Read          = {0};
    Read.PhysicalAddress.QuadPart = (LONG64)address;
    return MmCopyMemory(
        buffer, Read, size, MM_COPY_MEMORY_PHYSICAL, BytesTransferred);
}

/// @brief 写入指定内容到物理内存中
/// @param address 被写入的物理地址
/// @param buffer 需要写入的缓冲区指针
/// @param size 需要写入的大小
/// @param BytesTransferred 写入成功后的大小
/// @return
NTSTATUS WritePhysicalAddress(IN PVOID64 address, IN PVOID64 buffer,
                              IN SIZE_T size, OUT SIZE_T* BytesTransferred)
{
    PVOID            map;
    PHYSICAL_ADDRESS Write = {0};

    if (!address) {
        kprintf("Address value error. \r\n");
        return STATUS_UNSUCCESSFUL;
    }

    Write.QuadPart = (LONG64)address;
    map            = MmMapIoSpaceEx(Write, size, PAGE_READWRITE);

    if (!map) {
        kprintf("Write Memory faild.\r\n");
        return STATUS_UNSUCCESSFUL;
    }
    RtlCopyMemory(map, buffer, size);
    *BytesTransferred = size;
    MmUnmapIoSpace(map, size);
    return STATUS_SUCCESS;
}

/// @brief 通过EPROCESS获取DirBase值
/// @param pid 进程PID
/// @param pDirbase 一个UINT64指针，获取成功后返回值
/// @return
NTSTATUS GetDirBaseByEprocess(IN UINT64 pid, OUT PUINT64 pDirbase)
{
    PEPROCESS pEprocess;
    NTSTATUS  status;

    status = PsLookupProcessByProcessId((HANDLE)pid, &pEprocess);
    if (!NT_SUCCESS(status)) {
        kprintf("[!] Get Pid=%d _EPROCESS failed!", pid);
        return STATUS_UNSUCCESSFUL;
    }

    *pDirbase =
        *(PUINT64)((PUCHAR)pEprocess + WIN10_21H1_EPROCESS2DIRBASE_OFFSET);
    kprintf("[+] uDirBase ==> %llx\r\n", *pDirbase);

    return STATUS_SUCCESS;
}

/// @brief 传入DirBase值和虚拟地址后，回转化成一个物理地址返回
/// @param DirBase DirBase地址，传入一个UINT64值
/// @param addr 传入一个指向虚拟地址的指针，转化成物理地址后会修改这个指针的值
/// @return
NTSTATUS TranslateAddress(IN UINT64 DirBase, _Inout_ PUINT64 addr)
{
    UINT16   PML4, PDPE, PDE, PTE, offset;
    UINT64   mask = 0x7fffff000;
    UINT64   uTmp;
    SIZE_T   BytesTransferred;
    NTSTATUS status;

    offset = *addr & 0xfff;
    PTE    = (*addr >> 12) & 0x1ff;
    PDE    = (*addr >> (12 + 9)) & 0x1ff;
    PDPE   = (*addr >> (9 * 2 + 12)) & 0x1ff;
    PML4   = (*addr >> (9 * 3 + 12)) & 0x1ff;

    status = ReadPhysicalAddress(
        (PVOID64)(DirBase + PML4 * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PML4(%x) ==> %llx\r\n", PML4, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PDPE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PDPE(%x) ==> %llx\r\n", PDPE, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PDE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PDE(%x) ==> %llx\r\n", PDE, uTmp);

    status = ReadPhysicalAddress(
        (PVOID64)(uTmp + PTE * 8), &uTmp, sizeof(uTmp), &BytesTransferred);
    uTmp &= mask;
    kprintf("[+] PTE(%x) ==> %llx\r\n", PTE, uTmp);

    *addr = uTmp + offset;
    kprintf("[+] physical address: %llx\r\n", *addr);
    return STATUS_SUCCESS;
}


```

编译环境
----

```
Microsoft Visual Studio Community 2022
Version 17.9.6
VisualStudio.17.Release/17.9.6+34728.123
Microsoft .NET Framework
Version 4.8.09032

Installed Version: Community

Visual C++ 2022   00482-90000-00000-AA134
Microsoft Visual C++ 2022

ASP.NET and Web Tools   17.9.199.22661
ASP.NET and Web Tools

Azure App Service Tools v3.0.0   17.9.199.22661
Azure App Service Tools v3.0.0

C# Tools   4.9.0-3.24121.1+a98c90d56455379836dd5c845b35fa932b00cfa3
C# components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.

Debugging Tools for Windows   10.0.26090.1
Integrates the Windows Debugger functionality (http://go.microsoft.com/fwlink/?linkid=223405) in Visual Studio.

Microsoft JVM Debugger   1.0
Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines

NuGet Package Manager   6.9.2
NuGet Package Manager in Visual Studio. For more information about NuGet, visit https://docs.nuget.org/

Test Adapter for Boost.Test   1.0
Enables Visual Studio's testing tools with unit tests written for Boost.Test.  The use terms and Third Party Notices are available in the extension installation directory.

Test Adapter for Google Test   1.0
Enables Visual Studio's testing tools with unit tests written for Google Test.  The use terms and Third Party Notices are available in the extension installation directory.

TypeScript Tools   17.0.30103.2001
TypeScript Tools for Microsoft Visual Studio

Visual Basic Tools   4.9.0-3.24121.1+a98c90d56455379836dd5c845b35fa932b00cfa3
Visual Basic components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.

Visual Studio IntelliCode   2.2
AI-assisted development for Visual Studio.

Windows Driver Kit   10.0.26090.1
Headers, libraries, and tools needed to develop, debug, and test Windows drivers (msdn.microsoft.com/en-us/windows/hardware/gg487428.aspx)

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FYLUfNfmH9X0scKfOjRdQDL2icCgaica6GVfK5iaqgVsdhR8LTGCnbbFDxKGNibPYckZRAfyX7wojGMw/640?wx_fmt=png&from=appmsg)

  

**看雪 ID：mi1itray.axe**

https://bbs.kanxue.com/user-home-900501.htm

* 本文为看雪论坛精华文章，由 mi1itray.axe 原创，转载请注明来自看雪社区

[![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8EfwNn9CazCSjW7ALo1DEUVdXJNTDlQWqmEILfCkGE9JcZImibYDe2Ze3CwDLN9uhYRUZVuX3o7veg/640?wx_fmt=png&from=appmsg)](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458551276&idx=3&sn=50acfacc95476243fc250627ac9d087f&chksm=b18db36686fa3a709e4686bac6135bb4566f5d2b7de25d85bbc627123b48ccec252cc1f15fef&scene=21#wechat_redirect)

**#** **往期推荐**

1、[CVE-2020-9802：Incorrect CSE for ArithNegate 导致的越界访问](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553736&idx=1&sn=fa9d04982a90b1c0cf6c375efce65314&chksm=b18dbd0286fa3414de804dbd2315099238c1ec027489de8a51a7a6dd663b3a239d6768593497&scene=21#wechat_redirect)

2、[通过 BLECTF 入门 BLE](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553587&idx=1&sn=555f3300fdfb937c866049ec95101e07&chksm=b18dbc7986fa356f385dbffe62de254e6d722f876becce0a78ebe8c2b742e83a71fd87bea561&scene=21#wechat_redirect)

3、[InfinityHook 可兼容最新版 windows](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553456&idx=1&sn=2df223026199d77ea1ee2672cd2792a4&chksm=b18dbcfa86fa35ece674c4810d4596eafd31fb2fee0e692de35fd9375dff614fccb9583c2704&scene=21#wechat_redirect)

4、[CVE-2023-4427：ReduceJSLoadPropertyWithEnumeratedKey 中的越界访问](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553432&idx=1&sn=93377c71147ef00b8e58571093d5ab55&chksm=b18dbcd286fa35c424bcf128759e907304820fb4289f407f6ba5ecd0b48897ce31ddb7623caa&scene=21#wechat_redirect)

5、[Windows 主机入侵检测与防御内核技术深入解析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553431&idx=1&sn=c2d1e01e4c6720d78bc1574c7bf31a57&chksm=b18dbcdd86fa35cbcc56961d6fb31e826c79008814e3861f332d23b87c85910e7f2cf152f7d6&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg)

**球分享**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg)

**球点赞**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg)

**球在看**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78txPhfvI9WpuGSCawCN8NJCgzD16Y0IwdUkaI33Qr3DpwRRuvibgRQOg/640?wx_fmt=gif&from=appmsg)

点击阅读原文查看更多