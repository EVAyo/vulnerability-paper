<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/JH7IyZGHLTym2e4I179XXw)

##### 简介

Minhook 库其实跟上一篇的那个库是差不多的，只不过它是使用 C 语言进行编写的 hook 库，我们可以使用它来进行 Hook Windows API 函数，MinHook 库相比 Detours 库来说是比较简单的，它是一个轻量级的 API。

下载地址如下:

```
https://github.com/TsudaKageyu/minhook

```

它跟 Detours 库是类似的，Minhook 库也需要. lib 文件和 MinHook.h 文件，将这两个文件拉入到项目中即可。

如下代码:

```
#include <iostream>
#include "MinHook.h"
#pragma commint(lib,"C:\\Users\\Admin\\Desktop\\bin\\libMinHook.x86.lib");
int main()
{
}

```

##### MinHook API

MinHook 的工作原理是初始化一个结构，这个结构中保存着挂钩和取消挂钩的信息，这是通过初始化库中的 HOOK_ENTRY 结构的 MH_Initalize API 完成的，紧接着函数用户创建挂钩，然后启用他们，他们用于取消挂钩，最后清理初始化的结构。

如下结构:

```
MH_CreateHook MH_EnableHook MH_DisableHook MH_Uninitialize
    MH_Initialize 初始化HOOK_ENTRY结构
    MH_CreateHook 创建挂钩
    MH_EnableHook 启动创建的挂钩
    MH_DisableHook 删除挂钩
    MH_uninitialize 清理初始化的结构

```

MinHook API 返回一个 MG_STATUS 值，这个值是用户自定义的枚举，返回的 MG_STATUS 数据类型表示指定函数的错误码，如果函数成功，则返回 MG_OK，如果发生错误就返回非零值。

需要注意的是 MH_Initialize 和 MH_Uninitialize 函数只能分别在程序开始和结束时调用一次。

接下来我们写一个替换原始函数的自定义函数，当调用原始函数的时候触发挂钩然后跳转到我们自定义的函数。

```
#include <iostream>
#include "MinHook.h"
#pragma commint(lib,"C:\\Users\\Admin\\Desktop\\bin\\libMinHook.x86.lib");
typedef HMODULE(WINAPI* fnGetModuleHandleA)(
    _In_opt_ LPCWSTR lpModuleName
    );
fnGetModuleHandleA pGetModuleHandleA = NULL;
HMODULE WINAPI MyGetModuleHandleA(LPCWSTR lpModuleName) {
  return pGetModuleHandleA(L"NTDLL.DLL");
}
int main()
{
}

```

##### 挂钩

如果要使用 MinHook 挂钩特定的 API 的话，首先需要指定 MH_Initialize 函数，然后可以使用 MG_CreateHook 创建挂钩并使用 MH_EnableHook 启动挂钩。

```
#include <iostream>
#include "MinHook.h"
#ifdef _M_X64
#pragma comment (lib, "C:\\Users\\Admin\\Desktop\\bin\\libMinHook.x64.lib")
#endif
#ifdef _M_IX86
#pragma comment (lib, "C:\\Users\\Admin\\Desktop\\bin\\libMinHook.x86.lib")
#endif
typedef HMODULE(WINAPI* fnGetModuleHandleA)(
    _In_opt_ LPCWSTR lpModuleName
    );
fnGetModuleHandleA pGetModuleHandleA = NULL;
HMODULE WINAPI MyGetModuleHandleA(LPCWSTR lpModuleName) {
  return GetModuleHandleW(L"USER32.DLL");
}
BOOL HookTest() {
  DWORD    dwMinHookErr = NULL;
  if ((dwMinHookErr = MH_Initialize()) != MH_OK) {
    return FALSE;
  }
  if ((dwMinHookErr = MH_CreateHook(&GetModuleHandleA, &MyGetModuleHandleA, (LPVOID*) & pGetModuleHandleA)) != MH_OK) {
    return FALSE;
  }
  if ((dwMinHookErr = MH_EnableHook(&GetModuleHandleA)) != MH_OK) {
    return -1;
  }
  return TRUE;
}
int main()
{
      HMODULE hmodule = GetModuleHandleA("KERNEL32.DLL");
  HookTest();
  HMODULE hmodule1 = GetModuleHandleA("KERNEL32.DLL");
  getchar();
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mqgs6BkFNE9t8dBE2QksNy3ibkqCU89Hth8ZKEkzicRemhfB3SZ3pUMLGBJbmiaRSmiayC7dmkDVeEe1g/640?wx_fmt=png&from=appmsg)

##### 取消挂钩

取消挂钩需要注意的是 MinHook 库是不不需要使用事务的，相反如果需要删除挂钩，唯一的要求是使用挂钩函数的地址运行 MH_DisableHook API。

```
BOOL Unhook() {
  DWORD  dwMinHookErr = NULL;
  if ((dwMinHookErr = MH_DisableHook(&GetModuleHandleA)) != MH_OK) {
    return -1;
  }
  if ((dwMinHookErr = MH_Uninitialize()) != MH_OK) {
    return -1;
  }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mqgs6BkFNE9t8dBE2QksNy3OGJwgl5gFeoK9k1rHCoXANFz252dIIK8FSGZ0KxRmoCIScCZe1kjfA/640?wx_fmt=png&from=appmsg)