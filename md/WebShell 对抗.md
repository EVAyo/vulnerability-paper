<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/XhWSiSPJbUR4iqZA3b-wWA)

什么是恶意代码
-------

我们所说的恶意代码（Malicious Code）是指一种违背目标系统安全策略的程序代码，会造成目标系统信息泄露、资源滥用、破环系统的完整性及可用性。

这里所说的违背目标系统的安全策略怎么理解呢？

*   非预期的数据传输（偷偷将数据传输到指定地址）
    
*   非预期的信息获取（本来只收集 ip 地址，但是会将用户名，系统补丁信息，当前进程等信息进行收集）
    
*   非预期的配置修改（浏览器主页被修改）
    
*   非预期的权限获取（获取了键盘记录、摄像头权限、麦克风权限等）
    
*   非预期的……
    

每个系统都有一套安全策略和规则，策略和规则的目的就是保护系统的机密性、完整性和可用性。这些策略可能报考访问控制、身份验证、数据加密等措施。反正一切能够违背这些策略的软件功能，都可以称为恶意代码。

讨论：有漏洞 / 调试后门的软件，是否也能称为恶意代码？其实很难界定，首先，他确实违背了目标系统的安全策略，但是我们不能确认这些漏洞或后门是开发者有意为之还是不小心留下的，如果是有意为之的，那肯定是恶意代码，如果是不小心留下的，就不能将他定义为恶意代码，虽然他确实违背了目标系统的安全策略

恶意代码的攻击模型
---------

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rdeBibEhly1c3n36ARY7ztGKa70A9lZs8zpiavq6EgboSXicia2UOj3ePeg/640?wx_fmt=png&from=appmsg)

1.  入侵系统（程序、邮件、存储介质、植入）
    
2.  维持活提升已有权限（其传播与破坏建立在盗用用户或合法权限基础之上）
    
3.  隐蔽（改名、删除源文件、修改系统安全策略）
    
4.  潜伏（满足某些条件才能触发）
    
5.  破坏（信息丢失、泄密、系统被破坏）
    

恶意代码分类
------

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rJL9k6HcN4INibVKaBWHlsWV7YhFrCfcRbE3P1rJ9SOYVJDbvLQqVE5w/640?wx_fmt=png&from=appmsg)

### 根据语言进行分类

*   恶意文档（宏恶意代码或者利用文档漏洞获取非预期代码执行权限的，如 office、pdf 文档等）
    
*   恶意脚本（脚本语言编写，依赖于脚本解释器执行的，如 powershell、vb、vbs 等，对执行环境有依赖的）
    
*   webshell（一种特殊的恶意脚本类型，依赖于 webserver 或者 web 框架才能运行）
    
*   二进制恶意代码（由编译性语言编写，PE/ELF 等可执行文件格式，可以直接运行的）
    

### 根据功能进行分类

*   后门（恶意代码将自己安装到一台计算机来允许攻击者访问。后门程序通常让攻击者只需很少认证甚至无须认证，便可链接到远程计算机上，并可以在本地系统执行命令）
    
*   僵尸网络（与后门类似，也允许攻击者访问系统，但是所有被同一僵尸网络感染的计算机将会从一台控制命令服务器接收到相同的命令）
    
*   下载器（这是一类只用来下载其他恶意代码的恶意代码。下载器统筹是在攻击者获得系统的访问时首先进行安装的。下载器程序会下载和安装其他的恶意代码）
    
*   间谍软件（这是一类从受害计算机上收集信息并发送给攻击者的恶意代码。比如嗅探器、密码哈希采集器、键盘记录器等。这类恶意代码统筹用来获取 E-mail、在线网银等账号的访问信息）
    
*   启动器（用来启动其他恶意程序的恶意代码。通常情况下，启动器使用一些非传统的技术，来启动其他恶意程序，以确保其隐蔽性，或者以更高权限访问系统）
    
*   内核套件（设计用来隐藏其他恶意代码的恶意代码，一般是 ring0 层。内核套件通常是与其他而已代码，如后门，组合成工具套装，来允许为攻击者提供远程访问，并且使代码很难被受害者发现）
    
*   勒索软件（是恶意代码获利的有效路径，设计成吓唬受感染的用户，来勒索他们购买某些东西的恶意代码。这类软件通常由一个用户界面，使得它看起来像是割杀毒软件或其他安全程序。它会通知用户系统中存在而已代码，而唯有除掉它们的方法只有购买他们的 “软件”，而事实上，他们所卖的软件的全部功能只不过是将勒索软件进行移除而已）
    
*   发送垃圾邮件的恶意代码（这类恶意代码在感染用户计算机之后，便会使用系统与网络资源来发送大量的垃圾邮件。这类恶意代码通过为攻击者出售垃圾邮件发送服务而获得收益）
    
*   蠕虫或计算机病毒（可以自我复制和感染其他计算机的恶意代码）这节课我们主要讲的是 webshell 恶意代码，因为在红蓝对抗的过程中，打点撕开口子的第一步就是要在边界设备上做权限维持，除了直接钓鱼以外，webshell 的攻击方式是最为有效的
    

webshell 的演进史
-------------

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rP2n8Ne7bgVKJMkCGwF9uQibYBkHm5EdYy36KRdYD1joS2VqL7DwvaIA/640?wx_fmt=png&from=appmsg)

*   web 服务器管理页面（通常是指一种用于管理和配置 Web 服务器的用户界面。这些页面通常由服务器软件（如 Apache、Nginx、Microsoft IIS 等）提供，并允许管理员通过简单的图形界面或 Web 界面来执行各种操作，如配置虚拟主机、修改服务器设置、查看日志、监控性能等，最早期的时候使用的，一般是通过弱口令获取权限并执行恶意操作）
    
*   大马（如果发现一个网页的上传点，但是又想控制服务器，那么就尝试使用上传恶意代码来进行控制，这时候就出现了大马，大马的体积大、功能齐全、能够管理数据库、文件管理、对站点进行快速的信息收集，甚至能够提权。）
    
*   小马（随着攻防的演进，因为大马的体积过大，我们在上传文件的时候，会被限制上传的文件大小或是拦截的情况，那么我通过小马来上传大马，实现我们想要的功能，其实小马就相当于重写一个上传功能。）
    
*   一句话木马（再然后大家发现通过小马拉大马的方式特征还是太明显了，因为大马会留存在服务器中，那么能不能有一种代码短小精悍、功能强大、隐蔽性好的木马，我们使用客户端就可以快速管理 webshell 了呢？就这样一句话木马就诞生了）
    
*   加密一句话木马（我们都知道攻防是一直在对抗的，攻击技术和防御技术是不断升级的，这时候为了更好的隐藏一句话木马，就产生了加密一句话木马，主要通过流量和特征加密的手段实现）
    
*   内存马（随着攻防的下沉，不在本地留存文件的内存马就诞生了）
    

webshell 的分类
------------

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rSR4icxFYrGaPlJtwicic0qzA6QyaFoq7BrBhFsy5ZnEDaiby582UDasG2Q/640?wx_fmt=png&from=appmsg)

恶意代码的文件特征
---------

常见的一句话木马

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rVric8FLFPSxdDbvxXxicJmtibXgMc5CF3GNPiaUGZDU0JfroWPGePSaOfA/640?wx_fmt=png&from=appmsg)

### PHP

1.  `<?php ... ?>`：这是 PHP 的标准起始和结束标记，表示其中包含 PHP 代码。
    
2.  `@eval(...);`：这里使用了`eval()`函数。`eval()`函数是一个非常危险的函数，它允许执行传递给它的任意字符串作为 PHP 代码。在这里，`$_POST['attack']`包含的内容将被作为 PHP 代码进行执行。
    
3.  `$_POST['attack']`：这是一个 POST 请求参数，通常是从 Web 表单中提交的。攻击者可以通过将恶意代码发送到此参数来利用它。
    

### ASP

1.  `<% ... %>`：这是 ASP 代码块的标记，表示其中包含 ASP 代码。
    
2.  `eval`：这是 ASP 的一个函数，类似于 PHP 的`eval()`函数。它允许执行传递给它的任意字符串作为 ASP 代码。
    
3.  `request("attack")`：这是从请求中获取名为 "attack" 的参数的 ASP 语法。攻击者可以通过向该参数传递恶意代码来利用它。
    

### ASPX

1.  `<%@ Page Language="Jscript"%>`：这是一个指令，用于指定页面使用的脚本语言，这里指定为 JScript。
    
2.  `<% ... %>`：这是 ASP.NET 代码块的标记，表示其中包含服务器端代码。
    
3.  `eval(Request.Item["attack"],"unsafe");`：这行代码使用了 ASP.NET 的`eval()`方法，该方法用于执行传递给它的字符串作为代码。第一个参数是`Request.Item["attack"]`，它表示从请求中获取名为 "attack" 的参数的值。第二个参数是字符串 "unsafe"，它用于指定执行环境。
    

### JSP

1.  `<% ... %>`：这是 JSP 的脚本标记，表示其中包含 Java 代码。
    
2.  `Process process = Runtime.getRuntime().exec(request.getParameter("cmd"));`：这行代码使用`Runtime.getRuntime().exec()`方法执行传递给页面的命令。命令从 HTTP 请求的参数中获取，这在安全性上存在潜在的问题，因为它允许任何人执行任何命令，包括可能导致系统受损或数据泄露的恶意命令。
    
3.  `InputStream inputStream = process.getInputStream();`：这行代码获取执行命令后的输入流，以便读取命令的输出。
    
4.  `BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));`：这行代码创建一个用于读取命令输出的`BufferedReader`对象。
    
5.  `String line;`：这是一个声明字符串变量的语句，用于存储每行命令输出的内容。
    
6.  `while ((line = bufferedReader.readLine()) != null){ ... }`：这是一个`while`循环，用于逐行读取命令的输出，直到到达输出流的末尾（`readLine()`返回`null`）为止。
    
7.  `response.getWriter().println(line);`：在每次迭代中，将读取的每行输出发送回客户端，使用`response.getWriter().println()`方法。这将导致输出显示在客户端的浏览器上。根据这四种常见的一句话木马，我们可以归纳总结出 webshell 的文本特征，就是首先必须是从外部传递一个可控的参数，第二就是传递的参数被系统指令所执行，这里的系统指令就是危险函数
    

参数传递
----

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rsJdYjDcwVjSETbia83pwkyUuLEDvWp31L74Ed93s0162wKPmdMBz82w/640?wx_fmt=png&from=appmsg)

这里我们所说的参数传递不单单指外部参数传递，在 webshell 对抗中，在函数间的参数传递也很常用

### 从外部传入指令参数

1.  从内置全局数组中获取外部参数
    

1.  `$_GET['cmd']`
    
2.  `$GLOBALS['_POST']['cmd']`
    

3.  利用环境变量相关函数获取外部参数
    

1.  `getenv('HTTP_CONNECTION')`
    

5.  将外部参数作为文件 / 目录信息写入磁盘
    
6.  将外部参数存入 output buffering 缓存中
    
7.  利用 PHP 原生函数获取外部参数
    

1.  `get_defined_sys`
    
2.  `getallheaders`
    
3.  `phpinfo`
    

9.  利用输入 / 输出流获取外部参数
    
10.  利用网络请求从远程 IP 获取外部参数
    

1.  `file_get_contents`
    
2.  `get_meta_tags`
    

12.  利用 xml 处理函数获取外部参数
    

1.  `simplexml_load_string`
    

14.  利用数据库相关扩展获取外部参数
    

1.  `mysql`
    
2.  `memcache`
    
3.  `redis`
    

16.  利用本地变量注册获取外部参数
    

1.  `parse_url`
    
2.  `etract`
    

### 动态生成数值和字符串的方式

1.  动态生成数组键值
    

1.  利用 try-catch 存储和生成当前数组 key
    
2.  利用另一个数组变量存储当前数组 key
    
3.  利用 time 延时逻辑生成当前数组 key
    
4.  利用 random 逻辑生成当前数组 key
    

3.  动态生成参数名称
    

1.  利用运算符技术（自增、异或、取非、取反）
    

5.  动态生成函数名称
    

1.  利用字符串拼接技术
    
2.  利用 explode 字符串分组技术
    

7.  对字符串内容进行编码 / 解码的方式
    

1.  利用 base64 编码 / 解码
    
2.  利用字符串顺序逆转
    
3.  利用文本替换
    
4.  利用 0x16 进制编码
    

9.  向函数传入实参 / 变量的方式
    

1.  `try{throw new Exception("system");}`
    
2.  `__toString`方法重载
    
3.  利用 array callback 相关函数实现参数传递
    
4.  利用 define 宏定义方式实现参数传递
    
5.  利用自定义加 / 解密函数进行处理后再进行参数传递
    
6.  利用类方法重载的方式实现隐式参数传递
    
7.  利用 try-catch 方式传递函数名
    

危险函数
----

我们以 PHP 为例，为什么是 PHP，因为 PHP 是一种动态弱类型语言，相对于 Java 强类型语言而言，PHP 在参数传递、类型转换、函数调用方式都非常灵活，这给开发者带来开发便利的同时，同时也给攻击者编写各种畸形恶意代码带来了很多便利`eval` 函数允许执行以字符串形式给出的 PHP 代码。这意味着你可以在运行时动态地生成 PHP 代码并执行它。eval 是一个语言构造器而不是一个函数，不能被 可变函数 调用`system` 函数用于执行操作系统命令，并返回执行结果。`assert` 函数用于在程序中进行断言，是一种程序中的声明，用于在特定条件下验证代码的正确性，在 PHP7.1 版本以后， **assert() 默认不再可以执行代码** 就像`echo`一样。

`exec` 函数用于执行外部命令，并将结果存储在数组中，每行作为数组的一个元素

`shell_exec` 函数执行给定的 shell 命令，并将其完整输出作为字符串返回。

`passthru` 函数执行外部命令并将结果直接输出到标准输出。与 `system` 函数类似，但不同之处在于 `passthru` 将命令的输出直接发送到标准输出，而不是作为函数的返回值返回

`popen` 函数用于启动一个外部进程，并建立一个到该进程的管道。它允许以读或写的方式与外部进程进行交互。`popen` 返回一个文件指针，您可以使用 `fread` 或 `fwrite` 来读取或写入与该进程的通信。

`proc_open` 函数提供了更多灵活性，它允许您以更底层的方式启动外部进程，并为输入、输出和错误流建立单独的管道

webshell 的监测
------------

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rGiaN01O66Sm15DWayqicsNI3k4um2HiaZdkpvUm0x4HbZqRc8WXnY5SQQ/640?wx_fmt=png&from=appmsg)

### 正则匹配

```
(eval|system)\(\$_(POST|GET|REQUEST)\[

```

### SSDEEP

通过模糊哈希匹配已知样本，可以允许⼀定范围内的修改，原理是分片分别计算哈希，连接后得到字符串，比较时计算两个字符串的加权编辑距离，评估样本的相似度。加权编辑距离指⼀个字符串最少经过多少次操作 (增加、删除、修改、交换) 得到另⼀个字符串，不同的操作对应不同的权值，结果相加。ssdeep 只能针对已知样本而且没有⼤范围修改的情况，而且当样本量增加时比较操作的计算量也会随之增加。ssdeep 在恶意软件检测中有比较多的应用，但是针对 webshell 局限性比较明显，用途有限。

### 静态分析

基本相当于白盒扫描，静态分析主要流程一般为词法分析、语法分析、污点分析。

#### 词法分析

词法分析将字符序列转换为记号（token）序列的过程。词法只识别语素，不关心几号之间的关系 (比如括号是否匹配)。直观的例⼦就是语法高亮，每⼀个不同颜色的色块就是⼀个 token。php 本身提供了⼀个 token_get_all 和 PhpToken::tokenize 方法将 php 源码转换成 token 数组。

#### 语法分析

语法分析是以词法分析结果 (token 流) 为输入，进行语法检查，分析语法结构，构建中间语言的过程。⼀般来说中间语言有多种不同的表达形式。比如抽象语法树、三地址码、静态单赋值形式

#### 污点分析

污点分析就是分析程序中由污点源引入的数据，在经过数据流处理，传播到污点汇聚点后，是否符合预设的策略。对于 Webshell 的定义而言，这个策略就是外部可控的值，能否传递进危险函数，从而达到任意代码执行、命令执行的目的。

因为 php 动态弱类型的特性，灵活度极高，单纯静态分析漏报的可能性很高，最简单的例子比如

```
<?php
    $a = "sys"."tem";
    $a($_GET["a"]);

```

静态分析无法获取 $a 的内容，所以不能判断第三行具体执行了哪个函数，也就无从检测了。所以⼀般情况下 webshell 检测还需要结合动态分析

### 动态分析

动态分析⼀般通过 hook 关键操作与函数的方式，构造⼀个沙箱的环境直接执行样本，执行过程中可以对污点传播进行跟踪，当污点传播到敏感函数时即可判断漏洞存在（类似 IAST）。动态分析的缺陷：

1.  动态分析无法判断跳出循环的时机，可能导致循环执行不充分
    
2.  分⽀爆炸，分⽀多了之后执行时间爆炸
    
3.  依赖外部信息的 “隐含分支”
    

### AI 分析

基本思路是把 opcode 丢进去炼丹，用什么算法的都有：贝叶斯、SVM、随机森林、卷积神经网络....，总之方法多种多样

### 恶意代码与安全设备的对抗

*   不确定值对抗绕过
    

通过对关键数据，如命令、参数或关键字等进行混淆和变换，使其难以被检测、分析和识别，增加对抗检测的难度

*   分支对抗绕过
    

分支对抗的主要目的是通过改变恶意代码的控制流程，增加代码路径的复杂性和多样性，使得检测和分析系统难以追踪和理解恶意代码的执行流程，从而提高对抗检测的难度

*   编码对抗绕过
    

编码对抗的主要目的是对恶意代码中的数据进行编码或加密，以隐藏其真实含义和功能。

*   混淆对抗绕过
    

混淆对抗的主要目的是使恶意代码的结构和逻辑变得复杂和模糊，使其难以被理解、识别和分析。

*   命令分割对抗绕过
    

将恶意指令拆分成多个片段，在目标系统上动态拼接和执行，以避免被静态分析系统识别为恶意代码

*   利用漏洞绕过
    

利用系统或应用程序的漏洞，绕过安全防护，例如利用文件上传漏洞、代码执行漏洞等