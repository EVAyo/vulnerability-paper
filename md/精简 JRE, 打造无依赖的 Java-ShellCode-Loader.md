<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/brSzTx-U62iTF9EjEtVLSg)

前言
--

       利用小众语言进行免杀一直是一个屡试不爽的方法，从 python 到 go 再到现在的 nim 免杀，用的人越多杀软的检测也就越来越严格。现在自己写的 go 程序基本只要涉及到网络通信 360 就干掉了。那么还有没有什么新的姿势呢？

之前介绍过在 As-Exploits 中用到的基于 JNA 实现的 ShellCodeLoader(https://t.zsxq.com/022FQrFAu)，这个 Loader 在精简后不到 1m，配合 JarLoader 模块在插件里面可以直接内存加载，文件不落地。后来发现落地了问题也不大，到现在 VT 还是 0/57。所以后来抽出来作为一个单独的项目：https://github.com/yzddmr6/Java-Shellcode-Loader![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpJGPEzms5RN4qa7JXzFIs9pSObZUrsEdPRk67xW8icBc1qUzUNtc7F9g/640?wx_fmt=png)

实战里面有 Java 的 WebShell 用起来非常方便，一键免杀 xxx。但是缺点是如果用来钓鱼，或者碰上 jdk 环境过高过低都用不了，还是有局限性。所以就研究了一下怎么跟 jre 一起打包成一个单独的可执行文件 exe。

    目前成果如下：用自解压精简后带 jre 环境的 exe 只有 6.5m，用 Enigma Virtual Box 压缩模式 8.5m，差不多跟 python 打包后差不多大小，VT 6/67，基本可以实现我们的需求。

jre 目录结构
--------

原版一个 jre 大概快 200m，在没有安装 jre 环境的普通用户来说，显然带着整个 jre 和后门一起打包是不可能的了，但我们可以从 jre 中提取加载后门时需要用到的 class 文件, 并集合到一起, 这样就能大大压缩 jre 的体积。

jre 最主要的两个目录是 bin 跟 lib，bin 下主要是各类 dll 跟可执行文件，lib 下是 java 的依赖库。精简 jre 就可以从这两方面入手。

### **lib 目录**

**access-bridge-64.jar**

    Java Accessibility API 是 Java Accessibility Utilities 的一部分，它是一组实用程序类，可帮助辅助技术提供对实现 Java Accessibility API 的 GUI 工具包的访问。

**charsets.jar**

    Java 字符集，包含 Java 所有支持字符的字符集

**cldrdata.jar**

    Unicode CLDR 为软件提供了支持世界语言的关键构建块，提供了最大和最广泛的语言环境数据库。这些数据被广泛的公司用于其软件国际化和本地化，使软件适应不同语言的惯例以用于此类常见软件任务.

**deploy.jar**

    Java 安装目录的常见部分 - 该文件运行某些产品的安装。正确设置 Java 路径后，用户可以执行此文件（只需双击它或按文件上的 Enter 键），要部署的应用程序将运行其安装程序。例如。诺基亚 OVI 套件通常使用这种部署形式。作为彼此的 JAVA 包，如果您将其重命名为 ZIP 并打开内容，则可以检查包中的类。

**dnsns.jar**

    即 DNS naming service , 提供 DNS 地址服务的包，里面只有 2 个方法 getHostByAddr 和 lookupAllHostAddr

**jaccess.jar**

    定义 Assistive Technologies.AWT（Abstract Window Toolkit）使用的 JDK 实用程序类

**javaws.jar**

    JNLP（Java Network Launching Protocol ）是 java 提供的一种可以通过浏览器直接执行 java 应用程序的途径。

**jce.jar**

    java 类库是 java 发布之初就确定了的基础库， 而 javax 类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案， 所以，就加上些，典型的就是 awt(Abstract Windowing ToolKit) 和 swing。） 这个包都是加密相关的。

**jfr.jar**

    和 jdk\bin\jmc.exe 有关系。Java Mission Control 包括 JMX 控制台和 Java 飞行记录器。Java 飞行记录器 (JFR) 是一个用于收集有关正在运行的 Java 应用程序的诊断数据和概要分析数据的工具。它集成到 Java 虚拟机 (JVM) 中， 几乎不会带来性能开销，因此甚至可以在高负载生产环境中使用。使用默认设置时，内部测试和客户反馈表明性能影响低于 1%。对于一些应用程序，这一数字会大幅降低。但是，对于短时间运行的应用程序 (不是在生产环境中运行的应用程序类型)， 相对的启动和预热时间可能会较长，这对性能的影响可能会超过 1%。JFR 收集有关 JVM 及其上运行的 Java 应用程序的数据。

**jfxrt.jar**

    JDK 有个 rt.jar ，是存储 JAVA 语言核心类的的。这个 jfxrt.jar 就相当于 JavaFX 的 rt.jar. JavaFX 是一组图形和媒体包，使开发人员能够设计，创建，测试，调试和部署在不同平台上一致运行的富客户端应用程序。在 jdk 最新的发版当中，javafx 的包已经被移除了。

**jfxswt.jar**

    也是和 JavaFx 相关，为 JavaFx 和 Swing 提供一些兼容性操作。

**jsse.jar**

    SSL 连接，验证的包，

**localedata.jar**

    日期显示国际化的包，里面包含各地区的日期文字。

**management-agent.jar**

    里面只有一个文本文件。

**nashorn.jar**

包括

1. 动态链接. 包含用于链接调用的动态调用站点的接口和类。dynalink 与 java.lang.invoke 包密切相关，并且依赖于该包。虽然 java.lang.invoke 为 invoke dynamic 调用站点的动态链接提供了一个低级别的 API，但它不提供一种方法来表示对象的更高级别操作，也不提供实现这些操作的方法。如果一种语言是静态类型的，并且它的类型系统与 JVM 的类型系统匹配，那么它可以使用通常的调用、字段访问等指令（例如 invokevirtual、getfield）来实现这一点。但是，如果语言是动态的（因此，某些表达式的类型直到在运行时进行计算时才知道），或者其对象模型或类型系统与 JVM 的对象模型或类型系统不匹配， 那么它应该使用 invokedynamic 调用站点，并让 dynalink 管理它们。

2.Javascript 引擎 从 JDK 8 开始，Nashorn 取代 Rhino 成为 Java 的嵌入式 JavaScript 引擎。Nashorn 完全支持 ECMAScript 5.1 规范以及一些扩展。该特性允许开发人员将 JavaScript 代码嵌入到 Java 中，甚至从嵌入的 JavaScript 中调用 Java。此外， 它还提供了使用 jrunscript 从命令行运行 JavaScript 的能力。

**plugin.jar**

    功能很庞大的一个包。

**resources.jar**

提示信息显示国际化的包，里面各地区的文字, 图片等。

**rt.jar**

java 核心源代码包

**sunec.jar ,sunjce_provider.jar,sunmscapi.jar,sunpkcs11.jar**

都是加密相关的包。

**zipfs.jar**

java 对 zip 文件操作的支持。

### **bin 目录**

只找到了 jdk/bin 目录的介绍，jre 有些没有，将就着看一下吧

https://www.cnblogs.com/chongcheng/p/14138996.html

精简 rt.jar
---------

rt.jar 是 java 核心源代码包，原版有 61m，我们主要的精简也就是从这里入手。原理是 jar 包运行是加上 - XX:+TraceClassLoading 参数可以打印出所有被加载过的 class 文件，然后在对这部分 class 进行二次打包，生成我们的精简 rt.jar。这里借 MG 师傅的图一用：

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpKqVdIO29BUicjsbaXsTgapbc2569S8pQhfcicmTrB75ZsalicQVVkichOg/640?wx_fmt=png)

代码是参考 MG1937 师傅的这篇文章：

https://www.cnblogs.com/aldys4/p/14879607.html，修改后代码如下：

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
public class Main {
    public static void main(String[] arg) throws IOException {
        Runtime runtime = Runtime.getRuntime();
        String[] command = {"java", "-jar", "-XX:+TraceClassLoading", "D:\\ShellcodeLoader_jar\\ShellcodeLoader.jar", "aaaa"}; //这里要加上参数
        Process process = runtime.exec(command);
        BufferedReader bReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuffer sBuffer = new StringBuffer();
        List<String> list = new ArrayList<String>();
        int i = 0;
        String lineString;
        while ((lineString = bReader.readLine()) != null) {
            String core = getCore(lineString);
            if (core != "") {
                sBuffer.append("\n" + core);
                list.add(getCore(lineString.replace(".", "/")));
            }
            i++;
        }
        bReader.close();
        System.out.println(sBuffer.toString());
        list.add(0, "D:\\rt.jar");
        list.add(0, "xvf");
        list.add(0, "jar");
        String[] jar = list.toArray(new String[list.size()]);
        process = runtime.exec(jar);
        getOutput(process);
        System.out.println("Load class:" + i);
        System.out.println("jar xvf done!");
        String[] cmdJarPackage = cmd("jar cvf rt.jar com java javax META-INF org sun sunw");
        runtime.exec(cmdJarPackage);
        System.out.println("All done!");
    }
    public static String getCore(String line) {
        String result = null;
        if (line.startsWith("[Loaded")) {
            if (line.indexOf(".jna.") > 0 || line.indexOf("asexploits") > 0) {
                return "";//过滤jna包跟我们自己的包名
            } else {
                result = line.split(" ")[1];
            }
            return result;
        } else {
            return "";
        }
    }
    public static String[] cmd(String cmd) {
        return cmd.split(" ");
    }
    public static void getOutput(Process process) throws IOException {
        BufferedReader bReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        while (bReader.readLine() != null) {
            System.out.println("\n" + bReader.readLine());
        }
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpIJ1FsI9QxkPJjKt4An6icYuzu2eXcJSBhVEF3EInja3XIabpkCYVacA/640?wx_fmt=png)

这里有一个坑点，就是第一次获取加载的 class 信息的时候没有加上 ShellCode 参数，也就会导致有些运行期间才会用到的类没有加载。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpAmib66DRvsJibz7AaDYxUVGsOlPAiaPHF4yTURRxtH3pmQrGQRWnKIbtA/640?wx_fmt=png)

解决办法就是加上要执行的 ShellCode，把执行过程中所有加载的类都暴露出来，然后再打包。这里的 aaaa 随便写，只要能走到注入的过程就可以。可以看到现在的 rt.jar 已经不报错了。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpz88Br9zvGGabEOv5kof0picPjNNuXib18ZY3XpaQnAdtXwft2omE65yg/640?wx_fmt=png)

精简之前 lib 目录是 104m，现在已经压缩到 44m 了。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpic8TWCEH8hmSG4zkYWfQBzGDoArScA5TPuia41Cjna8n3yApmBujnNFg/640?wx_fmt=png)

我们压缩后的 rt.jar 也只有 1.8m 大小

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpiaQyFkO6aCuGt1jPtenn2ibKobUGkPZEcEltLuTWDo5DjNAwkon05nDw/640?wx_fmt=png)

这样肯定还是不够的，剩下目录里也有很多冗余的文件，这部分基本直接删除就可以了，不需要二次打包。另外 charsets.jar 还是有优化空间的，可以用类似 rt.jar 的方法进行精简，这里就懒得处理了。

    最后 lib 目录优化到只有 5m 大小了。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpa5qaU417EnONiaTV8Z6MWTQtAsHdX3AlFGUU6QTiaVicGklZo2ppKML8A/640?wx_fmt=png)

精简 dll
------

bin 目录同样很大，也是我们要优化的对象。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpy0oPAxCEHyGaoA6EpUHAN1SkCyfZ8fqsCc4AVlmWnicD1Xm4ibUfOW4Q/640?wx_fmt=png)

这里采取的办法是用 process explorer 查看程序运行时加载了哪些 dll 或者 exe，仅保留这部分，其他的都可以删掉。

注意这里最好加一个 System.in.read() 保持控制台不退出，不然就会一闪而过，process explorer 就看不到了。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpU5ZVbm7XOjxxCOicXYpouwUL4ZUwk0Zic43nwgvj1e13tXmWvnQicsfbg/640?wx_fmt=png)

还有一个简单的办法，在程序跑起来的同时，删除 bin 目录下所有文件，如果提示被占用了那么就是被打开了，把这部分跳过即可。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPp0tUPxYgOZmywNUcNslNibp4sHJwXCNDrUiauIgVsvLwmG80LPxNdNqTw/640?wx_fmt=png)

精简过后的 bin 目录大概 10m，主要是 jvm.dll 比较大。他是 jvm 的核心链接库，不能轻易改动。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpgxJ21HnDTOCsYtRiazNZib8bzdQicFhnulPbUkcBSHUg8w4mGibvnWHmtw/640?wx_fmt=png)

自解压捆绑执行
-------

环境整好了，接下来就是让他跑起来。自解压是钓鱼老套路了，搞个 vbs 来运行我们的 jar。这里的 ShellcodeLoader.jar 我硬编码了一个弹计算器的 ShellCode 先测试一下。

```
Set ws = CreateObject("Wscript.Shell")
ws.run "cmd /c .\jre\bin\java.exe -jar .\ShellcodeLoader.jar"

```

执行成功

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpadDXw4jSxhiaPws0IsPdR2CgzTaeZ3JehahfIfdxgIOkBrt3XEyKyYg/640?wx_fmt=png)

压缩出来 6.5m

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpLF6jlMxm0LAhPJaQx23LhgRUBvKJcib7TRvMNqu3QXEx4L5pe5eUv7A/640?wx_fmt=png)

VT 6/62 还好，但是 360 杀了，估计自解压这种已经进特征库了。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpVQlVgLkOe8sFicsRibOI1rQ8YQ1VpnEg2zHw0cPPvBykI9jm1o73B6Cw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpKVj77I51UgYzYo8t9KwWCpMQBh9C8jpSwqLXuBAibIt1az2TnRNP6icQ/640?wx_fmt=png)

EnigmaVirtualBox 打包全部文件
-----------------------

自解压估计已经被重点监控了，用 EnigmaVirtualBox 把 jre 跟 jar 打包成一个单独的 exe 试试

这里 install.exe 是偷懒用 msfvenom -p windows/exec 生成的

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpbUmfJA3mFhtpGNaVMunEJFtYNJ15iarMkmuqa4pEc8K8dciawCt9Ssng/640?wx_fmt=png)

可以执行，但是会有 UAC 提示框，不太行

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpFQ5EPel8grlNFvRogpVr4FX1PuD8c1mFXqia78bV5KUibibjCricSPk0Vg/640?wx_fmt=png)

VT 上查杀过半了，看来不能偷懒

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPp4JvlQXD82zdoJTmcfcpBuLKJkcbhRqBXgOLkVg7vS6UrU7Lt8KEKGA/640?wx_fmt=png)

后来又用 C++ 写了一个 exe 去调用，还是杀的比较多

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpmFGrt5yIjUpptpeBAP5AkwFW7IhI3EiafAkdWrhMmRAm8ukXFgoNUHQ/640?wx_fmt=png)

EnigmaVirtualBox 打包 jre
-----------------------

不过话说我为什么要打包到一起呢，沙箱里面一跑就出来了，这就失去了 jar 的优势：jar 除了可以分离真正的 Payload 以外，本身就可以加各种混淆，各种商业软件也都是带混淆的，杀软也不能直接杀。

转换思路，我可以仅打包一个人畜无害的 jre 到 exe，然后再 jre.exe -jar xxx 去调用。

打包方法同上，打包出来后 8.2m，测试一下能不能用

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpcheK1phhCZ90BmjrE4tro381FLm1zBvtvLkricv8icTsWvo5LkoEsdrA/640?wx_fmt=png)

执行成功

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpzeBNxKj4TCoRiaHN6ibQLR3udVic4ppXSZLnTS24Te2OycxsYYMqWZSDw/640?wx_fmt=png)

xxx 不杀

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPpfkMtbEibXQSOLt3oWfNKbW1wb7HqDvQMD3WprWQfgDE3FbmiaYghd6qw/640?wx_fmt=png)

VT 测一下还有 6 个引擎检出。。。这 tm 就是个 java.exe 啊，还 Static ML，真就瞎告呗。这样说我也能搞一个杀毒引擎，看到 PE 头就杀，名字就叫 Deep Static ML。

![](https://mmbiz.qpic.cn/mmbiz_png/LtiayO136fU7vCOJyphibzUIOu5lyX9wPp3UZ1mQMQ8bsSsSOH6GWdaKku7JlxLzRmOJz6wsGLj5oa80DATSuia4g/640?wx_fmt=png)

最后
--

    本文仅用于安全研究，请勿用于非法用途。如果有什么问题欢迎交流。