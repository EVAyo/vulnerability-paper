<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/8240)

> 先知社区，先知安全技术社区

关于 apache kylin 漏洞就 2 篇帖子：  
[https://mp.weixin.qq.com/s/QzlHYST0kIqjNV-hnosyAw](https://mp.weixin.qq.com/s/QzlHYST0kIqjNV-hnosyAw)  
[https://www.freebuf.com/vuls/243541.html](https://www.freebuf.com/vuls/243541.html)  
其中，CVE-2020-1392 是 jd 蓝军发现的。  
直接就开始分析吧，首先分析 sink，  
Sink 就很简单

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200831154406-bf683266-eb5d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200831154406-bf683266-eb5d-1.png)

这里的 sink 我们就正常的去定义一个 construtorCall，然后这个 construtorCall 限定在 processBuilder 下就行。如果你不会写，那就很棒棒了，codeql 官方有一个 ExternalProcess.qll 库里面有一个 ArgumentToExec 类，这个类会覆盖到这个 sink

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200831154440-d3edef50-eb5d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200831154440-d3edef50-eb5d-1.png)

那么就直接写一个

```
override predicate isSink(DataFlow::Node sink) {
        sink.asExpr() instanceof ArgumentToExec
}


```

就定义好了 sink。  
接下来定义 source。  
我们看到漏洞的分析里，漏洞最开始的参数是来源于

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200831154504-e1c604aa-eb5d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200831154504-e1c604aa-eb5d-1.png)

这的注解的 project 参数。这个 project 应该就是一个任务的名字。  
对于这个 source 的定义的话，就可以判断下他的注解和参数，参数也是有注解的，把这个抽象出来一个 method  
代码就是

```
class DumpProjectDiagnosisInfoMethod extends Method {

     DumpProjectDiagnosisInfoMethod() {

    //    this.hasName("dumpProjectDiagnosisInfo")

     this.getSourceDeclaration().getAnAnnotation().toString().matches("%Mapping%")  and

     this.getAParameter().getAnAnnotation().toString().matches("PathVariable")

    }

}


```

接下来我们可以看到整个漏洞的产生有不断的调用方法。  
那么定义一个

```
class CallTaintStep extends  TaintTracking::AdditionalTaintStep {

    override  predicate step(DataFlow::Node n1, DataFlow::Node n2) {

      exists(Call  call |

        n1.asExpr()  = call.getAnArgument() and

        n2.asExpr()  = call

      )

    }

}


```

来保证调用关系。  
然后我们跑下 codeQL

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200831154518-ea4c9576-eb5d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200831154518-ea4c9576-eb5d-1.png)

可以看到 source 有 3 个地方可以流入 processbuilder，分别是 CubeController.java,DiagnosisController.java 这 2 个文件，其中 Diagnosisxx.java 这个文件有 2 个注解方法可以流入到 processbuilder。分别获得了 CVE-2020-13925，CVE-2020-1956。  
京东的那个分析文章也说了，漏洞存在的 2 个接口，而我们多了一个。这个会不会存在问题呢？  
我们来看下他的数据流：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200831154529-f133010e-eb5d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200831154529-f133010e-eb5d-1.png)

可以看到数据流第 5 步经过了一个 checkParameterWhiteList 方法，这个方法需要满足正则表达式：

```
COMMAND_WHITE_LIST =  "[^\\w%,@/:=?.\"\\[\\]]";


```

反正我是绕不过。绕过了 这就是一个新的 CVE 了。但是放心，这个数据流是通的。

自从用了数据流，挖洞都轻松了很多。  
用 CodeQL 分析 1day 很轻松 看看 cve 描述 然后挖掘一下就基本上可以把没 poc 的漏洞分析出利用方式了。  
apache kylin 就有一个新的 cve 也是国人提交的，大家可以试试分析下