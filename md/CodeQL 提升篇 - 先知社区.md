<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10852)

> 先知社区，先知安全技术社区

如果已经了解 CodeQL 基础知识相信如下内容对各位有一定的帮助

功能
--

> 编译

闭源项目创建数据库，可以使用该工具：[https://github.com/ice-doom/codeql_compile](https://github.com/ice-doom/codeql_compile)

> 历史查询

在 VSCode 左侧可以的 QUERY HISTORY 可以点击切换历史查询内容，也可以右键比对查询结果等功能  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221508-b3ee610a-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221508-b3ee610a-7b8d-1.png)

> 查看 AST

在 VSCode 左侧选中要查看的 java 文件之后，点击 View AST 即可查看，并且鼠标点击到 java 文件中的类、方法等，AST VIEWER 中会自动帮助我们定位到该项  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221520-bb92e2fa-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221520-bb92e2fa-7b8d-1.png)

> 快速查询

在我们编写的一些谓词上方有个快速查询按钮，点击之后可以快速查询当前谓词的结果。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221527-bf41cd94-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221527-bf41cd94-7b8d-1.png)

语法
--

列出个人经常用到的语法和一些注意事项

### 获取具体 QL 类型

不确定使用什么方式获取目标时，除了通过查看 AST，还可以通过词`getAQlClass()`获取调用它实体的具体 QL 类型。

```
from Expr e, Callable c
where e.getEnclosingCallable() = c
select e, e.getAQlClass()

```

### 尽可能缩小范围

如下定义，如果项目代码量很大，则非常耗时

```
override predicate isSink(DataFlow::Node sink) {
    sink.asExpr().getParent() instanceof ReturnStmt
}

```

可以设置 return 语句在哪个函数中调用来缩小范围，乃至其 Type 的全限定名

```
override predicate isSink(DataFlow::Node sink) {
    sink.asExpr().getParent() instanceof ReturnStmt
    and sink.asExpr().getEnclosingCallable().hasName("xxxxx")
}

```

### 个人使用的几个规则

```
// 以某个方法的参数作为source (添加了几种过滤方式，第一个参数、该方法当前类的全限定名为xxxx)
override predicate isSource(DataFlow::Node source) {
    exists(Parameter p |
        p.getCallable().hasName("readValue") and
        source.asParameter() = p and
        source.asParameter().getPosition() = 0
        and p.getCallable().getDeclaringType().hasQualifiedName("com.service.impl", "xxxxx")
    )
}

// 以某个实例的所有参数作为source(`X1 x1 = new X1(a,b)`，这里a、b作为source)，过滤：调用该实例的方法名称为`Caller`，实例类型名称为`X1`
override predicate isSource(DataFlow::Node source) {
    exists(ClassInstanceExpr ma |
        source.asExpr() = ma.getAnArgument()
        and ma.getTypeName().toString() = "X1"
        and ma.getCaller().hasName("Caller")
    )
}

```

### 调用端点路径

比如我们想知道方法 A 到方法 G 之间调用端点路径，则可以使用`edges`谓词，编写如下所示，如果也想找覆写的某个方法（如：接口实现类中的方法）可以将`calls`替换为`polyCalls`

```
import java

class StartMethod extends Method {
  StartMethod() { getName() = "main" }
}

class TargetMethod extends Method {
  TargetMethod() { getName() = "vulMain" }
}

query predicate edges(Method a, Method b) { a.calls(b) }

from TargetMethod end, StartMethod entryPoint
where edges+(entryPoint, end)
select end, entryPoint, end, "Found a path from start to target."

```

得到的结果如图所示  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221539-c67b37e4-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221539-c67b37e4-7b8d-1.png)

### 对某接口实现

主要是通过 codeql 自带谓词`overridesOrInstantiates`判断该函数是否进行了重写。  
如下，就能获取实现`JSONStreamAware`接口，重写的方法

```
class JsonInterface extends Interface{
    JsonInterface(){
        this.hasQualifiedName("com.alibaba.fastjson", "JSONStreamAware")
    }

    Method getJsonMethod(){
        result.getDeclaringType() = this
    }
}

class CMethod extends Method{
    CMethod(){
        this.overridesOrInstantiates*(any(JsonInterface i).getJsonMethod())
    }
}

from CMethod m select m, m.getDeclaringType()

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221547-cb93e7da-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221547-cb93e7da-7b8d-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221559-d250613e-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221559-d250613e-7b8d-1.png)

### 查询 Select

如果编写查询不规范可能会经常碰到类似如下错误  
Showing raw results instead of interpreted ones due to an error. Interpreting query results failed: [xxxxx] Exception caught at top level: Could not process query metadata. Error was: Expected result pattern(s) are not present for problem query: Expected exactly one pattern. [INVALID_RESULT_PATTERNS]

这种情况的注意事项如下：  
在不使用 path 查询时，元数据为`@kind problem`，并且也别导入 path 相关内容，如：`import DataFlow::PathGraph`，否则查询时会一直产生失败日志，而且当 string 中使用了`$@`占位符时会一直失败使其当作正常字符串展示在结果中。  
这种查询由两列组成`select element, string`

使用 path 查询时，元数据为`@kind path-problem`，查询模板为`select element, source, sink, string`  
当`element`指定为`source`节点时最先显示的是`source`  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221611-d96e5732-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221611-d96e5732-7b8d-1.png)

当`element`指定为`sink`节点时最先显示的是`sink`  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221614-db52ee14-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221614-db52ee14-7b8d-1.png)

AdditionalTaintStep
-------------------

在为一些项目编写规则查询时，经常碰到数据流中断的情况，下面列出经常碰到中断的情况和解决方案。

### setter 和 getter

场景 1：在做 GitHub CTF 案例时这块有体会，CodeQL 为减少误报很多地方都需要我们根据相应场景自己连接数据流，比如 getter。  
这种情况需要将调用方法的对象（通过`getQualifier`谓词获取限定符）和调用方法的返回值连接起来。如下操作就是从`get%`方法访问到它的限定符作为附加步骤重新连接起来。

```
class GetSetTaintStep extends TaintTracking::AdditionalTaintStep{
    override predicate step(DataFlow::Node src, DataFlow::Node sink){
        exists(MethodAccess ma |
            (ma.getMethod() instanceof GetterMethod or ma.getMethod() instanceof SetterMethod or ma.getMethod().getName().matches("get%") or ma.getMethod().getName().matches("set%"))
            and
             src.asExpr() = ma.getQualifier()
            and sink.asExpr() = ma
            )
    }
}

```

### mapper

场景 2：使用 mybatis 通常将接口命名为 xxxxMapper 或者 xxxxDao 这种形式，在 xml 配置文件中通过 namespace 指定其全限定名，当数据流需要经过数据库查询到这里会断开，那么需要手动将其连接起来。

如下我们使用普通查询从接收请求到`return`语句结束  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221624-e19dcba4-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221624-e19dcba4-7b8d-1.png)

最后会在此处中断  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221629-e42ef88e-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221629-e42ef88e-7b8d-1.png)

对应 xml 配置  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221632-e672c5c6-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221632-e672c5c6-7b8d-1.png)

那么需要添加`AdditionalTaintStep`将中断进行拼接。这里将污染源查询的`id`和某个方法连接（该方法的对象类型名称是`xxxxDao`），当然有的可能名称是`xxxxMapper`，根据情况而定

```
class MapperTaintStep extends TaintTracking::AdditionalTaintStep{

    override predicate step(DataFlow::Node src, DataFlow::Node sink){
        exists(MethodAccess ma |
            (ma.getQualifier().getType().getName().matches("%Dao") or ma.getQualifier().getType().getName().matches("%Mapper"))
            // and (src.asExpr() = ma.getAnArgument() or src.asExpr() = ma.getAnArgument().getAChildExpr())
            and src.asExpr() = ma.getAnArgument()
            and sink.asExpr() = ma
        )
    }
}

```

最后查询结果：  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221643-ecd586d8-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221643-ecd586d8-7b8d-1.png)

### 污染源作为参数传入

场景 3：如下图所示，`instance`作为污染源，`workNode`也被污染，将其传入`t.setSceneKey`为`t`对象的`sceneKey`属性赋值，那么这里`t`对象理应也是被污染的。但当我们将`instance`作为`source`，`return t`作为`sink`是获取不到路径的，需要加上额外步骤。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221654-f359fb4c-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221654-f359fb4c-7b8d-1.png)

代码如下，将调用方法的所有参数作为`source`(图中`setSceneKey`方法的`workNode.getSceneKey()`参数)，将调用方法的对象作为`sink`(图中的`t`对象)

```
class SrcTaintStep extends TaintTracking::AdditionalTaintStep{
    override predicate step(DataFlow::Node src, DataFlow::Node sink){
        exists(MethodAccess ma |
            (ma.getMethod() instanceof SetterMethod or ma.getMethod().getName().matches("set%"))
            and
                src.asExpr() = ma.getAnArgument()
            and sink.asExpr() = ma.getQualifier()
            )
    }
}

```

可以猜猜上图中总共需要添加几个额外步骤（3 个，第一：刚刚讲的；第二：`instance`的 getter；第三：`workNodeMapper`）

### 实例化

场景 4：如下图，将`req`传入`UploadFile`中创建`UploadFile`对象，再将其传入`systemService.uploadFile`方法中，这种情况，`uploadFile`对象应该是受污染的，但是默认情况下，我们像让数据流进入`systemService.uploadFile`中是不行的，因为在`new UploadFile`就已经断开了。那么就需要将其连接起来  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221706-fa6682e8-7b8d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221706-fa6682e8-7b8d-1.png)

代码如下，如果已经知道当前查询大概断的位置，可以缩小范围，这里将所有的都会连接起来

```
class InstanceTaintStep extends TaintTracking::AdditionalTaintStep{
    override predicate step(DataFlow::Node src, DataFlow::Node sink){
      exists(ClassInstanceExpr cie | 
        // cie.getTypeName().toString() = "UploadFile"
         src.asExpr() = cie.getAnArgument()
          and sink.asExpr() = cie)
    }
}

```

之前有位师傅提及了实例化断开问题，当时回答存在误导，这里算是重新讲清。

Partial flow
------------

对于数据流中断时候如何去解决确定中断位置在哪，官方提供了 Partial flow 方式，也就是查询到中断前的部分流，对于某些场景是有帮助的。如果想了解的话可以阅读官方描述 [Debugging data-flow queries using partial flow¶](https://codeql.github.com/docs/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow/)

使用：  
先导入`PartialPathGraph`，这里需要注意不能和`PathGraph`共存，也就是使用`PartialPathGraph`则不能导入`import DataFlow::PathGraph`。

```
import DataFlow::PartialPathGraph

```

在`TaintTracking::Configuration`配置中添加一个谓词，表示探索深度

```
override int explorationLimit() { result = 5 }

```

查询如下，注：`hasPartialFlow`是和`PartialPathGraph`匹配，`hasFlowPath`和`PathGraph`匹配，导入的时候一定要注意，否则会导致查不出来内容。

```
from MyTaintTrackingConfiguration conf, DataFlow::PartialPathNode source, DataFlow::PartialPathNode sink
where conf.hasPartialFlow(source, sink, _)
select sink, source, sink, "Partial flow from unsanitized user data"

```

当整个调用链非常长的时候又不知道具体断掉的位置，然后使用 Partial flow 会导致查询结果内容非常多，更不好排查了。官方提供了 2 种解决方式  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122222131-988c69d8-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122222131-988c69d8-7b8e-1.png)

大概的意思也就是，比如：a-b-c-d-e-f-g，不知道哪个位置中断了，那么就先查 a-b-c-d，将 sink 从 g 修改为 a。或者说是将 source 的大范围修改为确定的单个 source 来减少输出方便排查。还有就是可以使用`sanitizer`来清洗掉其他数据。

官方规则 - path-injection
---------------------

### path-injection

用于检测文件相关，可以是文件上传、文件读取。主要判断逻辑是对与传入文件操作时文件名是否可控

打开 CEW-022，官方对于此漏洞的简要说明：[java-path-injection](https://codeql.github.com/codeql-query-help/java/java-path-injection/)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221731-0969eb90-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221731-0969eb90-7b8e-1.png)

`TaintedPathConfig`污点跟踪分析的配置如下  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221735-0b9a37e4-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221735-0b9a37e4-7b8e-1.png)

#### source

使用了`RemoteFlowSource`，其中定义了用户输入可控的常见源。

#### sink

`sink`定义中使用了陌生的谓词和类，先看看`PathCreation`

```
override predicate isSink(DataFlow::Node sink) {
    exists(Expr e | e = sink.asExpr() | e = any(PathCreation p).getAnInput() and not guarded(e))
}

```

跟进 **PathCreation.qll** 包，获取用于创建路径的输入，定义了常见用法。使用方式通过调用`getAnInput()`谓词获取方法内的所有参数，也就是将`sink`定义为传入的文件名。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221744-11232c66-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221744-11232c66-7b8e-1.png)

再跟进 **TaintedPathCommon.qll** 查看`guarded`谓词  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221749-143174ee-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221749-143174ee-7b8e-1.png)

了解下`ConditionBlock`，可以使用下面查询内容

```
from ConditionBlock cb select cb, cb.getCondition(),cb.getCondition().getAChildExpr()

```

`cb`获取的是整个块，如：方法开始`{}`整个内容、`if (tree.getId() != null)`、`if (tree.getId() == null)`  
`cb.getCondition()`表示获取此基本块最后一个节点条件，如：`comboTree.getId() != null`、`salary.equalsIgnoreCase("null")`  
`cb.getCondition().getAChildExpr()`表示获取子表达式，如：`tree.getId()`、`null`、`salary`、`"null"`

```
public void demo() {
    if (tree.getId() != null) {
        cq.eq("id", tree.getId());
    }
    if (tree.getId() == null) {
        cq.isNull("Depart");
    }
    cq.add();
    ......
    data.setFooter("salary:"+(salary.equalsIgnoreCase("null")?"0.0":salary)+",age,email:合计");
}


```

回到`guarded`谓词中，  
`exists(PathCreation p | e = p.getAnInput())`再次强调变量调用为文件名。  
`cb.getCondition().getAChildExpr*() = c`将块的子表达式和表达式`c`匹配  
`c = e.getVariable().getAnAccess()`文件名的所有调用和表达式`c`匹配  
`cb.controls(e.getBasicBlock(), true)`注释意为：如果传入的`e.getBasicBlock()`是由该条件控制的基本块，即条件为`true`的基本块，则保持成立。  
比如通过`controls`查询，结果如下图，只有当`dirName`的`if`判断语句为`true`才能将`dirName`传入`File`中。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221802-1bfed9fa-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221802-1bfed9fa-7b8e-1.png)

将传入`controls`谓词中的`true`修改为`false`，则能匹配到如下图所示。进行判断的是`!`后面内容，所以可以得到该项  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221816-242b890c-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221816-242b890c-7b8e-1.png)

`not inWeakCheck(c)`最后一个过滤条件  
`inWeakCheck`谓词中定义调用方法的方法名等于`startsWith`等，传入表达式等于调用方法的对象。  
`EqualityTest`表示使用`==`或者`!=`的表达式，`getAnOperand()`谓词获取左边和右边的操作表达式，判断其中一个为`null`。

```
private predicate inWeakCheck(Expr e) {
  // None of these are sufficient to guarantee that a string is safe.
  exists(MethodAccess m, Method def | m.getQualifier() = e and m.getMethod() = def |
    def.getName() = "startsWith" or
    def.getName() = "endsWith" or
    def.getName() = "isEmpty" or
    def.getName() = "equals"
  )
  or
  // Checking against `null` has no bearing on path traversal.
  exists(EqualityTest b | b.getAnOperand() = e | b.getAnOperand() instanceof NullLiteral)
}

```

总结：  
经过比对 sink 是否使用`guarded`谓词的结果如下，左边是没有使用`guarded`谓词  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221829-2bdce7e0-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221829-2bdce7e0-7b8e-1.png)

如下图，没有将文件名传入`startsWith`等方法，并且没有使用`==`或者`!=`对`null`进行判断，只有当文件名的判断条件为`true`才能将其传入`File`中，那这种情况则不能当作`sink`。其实官方使用`guarded`谓词加入判断的这种情况有点不太理解，暂时没有想到哪些场景这种情况是适用的。可能我个人使用的话会将该项注释掉。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221832-2db42dc6-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221832-2db42dc6-7b8e-1.png)

#### isSanitizer

如果数据类型是基本类型或者是其包装类则清洗掉

```
override predicate isSanitizer(DataFlow::Node node) {
    exists(Type t | t = node.getType() | t instanceof BoxedType or t instanceof PrimitiveType)
}

```

#### isSanitizerGuard

这里也是起到清洗作用，当调用方法为`contains`并且其参数值为`..`，对表达式`e`的判断为`false`则条件成立。

```
class ContainsDotDotSanitizer extends DataFlow::BarrierGuard {
    ContainsDotDotSanitizer() {
        this.(MethodAccess).getMethod().hasName("contains") and
        this.(MethodAccess).getAnArgument().(StringLiteral).getValue() = ".."
}

    override predicate checks(Expr e, boolean branch) {
        e = this.(MethodAccess).getQualifier() and branch = false
    }
}

override predicate isSanitizerGuard(DataFlow::BarrierGuard guard) {
    guard instanceof ContainsDotDotSanitizer
}

```

上面的内容以案例来看是容易理解些的，如下图，只有当`sourceFilename.contains("..")`的判断语句为`false`才能进入`File`中，那么这种情况则将其清洗掉。  
也就是代码中如果对文件名内容进行`..`检测则清洗掉，不展示该数据。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221842-33cbb3dc-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221842-33cbb3dc-7b8e-1.png)

以上就是 path-injection 内容的讲解，不考虑`guarded`谓词情况，其实挺容易理解的，将常见用户输入可控的位置作为`source`，将常见文件操作方法的参数即文件名作为`sink`，清洗掉那些类型是基本类型等、如果对文件名进行`..`检测则也清洗掉。

#### 应用到真实场景

当我们查询，可以看到这里查询到了一个上传的工具类中，source 是`multipartRequest.getFileMap()`方法。如果稍微往前根据可以看到这里`multipartRequest`对象应该就是 controller 中传入进来的`request`对象，那么这里需要重新找到具体是哪个 controller 调用到这里  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221852-3995841e-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221852-3995841e-7b8e-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221855-3b939ce2-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221855-3b939ce2-7b8e-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221901-3f3df054-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221901-3f3df054-7b8e-1.png)

重新将 config 编写如下，这里只将 source 查到`RequestMapping`，如果要考虑全可以有`GetMapping`等。但只修改为如下是还不能查到内容的。

```
class TaintedPathConfig extends TaintTracking::Configuration {
  TaintedPathConfig() { this = "TaintedPathConfig" }

  override predicate isSource(DataFlow::Node source) {

    exists( Method m, Parameter p| 
    m.getAnAnnotation().getType().hasQualifiedName("org.springframework.web.bind.annotation", "RequestMapping")
    and m.hasAnnotation()
    and m.getAParameter() = p
    and source.asParameter()=p
    and p.getType().hasName("HttpServletRequest")
    )
   }

  override predicate isSink(DataFlow::Node sink) {
    exists( Method m, Parameter p| m.hasName("uploadFile") and
    m.getDeclaringType().hasQualifiedName("org.xxxx.core.common.dao.impl", "xxxxx")
    and m.getAParameter() = p
    and sink.asParameter()=p
    and p.getType().hasName("UploadFile")
    )
  }
}

```

原因就是`UploadFile`实例时这里中断了  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20220122221912-456b279e-7b8e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220122221912-456b279e-7b8e-1.png)

将其连接起来后即可

```
class InstanceTaintStep extends TaintTracking::AdditionalTaintStep{
  override predicate step(DataFlow::Node src, DataFlow::Node sink){
      exists(ClassInstanceExpr ma | 
         sink.asExpr() = ma
        and src.asExpr() = ma.getAnArgument())
  }
}

```