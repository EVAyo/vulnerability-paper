<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/7482)

> 先知社区，先知安全技术社区

什么是 codeql
----------

codeql 是 github security lab 开发的一种代码查询语言，可以利用 codeql 方便的进行代码的污点追踪分析，通过像 SQL 查询语言一样的对代码的查询方式，可以让使用者不用去过于关心污点追踪的实现细节，具体的 codeql 的语法和使用方法可以在官网上查看

[https://securitylab.github.com/tools/codeql](https://securitylab.github.com/tools/codeql)

利用 codeql 挖掘 fastjson 利用链
-------------------------

首先要清楚，fastjson 的利用链主要集中在 getter 和 setter 方法中，如果 getter 或者 setter 的方法中存在一些危险操作，比如 JNDI 查询之类的调用的话，如果参数可控就可以导致 JNDI 注入，而且 fastjson 的防御方式为黑名单，所以会层出不穷 fastjson 的绕过 gadgets

鉴于 fastjson 的漏洞原理较为简单，且 source（用户输入的源头）和 sink（危险的函数）较为明确，所以可以使用 codeql 对一些常见的库进行 fastjson 利用链的挖掘

定义 fastjson 的入口点
----------------

fastjson 的 source 相对比较好定义，所有 fastjson 的入口函数都是 getter 和 setter 这些函数，所以对应的 source 就为这些 getter 和 setter，在 codeql 查询中，其实相当于将所有的函数按照用户所需要的过滤规则拿出来，所以我们只需要定义过滤的规则

对于 getter 和 setter 的规则，这里其实并不是一定要有对应的属性，只要前三个字母开头是 get，并且第四个字母大写即可

getter 的规则：

1.  以 get 开头
2.  没有函数参数
3.  是我们的 code database 中的函数
4.  为 public 方法
5.  函数名长度要大于 3

setter 的规则：

1.  以 set 开头
2.  函数参数为一个
3.  是我们 code database 中的函数
4.  为 public 方法
5.  函数名长度大于 3
6.  返回值为 void

所以我们可以通过这几个规则写出对应的 fastjson gadgets 入口点的 ql 描述为：

```
class FastJsonSetMethod extends Method{
    FastJsonSetMethod(){
        this.getName().indexOf("set") = 0 and
        this.getName().length() > 3 and
        this.isPublic() and
        this.fromSource() and
        exists(VoidType vt | 
            vt = this.getReturnType()
        ) and
        this.getNumberOfParameters() = 1
    }
}


class FastJsonGetMethod extends Method{
    FastJsonGetMethod(){
        this.getName().indexOf("get") = 0 and
        this.getName().length() > 3 and
        this.isPublic() and
        this.fromSource() and
        this.hasNoParameters()
    }
}


```

定义危险函数
------

这里危险函数不仅仅是 JNDI 注入的函数，也可以是 DNS 查询之类的函数

JNDI 函数规则：

1.  这个函数名为 lookup
2.  这个函数所在的类实现了 "javax.naming.Context" 接口

所以用 ql 语言描述为：

```
class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getASupertype*().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}


```

确定搜索方法
------

因为在 fastjson 中，有两个输入点，一个是 get 方法所在类的属性，一个是在 fastjson 触发的时候所传入的参数，为了方便起见，没有定义确定的 source，一般来说能满足 get 方法最后到 lookup 的类相对较少，所以可以在查询结束以后再人工进行一次确认

这里没有用 fastjson 的全局的污点追踪，而是直接通过语法结构查找对应的利用链

先放一下代码，然后解释一下为什么这么写：

```
MethodAccess seekSink(Method sourceMethod){
    exists(
        MethodAccess ma, Method method|
        (ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*() and
        method = ma.getMethod()) or
        (ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*() and ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().isAnonymous() and method = ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().getAMethod())|
        if method instanceof JNDIMethod
        then result = ma
        else result = seekSink(method)
    )
}


```

### 基础版

首先，我们需要获取到所有 getter 方法内部的方法调用，这里使用了`ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*()`做选择，如果这个方法调用围绕的结构正是我们 getter 方法内部的一个子结构的话，那么证明这个方法调用是在 getter 中的

我们先跳过 or 这里的定义，来看后面：

后面对内部调用进行判断，看它是否是一个 JNDI 查询的方法，如果不是的话，因为还有内部调用，所以继续递归查询内部调用的内部调用，这样就可以获取到更深调用的 JNDI 查询

### 进阶版

也就是 or 后面的这一段，在 fastjson 1.2.66 中有这么一个 gadgets：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200326183824-ebd80538-6f4d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200326183824-ebd80538-6f4d-1.png)

入口点为：org.apache.shiro.jndi.JndiObjectFactory

用上面的 ql 是查不出来的，因为这里的 lookup 是在一个匿名类里面，并且是在函数参数中定义的，所以增加一个新的 sink 点

`ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*() and ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().isAnonymous() and method = ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().getAMethod())`，和前面一样，函数必须是内部调用的函数，并且函数的第一个参数为一个匿名类，之后获取到匿名类中的方法，即可获取到这种特殊的 sink 点

执行结果
----

shiro 挖掘结果：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200326183848-f9f565ca-6f4d-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200326183848-f9f565ca-6f4d-1.png)

common-configuration 挖掘结果：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200326183921-0d643546-6f4e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200326183921-0d643546-6f4e-1.png)

改进点
---

现在的这个 ql 还是有很多问题的，还需要继续去完善

1.  这种函数参数的匿名类，可能不在第一个索引，需要对所有的参数做判断
2.  对应的 sink 可以继续去拓展，可能有其他的调用方式没有加入（例如 lambda 表达式）
3.  危险方法不一定是 JNDI 查询，也可以是其他的方法
4.  没有使用到污点追踪，所以需要一点人工成本

PS：shiro 在编译的时候会报错，用`mvn compile -fn`可以忽略编译错误，成功构建 database

```
fastjson.qll

import java
import semmle.code.java.dataflow.DataFlow

class FastJsonSetMethod extends Method{
    FastJsonSetMethod(){
        this.getName().indexOf("set") = 0 and
        this.getName().length() > 3 and
        this.isPublic() and
        this.fromSource() and
        exists(VoidType vt | 
            vt = this.getReturnType()
        ) and
        this.getNumberOfParameters() = 1
    }
}


class FastJsonGetMethod extends Method{
    FastJsonGetMethod(){
        this.getName().indexOf("get") = 0 and
        this.getName().length() > 3 and
        this.isPublic() and
        this.fromSource() and
        this.hasNoParameters()
    }
}

class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getASupertype*().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}

predicate isClassField(RefType classType, string fieldName){
    classType.getAField().hasName(fieldName)
}

MethodAccess seekSink(Method sourceMethod){
    exists(
        MethodAccess ma, Method method|
        (ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*() and
        method = ma.getMethod()) or
        (ma.getEnclosingStmt() = sourceMethod.getBody().getAChild*() and ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().isAnonymous() and method = ma.getArgument(0).(ClassInstanceExpr).getAnonymousClass().getAMethod())|
        if method instanceof JNDIMethod
        then result = ma
        else result = seekSink(method)
    )
}

fastjson.ql
import java
import semmle.code.java.dataflow.DataFlow
import fastjson


from FastJsonGetMethod getMethod
select getMethod, seekSink(getMethod)


```