<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/LQ9O9Hqo3Qey8vasOpQ1oQ)

内存马
---

通过利用程序漏洞将恶意代码加载到目标系统的内存中，而不是将其写入磁盘，这种技术对于绕过一些安全防御机制非常有用，因为它可以在系统不会被监测到恶意文件的情况下执行代码

内存马的由来
------

随着攻防的下沉，对抗技术的更迭，所以产生了内存马，就比如说我们的战机和雷达，有一代二代战机，也会有一代二代雷达，当一代雷达能发现一代战机的时候，就必须得研制二代战机来规避一代雷达的发现，同理，我们的 webshell 就是战机，检出设备或软件就是雷达，当黑客发现落地式的 webshell 太明显了，所以研究出了不落地的，以内存形式存在的 webshell，也就是内存马。

内存马的本质
------

以内存方式存在的 web 组件，其携带了恶意功能，并能完成攻击者的意图

### web 容器

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2riawHamHsrPs7rwSHtlHcmNt84o253e8D2FfvU7guuafpHfAXLR2icdOA/640?wx_fmt=png&from=appmsg)

我们这里所说的 web 容器是指存放 web 服务的地方，只是一个方便理解的概念

*   web 容器是接收客户端请求，处理请求的程序
    
*   web 容器根据语言、设计方式的不同，存在多种形式的容器
    

*   Java 容器：tomcat、websphere、weblogic、resin 等
    
*   PHP 容器：apache、nginx+php
    

*   web 容器的不同导致内存马的多样性
    

*   语言不同导致，如 Java、PHP、Python 内存马
    
*   实现方式不同导致，如 websphere 和 tomcat 内存马
    

### tomcat web 组件

在 Tomcat 中，正常的请求会经过 tomcat 的三大组件，从客户端发送请求，然后到 lintener 监听器，再到 Filter 过滤器，最后达到 Servlet（请求的就是 IO 流，从磁盘上读取一个 html 文件或其他的文件），之后再将页面或者数据通过 filter 和 lintener 返回给浏览器

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rQbcgrmIq876CVpsjA2pb5AOemYy9j7HvCb6exuWfKLN1GHkldeAXFA/640?wx_fmt=png&from=appmsg)

#### Listener 监听器

通过 listener 可以监听 web 服务器中某一个执行动作，并根据其要求作出相应的响应。作用：监听事件的变化，通过回调函数，去做一些相应的处理监听器：ServletRequestListener（每次请求的开始与结束）、HttpSessionListener（session 创建与销毁）、ServletContextListener（服务器开启与关闭）当注册了该监听器，有相应事件发生时，会触发我们的监听器

#### Filter 过滤器

Filter 是一个可以复用的代码片段，可以用来转换 HTTP 请求、响应和头信息。Filter 无法产生一个请求或者响应，它只能针对某一资源的请求或者响应进行修改。作用：对客户端发出的请求进行过滤，起到拦截的作用可以用来做权限校验，XSS 过滤，安全检查等等

#### Servlet 组件

Servlet 是一种运行服务器端的 java 应用程序，具有独立于平台和协议的特性，并且可以动态的生成 web 页面，它工作在客户端请求与服务器响应的中间层。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。作用：处理我们客户端的请求，向客户端响应

#### web 容器与内存马的关系

*   内存马基于容器组件实现
    
*   在容器调用链中，向其新增恶意组件
    
*   容器组件被修改后携带恶意功能
    

### 内存马种类划分

#### 划分内存马种类的意义

*   做检出主要就是找出特征点
    
*   分类能够方便我们按种类提取特征
    
*   通过分类的方式帮助梳理攻击面
    

#### 基于语言接口划分

*   数据结构型：如 Servlet、Filter、Listener、Controller
    
*   API 接口型：如 Java Agent 和 Java Ssist 技术的内存马
    
*   两者区别在于一种是语言独有，而数据结构则是语言通用特征
    

##### Java agent

*   ava Agent 是一个运行在 Java 虚拟机（JVM）上的特殊类型的程序，它可以在应用程序加载到 JVM 之前或之后，通过 Instrumentation API 来修改应用程序的字节码。
    
*   Java Agent 通常用于监视、调试或者在运行时增强 Java 应用程序的功能。它可以用来收集性能指标、修改类的行为、实现热部署等。
    
*   提供在虚拟机层次上实现一些类的修改和重加载
    
*   启动时 premain，运行时 agentmain
    
*   内存马主要是使用 agentmain，运行时完成类的修改
    

##### Java ssist

*   Javaassist 是一个开源的 Java 字节码操作库，它提供了一组 API 用于在运行时操作 Java 字节码。
    
*   Javaassist 可以用于创建、修改、检查和操作 Java 类的字节码。它提供了一种简单而强大的方式来动态生成类、修改类的方法或字段等。
    
*   使用 java 编码不需了解虚拟机指令，就能动态改变或生成类
    

#### 数据结构型内存马分析

##### Servlet

*   实现 Servlet 接口
    
*   实现 Service 方法
    
*   在 Service 方法中执行命令功能
    
*   实例化 MalwareServlet，恶意类
    
*   添加到 standardContext 中，通过 Wrapper 包装器放到 standardContext
    
*   使用 standardContext 添加 URL 映射
    

#### API 型内存马分析

*   可以明显看到它会修改 HttpServlet 类的结构
    
*   通过 inst.redefineClasses() 来将我们修改的类替换掉原来的类，
    
*   inst.redefineClasses 属于 Java Instrumentation API 的一部分，用于在运行时重新定义类。该方法允许程序在运行时修改类的字节码定义，而无需重新加载类文件
    

检出设计
----

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rQnnWHUk0dTQQ3iaT4ibgVFhqibBWIbvrurNcibqWxOftJ8FCQf1O6LibY5Q/640?wx_fmt=png&from=appmsg)

### 攻击路径提取

怎么样打进来的，例如 webshell 打入还是 rce 漏洞打入？

### 攻击面提取

有多少种内存马，内存马划分为基于数据结构型和基于语言 API 型，最终还会在内存

### 设计拦截点

在哪里进行拦截，在攻击路径中，最后都会在内存中驻留

### 特征提取

归纳内存马的特征是什么，通过什么特征检出，特征通过什么方法获取通过类对象函数特征，类继承 Servlet

### API 支持度

我们使用的 API 是否能够支持我们完成特征的提取

*   所有加载的类对象可以通过 Instrumentation 获取
    
*   类继承的接口与父类特征可以通过 Class 对象获取
    
*   类函数种存在的特征可以通过字节码 + 反编译获取
    

### 方案产出

反复矫正后产出我们的方案

### 公开方案

和公开方案对比，还有哪些地方可以优化

### 方案需要考虑的几个因素

*   攻击路径
    
*   攻击面
    
*   误报率
    
*   性能
    

检出实践
----

![](https://mmbiz.qpic.cn/mmbiz_png/5qTjIDK0cVKsLhovpDxsexaGvEry1d2rJYj5Icmp8SQS3ghTNUBAACNzG35hGOA9NkMOiaMEKJGHahY6FygAOqw/640?wx_fmt=png&from=appmsg)

### 注入模块

*   注入模块主要负责将我们的检出模块加载到目标 JVM 进程
    
*   释放检出模块 agent.jar
    
*   注入 agent.jar 到目标进程
    
*   首先通过 java -jar injector.jar 启动注入模块
    
*   之后会释放出检出模块 agent.jar
    
*   使用 virtualMachine.loadAgent() 加载我们释放的 jar
    

### 检出模块

*   检出模块主要是将提取出的特征进行匹配，DUMP 可疑类
    
*   获取内存中加载的类，进行特征匹配
    
*   将匹配的字节码进行 DUMP，保存在磁盘