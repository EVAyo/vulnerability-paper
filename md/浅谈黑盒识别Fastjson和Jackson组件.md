<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dTn32ZZwNwEfKKk74arhCQ)

朋友们现在只对常读和星标的公众号才展示大图推送，建议大家把 “**亿人**安全**** “**设为星标**”，否则可能就看不到了啦

**原文由作者授权，首发在奇安信攻防社区  
**

https://forum.butian.net/share/1679

Java 生态中基本只有 Jackson 和 Fastjson 组件，但是两者相关的版本均存在相应的漏洞（反序列化、DDOS），所以对目标是否使用了对应的组件需要有相关的判断方法。方便信息收集进行进一步的测试。

Java 生态中基本只有 Jackson 和 Fastjson 组件，但是两者相关的版本均存在相应的漏洞（反序列化、DDOS），那么如何有效识别目标使用了哪种对应的组件就很有必要了。

理想状态下如果站点有原始报错回显，可以用不闭合花括号的方式进行报错回显，报错中往往中会有 Fastjson/Jackson 的关键字：

Jackson：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIpDiaGptuLbLkCL4vtozQibOibZwZBDpuyKYc5LJeYgIZTiazG3ATK62cUA/640?wx_fmt=png&from=appmsg)

Fastjson：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIaRrfseCY0k3q0DyKKEzEAAAibiaqYKqibJ9LyS8af74Mcd0icrcHxnCIbA/640?wx_fmt=png&from=appmsg)

但是实际上并不可能那么的理想，所以需要一些其他的 trick 来进行区分。下面探讨下两个解析器之间有什么区别。

0x01 Fastjson&Jackson 中的 Feature
================================

FastJson 和 Jackson 在序列化和反序列化的过程中提供了很多特性（Feature），例如 Fastjson 的 Feature.DisableFieldSmartMatch（1.2.30 引入）。如果没有选择该 Feature, 那么在反序列的过程中，FastJson 会自动把下划线命名的 Json 字符串转化到驼峰式命名的 Java 对象字段中。

简单看下两个解析器是如何加载 Feature 的。

1.1 Fastjson
------------

以 1.2.24 版本为例，查看常用的解析方法，在对 json 文本进行解析时，一般会使用 JSON.parse(text)，默认配置如下：

```
public static Object parse(String text) {
    return parse(text, DEFAULT_PARSER_FEATURE);
}


```

DEFAULT_PARSER_FEATURE 是一个缺省默认的 feature 配置:

```
public static int DEFAULT_PARSER_FEATURE;
static {
    int features = 0;
    features |= Feature.AutoCloseSource.getMask();
    features |= Feature.InternFieldNames.getMask();
    features |= Feature.UseBigDecimal.getMask();
    features |= Feature.AllowUnQuotedFieldNames.getMask();
    features |= Feature.AllowSingleQuotes.getMask();
    features |= Feature.AllowArbitraryCommas.getMask();
    features |= Feature.SortFeidFastMatch.getMask();
    features |= Feature.IgnoreNotMatch.getMask();
    DEFAULT_PARSER_FEATURE = features;
}


```

可以通过 Feature 类的 isEnabled 方法来判断相关的 Feature 是否开启：

```
package com.alibaba.fastjson.parser;

public enum Feature
{
  AutoCloseSource,  AllowComment,  AllowUnQuotedFieldNames,  AllowSingleQuotes,  InternFieldNames,  AllowISO8601DateFormat,  AllowArbitraryCommas,  UseBigDecimal,  IgnoreNotMatch,  SortFeidFastMatch,  DisableASM,  DisableCircularReferenceDetect,  InitStringFieldAsEmpty,  SupportArrayToBean,  OrderedField,  DisableSpecialKeyDetect,  UseObjectArray,  SupportNonPublicField;

  public final int mask;

  private Feature()
  {
    this.mask = (1 << ordinal());
  }

  public final int getMask()
  {
    return this.mask;
  }

  public static boolean isEnabled(int features, Feature feature)
  {
    return (features & feature.mask) != 0;
  }
  ......
}


```

1.2 Jackson
-----------

Jackson 主要是在 com.fasterxml.jackson.core.JsonFactory 对 Feature 进行管理。在类加载时会先把相关 Feature 的默认值进行采集：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIJWEHOyiaWUqmg80RmALP9qcPGRic5DfqLL2SEHibJqbENddAvzNbssibHw/640?wx_fmt=png&from=appmsg)

每个 Feature 都会有自己的默认值，例如下图中的 USE_BIG_DECIMAL_FOR_FLOATS 主要是将浮点数反序列化为 BIG_DECIMAL，默认是 False：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIZDuLhibxbiaZ1jeMTrCicSwmlFoayVqZ1cBMQtgENemq2pn4St9HZlnPw/640?wx_fmt=png&from=appmsg)

同样的，springboot 在 org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration 进行装配时，如果没有其他配置，会把这些默认的 Feature 配置进行装载：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaI3gmREHoM6Pdicg2Vtsl7EicrcAAOlmYzCCGMK8hnXFtz0MalAUu2pjicg/640?wx_fmt=png&from=appmsg)

既然两者都在在序列化和反序列化的过程中提供了很多特性（Feature），而两者之间的 Feature 肯定是有区别的，可以利用这一点看看能不能找到一些思路用户两者的区分。

0x02 黑盒区分 Fastjson 和 Jackson
============================

2.1 通过默认 Feature 配置区分
---------------------

根据前面的思路，可以根据两者默认的 Feature 配置或者设计上的区别来进行区分。下面列举一些可用的 trick。

### 2.1.1 Jackson 的 JsonParser.Feature(2.10 后替换为 JsonReadFeature)

JsonReadFeature 的配置也是一样的：

```
public enum JsonReadFeature implements FormatFeature {
  ALLOW_JAVA_COMMENTS(false, JsonParser.Feature.ALLOW_COMMENTS),
  ALLOW_YAML_COMMENTS(false, JsonParser.Feature.ALLOW_YAML_COMMENTS),
  ALLOW_SINGLE_QUOTES(false, JsonParser.Feature.ALLOW_SINGLE_QUOTES),
  ALLOW_UNQUOTED_FIELD_NAMES(false, JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES),
  ALLOW_UNESCAPED_CONTROL_CHARS(false, JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS),
  ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false, JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER),
  ALLOW_LEADING_ZEROS_FOR_NUMBERS(false, JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS),
  ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS(false, JsonParser.Feature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS),
  ALLOW_NON_NUMERIC_NUMBERS(false, JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS),
  ALLOW_MISSING_VALUES(false, JsonParser.Feature.ALLOW_MISSING_VALUES),
  ALLOW_TRAILING_COMMA(false, JsonParser.Feature.ALLOW_TRAILING_COMMA);
  ......
  }


```

这里以 JsonParser.Feature 为例进行举例:

*   解析 value 遇到以 "0" 为开头的数字
    

Jackson 的 objectMapper 默认情况下是不能解析以 "0" 为开头的数字的，但是 fastjson 是可以的：

```
/**
Feature that determines whether parser will allow JSON integral numbers to start with additional (ignorable) zeroes (like: 000001). If enabled, no exception is thrown, and extra nulls are silently ignored (and not included in textual representation exposed via getText).
Since JSON specification does not allow leading zeroes, this is a non-standard feature, and as such disabled by default.
**/
ALLOW_NUMERIC_LEADING_ZEROS(false),


```

Fastjson 会把 01 解析成 1:

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIt2Y13U2Zic6WUupTTQgFf9GJicfYl3GT8QkvxLUBWysyq3UQGnzqJicuA/640?wx_fmt=png&from=appmsg)

Jackson 在解析 01 时会抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIMWUGQap1pDSicMJckdS8cCS4icc4IlkibdLC6eDvkQjoKMvO9d1xlicGqw/640?wx_fmt=png&from=appmsg)

*   解析 value 为 NaN  
    Jackson 的 ObjectMapper 解析器默认不能识别 "Not-a-Number" (NaN)，不会认为其为浮点类型或者 int 类型的数字：
    

```
/**
Feature that allows parser to recognize set of "Not-a-Number" (NaN) tokens as legal floating number values (similar to how many other data formats and programming language source code allows it). Specific subset contains values that XML Schema  (see section 3.2.4.1, Lexical Representation) allows (tokens are quoted contents, not including quotes):
"INF" (for positive infinity), as well as alias of "Infinity"
"-INF" (for negative infinity), alias "-Infinity"
"NaN" (for other not-a-numbers, like result of division by zero)
Since JSON specification does not allow use of such values, this is a non-standard feature, and as such disabled by default.
**/
ALLOW_NON_NUMERIC_NUMBERS(false)


```

Fastjson 1.2.70 会把 NaN 解析成 0:

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIRjicVVWZUk1crO9xcQkduu7GPTjJEPibCQBWJDDmzOzseOSXiaN6cERRA/640?wx_fmt=png&from=appmsg)

Fastjson 1.2.37 会抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIH6WTQSzKhxDica9qja97FmZ3b8OHdX3shRqnJNCfK4rWNcwIlScWofA/640?wx_fmt=png&from=appmsg)

Jackson 会抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIeqbjSZRofT9hWrkgiaZh8DCVDNvZxvtJhmBBIKmdAYX6zcpJ98bZ0ZQ/640?wx_fmt=png&from=appmsg)

*   注释符
    

当 json 字符串里存在注释符时，默认情况下 Jackson 的 ObjectMapper 解析器不能解析（Fastjson 的 AllowComment 默认是开启的，所以支持注释符的解析）：

```
/**
 * Feature that determines whether parser will allow use
 * of Java/C++ style comments (both '/'+'*' and
 * '//' varieties) within parsed content or not.
 *<p>
 * Since JSON specification does not mention comments as legal
 * construct,
 * this is a non-standard feature; however, in the wild
 * this is extensively used. As such, feature is
 * <b>disabled by default</b> for parsers and must be
 * explicitly enabled.
 */
ALLOW_COMMENTS(false)


```

Fastjson 支持注释符：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIk36vXAg1v79wmtXyINa0t4WARbEOR1rVpmskFUHicad5JnIGic3WogbQ/640?wx_fmt=png&from=appmsg)

Jackson 默认情况下会报错：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIVNoMjkvctMwuhfPXlAB4DwIVCfQQJW44JJoaUM2s2ctsU1MvJiaHGxw/640?wx_fmt=png&from=appmsg)

*   json 字段使用单引号包裹
    

Fastjson 的 Feature.AllowSingleQuote 是默认开启的，支持使用单引号包裹字段名，但是 jackson 受到 JsonParser.Feature.ALLOW_SINGLE_QUOTES 的影响，默认是不支持的：

```
/**
Feature that determines whether parser will allow use of single quotes (apostrophe, character '\'') for quoting Strings (names and String values). If so, this is in addition to other acceptable markers. but not by JSON specification).
Since JSON specification requires use of double quotes for field names, this is a non-standard feature, and as such disabled by default.
**/
ALLOW_SINGLE_QUOTES(false)


```

Fastjson 正常解析：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIagYdMiaOy2QJcicfZmBUA3WQTD78TBu4ZlOz5a4k1QtVkGEw6bPm7DPg/640?wx_fmt=png&from=appmsg)

Jackson 解析抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaI7DzicDFuxNJARvI2R9cAtBtibOOv2URYRmc3nCooT7TyQU4MQvuOoo3Q/640?wx_fmt=png&from=appmsg)

*   json 属性没有使用双引号包裹
    

fastjson 的 AllowUnQuotedFieldNames 默认开启，允许 json 字段名不被引号包裹，但是 jackson 的 ALLOW_UNQUOTED_FIELD_NAMES 默认不开启，无法解析：

```
/**
 * Feature that determines whether parser will allow use
 * of unquoted field names (which is allowed by Javascript,
 * but not by JSON specification).
 *<p>
 * Since JSON specification requires use of double quotes for
 * field names,
 * this is a non-standard feature, and as such disabled by default.
 */
ALLOW_UNQUOTED_FIELD_NAMES(false)


```

*   解析 JSON 数组中 “缺失” 的值
    

如果数组中两个逗号之间缺失了值，形如这样`[value1, , value3]`。对于 fastjson 来说可以解析，jackson 受到`ALLOW_MISSING_VALUES`的影响会抛出异常：

```
/**
Feature allows the support for "missing" values in a JSON array: missing value meaning sequence of two commas, without value in-between but only optional white space. Enabling this feature will expose "missing" values as JsonToken.VALUE_NULL tokens, which typically become Java nulls in arrays and java.util.Collection in data-binding.
For example, enabling this feature will represent a JSON array ["value1",,"value3",] as ["value1", null, "value3", null]
Since the JSON specification does not allow missing values this is a non-compliant JSON feature and is disabled by default.
**/
ALLOW_MISSING_VALUES(false)


```

Fastjson 正常解析，会把缺失的值忽略掉：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIqlNoNFE2NPTWhokZZfmb40q02FTXdZxMMr0PBgAgZol6GEK3Y5OxgA/640?wx_fmt=png&from=appmsg)

Jackson 会抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIzNGWibheo43MMBzeyQU1JOguxLIGBzCtPbZ1IldquqaKjb3oIRfSictQ/640?wx_fmt=png&from=appmsg)

### 2.1.2 Jackson 的 MapperFeature

*   大小写敏感
    

假设 Bean 的结构如下：

```
public class User {
    private int id;
    private String userName;
    private String sex;
    private String[] nickNames;

    //对应的getter和setter方法
}


```

在代码里里属性 id 是小写的，在 fastjson 和 jackson 解析时会有区别。

FastJson 在反序列化的时候，是对大小写不敏感的:

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIsoeEGnUF1lunerADlyGDbjec8zIADJUQA0zxvNgUrOLe7iaFA08SesQ/640?wx_fmt=png&from=appmsg)

在 Jackson 中，`MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`默认设置为 FALSE，在反序列化时是大小写敏感的，可以看到下面的例子中 Id 因为大小写敏感的问题并未赋值：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaISomLX1taUmiaSdHpos439Ah8zvfDlUbx0D07haxXAiaHPMhiaSkNmbcoA/640?wx_fmt=png&from=appmsg)

### 2.1.3 Fastjson 的 Feature

*   忽略 json 中包含的连续的多个逗号
    

Fastjson 中 Feature.AllowArbitraryCommas 是默认开启的，允许在 json 字符串中写入多个连续的逗号。

Fastjson 正常解析：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIEYiaVCyJ5SDsNM0F85vWsVp1XyBib8gqU1f228ND9wKcibfEdEKzPXEnQ/640?wx_fmt=png&from=appmsg)

Jackson 会抛出异常，类似的的 Feature 是 ALLOW_TRAILING_COMMA（是否允许 json 尾部有逗号，默认是 False)：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIKnyxajwV8dWgJRD8BroNzJLCcSiaeU4cNK0TwUSibREmJ7RrMMHwybtQ/640?wx_fmt=png&from=appmsg)

2.2 结合 fastjson 智能匹配区分
----------------------

除了通过默认 Feature 的差异以外，FastJSON 存在智能匹配的特性，即使 JavaBean 中的字段和 JSON 中的 key 并不完全匹配，在一定程度上还是可以正常解析的。通过这些特性也可以简单的进行区分。

*   字段名包含`-`和`_`
    

主要是在 JavaBeanDeserializer.smartMatch 方法进行实现。通过这一特点可以在一定程度上做区分。

在 1.2.36 版本及后续版本，部分具体代码如下，具体处理方法在 TypeUtils.fnv1a_64_lower：

```
public FieldDeserializer smartMatch(String key, int[] setFlags)
  {
    if (key == null) {
      return null;
    }
    FieldDeserializer fieldDeserializer = getFieldDeserializer(key, setFlags);
    if (fieldDeserializer == null)
    {
      long smartKeyHash = TypeUtils.fnv1a_64_lower(key);
      if (this.smartMatchHashArray == null)
      {
        long[] hashArray = new long[this.sortedFieldDeserializers.length];
        for (int i = 0; i < this.sortedFieldDeserializers.length; i++) {
          hashArray[i] = TypeUtils.fnv1a_64_lower(this.sortedFieldDeserializers[i].fieldInfo.name);
        }
        Arrays.sort(hashArray);
        this.smartMatchHashArray = hashArray;
      }


```

查看 TypeUtils.fnv1a_64_lower 的具体实现, 这里忽略字母大小写和 - 和_：

```
 public static long fnv1a_64_lower(String key)
  {
    long hashCode = -3750763034362895579L;
    for (int i = 0; i < key.length(); i++)
    {
      char ch = key.charAt(i);
      if ((ch != '_') && (ch != '-'))
      {
        if ((ch >= 'A') && (ch <= 'Z')) {
          ch = (char)(ch + ' ');
        }
        hashCode ^= ch;
        hashCode *= 1099511628211L;
      }
    }
    return hashCode;
  }


```

也就是说 fastjson1.2.36 版本及后续版本支持同时使用_和 - 对字段名进行处理：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIFQoa3R5CWPfXSEEc4vbkvMlfZFNwhCpDcrCOttCWgWlaGYzeG3Kt6Q/640?wx_fmt=png&from=appmsg)

但是 jackson 默认是没有这一特性的，例如下面的例子，并没有识别到经过`-`和`_`处理后的 userName：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIpawUqbYliaeX8tX3sLdsPaN3mpKYW96PsWe04ZMkpkwRiaGicjqvshYdA/640?wx_fmt=png&from=appmsg)

*   使用 is 开头的 key 字段
    

Fastjson 在做智能匹配时，如果 key 以 is 开头, 则忽略 is 开头, 相关代码如下:

```
int pos = Arrays.binarySearch(this.smartMatchHashArray, smartKeyHash);
if ((pos < 0) && (key.startsWith("is")))
{
    smartKeyHash = TypeUtils.fnv1a_64_lower(key.substring(2));
    pos = Arrays.binarySearch(this.smartMatchHashArray, smartKeyHash);
}


```

同样的 Jackson 是不具备该特点的。

0x03 一些疑惑?
==========

根据上面的思路可以发掘出很多别的思路，但是实际在环境测试时却与之前的想法有差异，这里对遇到的其中一个点进行分析。

3.1 关于 Jackson 的属性对齐特性
----------------------

很容易发现 Jackson 反序列化多余的属性会抛出异常，其实是受到`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`的影响 (默认设置为 true):

```
/**
Feature that determines whether encountering of unknown properties (ones that do not map to a property, and there is no "any setter" or handler that can handle it) should result in a failure (by throwing a JsonMappingException) or not. This setting only takes effect after all other handling methods for unknown properties have been tried, and property remains unhandled.
Feature is enabled by default (meaning that a JsonMappingException will be thrown if an unknown property is encountered).
**/
FAIL_ON_UNKNOWN_PROPERTIES(true)


```

所以相比 fastjson，jackson 会比较严格，因为强制 key 与 javabean 属性对齐，只能少不能多 key，所以在解析时会报错。服务器的响应包中多少会异常回显（或者是通用报错页面）。看一个具体的例子：

例如 JavaBean 中有如下属性：

```
public class User {
    private int id;
    private String userName;
    private String sex;

    //对应属性的getter和setter方法
}


```

使用 ObjectMapper 对对应的 Json 字符串进行解析，因为没有 passwd 属性，在解析时会抛出异常：

```
public static void main(String[] args) throws IOException {
    String jsonStr="{\"id\":1,\"sex\":\"male\",\"userName\":\"admin\",\"passwd\":\"123456\"}";
    ObjectMapper mapper = new ObjectMapper();
    User user = mapper.readValue(jsonStr,User.class);
    System.out.println(user);
}


```

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIhicdQGArD9F13h3ice2uMiajIrMvMhNUTDtU45nmBwpRicnejz5Q9zJIEQ/640?wx_fmt=png&from=appmsg)

根据上面的猜想，理论上应该是可以通过这个属性对齐特性来简单区分使用的是 Jackson 还是 fastjson 解析器的。

进一步在 springboot 环境下进行测试（Springboot 默认使用的是 Jackson）：

同样是刚刚的 JavaBean，可以看到增加了新的无关属性 passwd 后，并未抛出异常：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIBs3WdXBGl1zIT91FUjqorE6suzcbfnngv2aymgDjns5BybiaRk54zNg/640?wx_fmt=png&from=appmsg)

这是为什么呢？

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIYe04y80ibrCTcTDnDcDSsT98NAv1fMZIDZKdWRDBsam63bia6MVVnZnQ/640?wx_fmt=png&from=appmsg)

其实在 Spring/Spring Boot 环境下，`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`默认是关闭的。这里简单说下原因：

以 springboot 为例，如果在编码时没提供自定义的配置，会遵循 springboot 的默认配置，主要是在`org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration`类进行配置，这里通过`Jackson2ObjectMapperBuilder`来创建 ObjectMapper：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIyaf11UKeYoGZta239iaJXJZjA9N2zpIF303nEvH5o4PnD6bYS4Wawtg/640?wx_fmt=png&from=appmsg)

如果没有额外的配置的话，会使用默认的 Jackson2ObjectMapperBuilder，查看具体 build() 的实现：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaITnfS4LcUoUSZVgd6IGMK2gmvfODVyUA3UEP7sGibvk4YNOx2XibwGrFQ/640?wx_fmt=png&from=appmsg)

在 configure 方法里进行了相关的配置，这里通过调用 customizeDefaultFeatures() 配置了一些 feature：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIfQ1oAAl1dd0ymWsPtREGb1MMuYIibKfR5ncz0vQQibvRgpt1eOFVyucA/640?wx_fmt=png&from=appmsg)

继续查看 customizeDefaultFeatures 方法的具体实现，可以看到这里将`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`设置成了 false，Jackson 的属性对齐特性不生效了，也就应证了前面增加了新的无关属性后，依旧正常解析的现象了：

![](https://mmbiz.qpic.cn/mmbiz_png/iar31WKQlTTroz829iaQjFbLoDTEzmnbiaIlmBt6bicUpoS7x93UNY1KAGgpvItL4GCAfPq3zoOX3nlOlGnVuFw1ZQ/640?wx_fmt=png&from=appmsg)

所以想要在 Spring/Sping Boot 环境下区分使用的是哪个解析器，需要另辟蹊径。

0x04 其他
=======

除此以外，虽然说大多数都是使用的 Jackson/Fastjson，但是不排除还有使用 gson 等其他解析库的。一些 Feature 同样的会有影响，例如标准 JSON 里面是不能包含换行符的（必须以 \ n 表示），但是 Fastjson 和 gson 都是支持的，这里也会引入一些干扰项。总的来说，通过上述的一些技巧在一定程度上还是能进行区分的。