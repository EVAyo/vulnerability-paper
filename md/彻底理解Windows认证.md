> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.secpulse.com](https://www.secpulse.com/archives/94848.html)

> 在内部分享的《彻底理解 Windows 认证》议题解读，本次议题围绕着 Windows 认证分别讲解了：

在内部分享的《彻底理解 Windows 认证》议题解读，本次议题围绕着 Windows 认证分别讲解了：

*   Pass The Hash
    
*   Silver Tickets、Golden Tickets、
    
*   Impersonation Token
    

这些技术分别能够满足我们在渗透中持续的维持权限、提权。

作者：倾旋

[https://youtu.be/-FgWkU5awQE](https://youtu.be/-FgWkU5awQE "下列链接")

**0x00 本地认证**

*   本地认证基础知识
    
*   NTLM Hash 与 NTLM
    
*   NTLM Hash 的产生
    
*   本地认证流程
    
*   LM Hash
    

**0x01 网络认证**

*   NTLM 协议
    
*   Chalenge/Response
    
*   NTLM V2 协议
    
*   Pass The Hash
    

**0x02 Kerberos 域认证**

*   Active Directory(活动目录) 概念
    
*   Active Directory(活动目录) 功能
    
*   域认证体系 - Kerbroes
    
*   域认证所参与的角色 (三只狗头)
    
*   域认证粗略流程
    
*   域认证
    
*   白银票据 (Silver Tickets)
    
*   伪造白银票据 (Silver Tickets)
    
*   白银票据 (Silver Tickets) 演示
    
*   白银票据 (Silver Tickets) 防御
    
*   黄金票据 (Golden Tickets)
    
*   黄金票据 (Golden Tickets)-MSF kiwi
    
*   黄金票据 (Golden Tickets) - 伪造
    
*   黄金票据 (Golden Tickets) - 演示
    
*   Tickets 总结
    

**0x03 Windows Access Token**

*   Windows Access Token 简介
    
*   Windows Access Token 组成
    
*   Windows Access Token – SID (Security Identifiers) 安全标识符
    
*   Windows Access Token 产生过程
    
*   Windows Access Token 令牌假冒实战
    
*   Windows Access Token 令牌假冒实战
    
*   Windows Access Token 令牌假冒防御
    

**0x04 知识点总结**

**0x05 议题资料分享**

0x00 本地认证
---------

### 本地认证基础知识

在本地登录 Windows 的情况下，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证，但是操作系统中的密码存储在哪里呢？

%SystemRoot%\system32\config\sam

当我们登录系统的时候, 系统会自动地读取 SAM 文件中的 “密码” 与我们输入的 “密码” 进行比对，如果相同，证明认证成功!

这个 SAM 文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。

上面认证的过程只是粗略的说法，整个认证过程并没有那么简单，从操作系统的角度来看，还是需要铺垫很多概念的。

Windows 本身不保存明文密码，只保留密码的 [Hash](https://baike.baidu.com/item/Hash/390310?fr=aladdin)。

Hash，一般翻译做 “散列”，也有直接音译为“哈希” 的，就是把任意长度的输入（又叫做预映射 pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 – Baidu

为了保证存储的不是明文，从而采用 Hash，但是密码 Hash 也需要特定的生成算法以及表现形式。

### NTLM Hash 与 NTLM

在 Windows 中，密码 Hash 目前称之为 NTLM Hash，其中 NTLM 全称是：“NT LAN Manager”。

这个 NTLM 是一种网络认证协议，与 NTLM Hash 的关系就是：NTLM 网络认证协议是以 NTLM Hash作为根本凭证进行认证的协议。

也就是说，NTLM 与 NTLM Hash 相互对应。

在本地认证的过程中，其实就是将用户输入的密码转换为 NTLM Hash 与 SAM 中的 NTLM Hash 进行比较。

### NTLM Hash 的产生

假设我的密码是 admin，那么操作系统会将 admin转换为十六进制，经过 Unicode 转换后，再调用 MD4 加密算法加密，这个加密结果的十六进制就是 NTLM Hash

```
admin -> hex(16进制编码) = 61646d696e
61646d696e -> Unicode = 610064006d0069006e00
610064006d0069006e00 -> MD4 = 209c6174da490caeb422f3fa5a7ae634

```

### 本地认证流程

```
winlogon.exe -> 接收用户输入 -> lsass.exe -> (认证)


```

首先，用户注销、重启、锁屏后，操作系统会让 winlogon 显示登录界面，也就是输入框，接收输入后，将密码交给 lsass 进程，这个进程中会存一份明文密码，将明文密码加密成 NTLM Hash，对 SAM 数据库比较认证。

*   Windows Logon Process(即 winlogon.exe)，是 Windows NT 用户登 陆程序，用于管理用户登录和退出。
    
*   LSASS 用于微软 Windows 系统的安全机 制。它用于本地安全和登陆策略。
    

### LM Hash

在 NTLM 协议问世之前，它对前身就是 LM（LAN Manager）协议。

LM 与 NTLM 协议的认证机制相同，但是加密算法不同。

目前大多数的 Windows 都采用 NTLM 协议认证，LM 协议已经基本淘汰了。

LM 协议认证过程中需要 LM Hash 作为根本凭证进行参与认证，下面就简述一些 LM Hash 的产生：

*   将所有小写字母转换为大写字母 • >123ABC // 未达到 7 个字符 • 将密码转化为 16 进制，分两组，填充为 14 个字符, 空余位使用 0x00 字符填补 > 31323341424300000000000000• 将密码分割为两组 7 个字节的块
    
*   >31323341424300 00000000000000 // 16 进制 • 将每组转化为比特流，不足 56Bit 则在左边加 0• >31323341424300 ->(转换为二进制) 110001001100100011001101000001010000100100001100000000-> (补 足 56Bit)
    
*   00110001001100100011001101000001010000100100001100000000• 将比特流按照 7 比特一组，分出 8 组，末尾加 0 由于后者都为 0，结果可想而知，那就都是 0;  
    
*   将每组比特流转换为 16 进制作为被加密的值，使用 DES 加密，字符串 “KGS!@#$%” 为 Key(0x4B47532140232425)，得到 8 个结果 ，每个 结果转换为 16 进制。• -> 00110000100110001000110001101000000101000001001000001100
    
*   00000000• ->30988C6814120C00 -> DES(30988C6814120C00) -> 48-D7-EB-91- 2F-5E-69-7C  
    
*   由于我们的密码不超过 7 字节，所以后面的一半是固定的:  
    
*   AA-D3-B4-35-B5-14-04-EE  
    
*   连接两个 DES 加密字符串。这是 LM 哈希。  
    
*   48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE
    

在上面的产生过程中，脆弱点就在于 DES 的 Key（KGS!@#$%）是固定的，也就是说，有了 Key 就能够解出原文。

并且根据 LM Hash 特征，也能够判断用户的密码是否是大于等于 7 位。

0x01 网络认证
---------

在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑 上的网络环境 (工作区)，隶属于工作组的机器之间无法互相建 立一个完美的信任机制，只能点对点，是比较落后的认证方式， 没有信托机构。

假设 A 主机与 B 主机属于同一个工作组环境，A 想访问 B 主机上的资料，需要将一个存在于 B 主机上的账户凭证发送至 B 主机，经过认证才能够访问 B 主机上的资源。

这是我们接触比较多的 SMB 共享文件的案例，SMB 的默认端口是 445。

早期 SMB 协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称 LM，它是如此简单以至很容易就被破解，现在又有了 NTLM 以及 Kerberos。

### NTLM 协议

NTLM 是一种网络认证协议，它是基于挑战（Chalenge）/ 响应（Response）认证机制的一种认证模式。

这个协议只支持 Windows

### Chalenge/Response

**NTLM 协议的认证过程分为三步：**

*   协商
    
*   质询
    
*   验证
    

协商：主要用于确认双方协议版本

质询：就是挑战（Chalenge）/ 响应（Response）认证机制起作用的范畴，本小节主要讨论这个机制的运作流程。

验证：验证主要是在质询完成后，验证结果，是认证的最后一步。

**质询的完整过程：**

*   1. 客户端向服务器端发送用户信息 (用户名) 请求
    
*   2. 服务器接受到请求，生成一个 16 位的随机数，被称之为 “Challenge”， 使用登录用户名对应的 NTLM Hash 加密 Challenge(16 位随机字符)， 生成 Challenge1。同时，生成 Challenge1 后，将 Challenge(16 位随机 字符) 发送给客户端。
    
*   3. 客户端接受到 Challenge 后，使用将要登录到账户对应的 NTLM Hash 加密 Challenge 生成 Response，然后将 Response 发送至服务器端。
    

其中，经过 NTLM Hash 加密 Challenge 的结果在网络协议中称之为 Net NTLM Hash。

验证： 服务器端收到客户端的 Response 后，比对 Chanllenge1 与 Response 是否相等，若相等，则认证通过。

**使用另外一种方式解读：**

1.Server 接收到 Client 发送的用户名后，判断本地账户列 表是否有用户名 share_user

*   如果没有，返回认证失败
    
*   如果有，生成 Chanllenge，并且从本地查找 share_user 对 应的 NTLM Hash，使用 NTLM Hash 加密 Chanllenge，生成一 个 Net-NTLM Hash 存在内存中，并将 Chanllenge 发送给 Client。
    

2.Client 接收到 Chanllenge 后，将自己提供的 share_user 的密码转换为 NTLM Hash，使用 NTLM Hash 加密 Chanllenge， 这个结果叫 Response，表现形式是 Net-NTLM Hash，最后将 Response 发送给 Server。

3.Server 接收到 Client 发送的 Response，将 Response 与之 前的 Net-NTLM Hash 进行比较，如果相等，则认证通过。

**注意:**

1.Chanllenge 是 Server 产生的一个 16 字节的随机数，每次认证都不同

2.Response 的表现形式是 Net-NTLM Hash，它是由客户端 提供的密码 Hash 加密 Server 返回的 Chanllenge 产生的结果。

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image12.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image12.png)

### NTLM V2 协议

NTLM v1 与 NTLM v2 最显著的区别就是 Challenge 与加密算法不同，共同点就是加密的原料都是 NTLM Hash。

下面细说一下有什么不同:

*   Challage:NTLM v1 的 Challenge 有 8 位，NTLM v2 的 Challenge 为 16 位。
    
*   Net-NTLM Hash:NTLM v1 的主要加密算法是 DES，NTLM v2 的主要加密算法是 HMAC-MD5。
    

现在应该能够理解什么是 NTLM、NTLM Hash、LM、LM Hash、Net NTLM Hash 了吧？

### Pass The Hash

在内网渗透中，我们经常会需要抓取管理员的密码、NTLM Hash，通过搜集这些信息有助于我们扩大战果，尤其是在域环境下。

*   什么是哈希传递?
    

哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。

*   哈希传递的作用?
    

解决了我们渗透中获取不到明文密码、破解不了 NTLM Hash 而又 想扩大战果的问题。

Pass The Hash - 必要条件

*   哈希传递需要被认证的主机能够访问到服务器 (废话)
    
*   哈希传递需要被传递认证的用户名
    
*   哈希传递需要被传递认证用户的 NTLM Hash
    

要完成一个 NTLM 认证，第一步需要客户端将自己要参与认证的 用户名发送至服务器端，等待服务器端给出的 Challenge⋯⋯

其实哈希传递就是使用用户名对应的 NTLM Hash 将服务器给出的 Chanllenge 加密，生成一个 Response，来完成认证。

Pass The Hash 能够完成一个不需要输入密码的 NTLM 协议认证流程，所以不算是一个漏洞，算是一个技巧。

Pass The Hash 的工具：

*   Smbmap
    
*   CrackMapExec
    
*   Smbexec
    
*   Metasploit
    

使用 CrackMapExec 实现 Hash 传递：

```
root@kali:~/cache# cme smb 192.168.3.5 -u administrator -H dab7de8feeb5ecac65faf9fdc6cac3a9 -x whoami
SMB 192.168.3.5 445 LIYINGZHEA30B
[*] Windows 7 Ultimate 7601 Service Pack 1 x64 (name:LIYINGZHEA30B)
(domain:PAYLOADS) (signing:False) (SMBv1:True)
SMB 192.168.3.5 445 LIYINGZHEA30B
[+] PAYLOADS\administrator dab7de8feeb5ecac65faf9fdc6cac3a9
(Pwn3d!)SMB 192.168.3.5 445 LIYINGZHEA30B [+] Executed command


```

0x02 Kerberos 域认证
-----------------

Active Directory(活动目录) 概念

Windows 提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务，当然，这个不在我们的讨论范围。

活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。

*   Active Directory 存储了有关网络对象的信息，并且让管理员和用 户能够轻松地查找和使用这些信息。Active Directory 使用了一种 结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻 辑的分层组织。
    
*   网络对象分为: 用户、用户组、计算机、域、组织单位以及安全 策略等。
    

### Active Directory(活动目录) 功能

*   服务器及客户端计算机管理: 管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。
    
*   用户服务: 管理用户域账户、用户信息、企业通讯录 (与电子邮 件系统集成)、用户组管理、用户身份认证、用户授权管理等， 按省实施组管理策略。
    
*   资源管理: 管理打印机、文件共享服务等网络资源。
    
*   桌面配置: 系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特 征限制、网络连接限制、安全配置限制等。
    
*   应用系统支撑: 支持财务、人事、电子邮件、企业信息门户、办 公自动化、补丁管理、防病毒系统等各种应用系统。
    

在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。

这个中间就需要 Kerberos 认证协议来验证网络对象间的权限。

### 域认证体系 - Kerbroes

Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客 户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不 依赖于主机操作系统的认证，无需基于主机地址的信任，不要求 网络上所有主机的物理安全，并假定网络上传送的数据包可以被 任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一 种可信任的第三方认证服务，是通过传统的密码技术 (如: 共享 密钥) 执行认证服务的。

### 域认证所参与的角色 (三只狗头)

Kerberos 的标志是三只狗头，狗头分别代表以下角色：

*   Client
    
*   Server
    
*   KDC(Key Distribution Center) = DC(Domain Controller)
    

Kerberos 认证协议的基础概念：

票据（Ticket）：是网络对象互相访问的凭证。 TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证的存在。

KDC 负责管理票据、认证票据、分 ** 据，但是 KDC 不是一个独立的服务，它由以下服务组成：

*   Authentication Service: 为 client 生成 TGT 的服务
    
*   Ticket Granting Service: 为 client 生成某个服务的 ticket
    

另外还需要介绍一个类似于本机 SAM 的一个数据库：AD，全称叫 account database，存储所有 client 的白名单，只有存 在于白名单的 client 才能顺利申请到 TGT。

从物理层面看，AD 与 KDC 均为域控制器 (Domain Controller)。

### 域认证粗略流程

1.  client 向 kerberos 服务请求，希望获取访问 server 的权限。 kerberos 得到了这个消息，首先得判断 client 是否是可信赖的， 也就是白名单黑名单的说法。这就是 AS 服务完成的工作，通过 在 AD 中存储黑名单和白名单来区分 client。成功后，返回 AS 返 回 TGT 给 client。
    
2.  client 得到了 TGT 后，继续向 kerberos 请求，希望获取访问 server 的权限。kerberos 又得到了这个消息，这时候通过 client 消息中的 TGT，判断出了 client 拥有了这个权限，给了 client 访 问 server 的权限 ticket。
    
3.  client 得到 ticket 后，终于可以成功访问 server。这个 ticket 只是 针对这个 server，其他 server 需要向 TGS 申请。
    

### 域认证

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image13.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image13.png)

首先，客户端需要发送自己的身份信息到 KDC，身份信息中起码包含用户名，KDC 根据用户名在 AD 中寻找是否在白名单中，然后根据用户名提取到对应的 NTLM Hash。

KDC 此时生成一个随机字符串，叫 Session Key，使用用户名对应的 NTLM Hash 加密 Session Key，作为 AS 数据，使用 KDC 中某个用户的 NTLM Hash 加密 Session Key 和客户端的信息，生成 TGT。

*   Session Key 用于客户端向 TGS 服务通信。
    
*   域内所有网络对象的凭证都在 AD 中保存
    
*   KDC 中某个用户指的是 krbtgt
    

数据结构：

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image14.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image14.png)

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image15.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image15.png)

其中，TGT 的到期时间为 8 小时，如果超过了 8 小时，还需要重新申请 TGT，不能之间进入下一步获取 Ticket。

Kerberos 是一个假设网络环境不安全的情况下能够正常进行认证工作的协议。

第一步中，KDC 返回的 TGT 客户端是无法解密的，因为它没有 KDC Hash，如果有，我们就可以伪造黄金票据，这个是后话了。

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image16.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image16.png)

第二步客户端需要提供 TGT 与第一步中使用自己 NTLM Hash 解密出来的 Session Key 加密的客户端信息跟时间戳。

如果假设这个数据被中间人窃取到，也无法在段时间内破解，因为 KDC 会校验时间戳。

KDC 接到 TGT 与其他内容后，会首先解密 TGT，只有 KDC 可以解密 TGT，从 TGT 中提取到 Session Key，再使用 Session Key 解密其他内容，解密出来的内容同 TGT 中的信息进行校验来确认客户端是否受信。

验证通过后，就会生成一个新的 Session Key，我们称之为 Server Session Key，这个 Server Session Key 主要用于和服务器进行通信。同时还会生成一个 Ticket，也就是最后的票据了。

Ticket 组成如下：

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image17.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image17.png)

Server Hash：这个 Hash 是在 AD 中服务器计算机的 NTLM Hash

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image18.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image18.png)

在第三步里，客户端向服务器请求，需要提供 Ticket，Server Session Key 加密的客户端信息与时间戳。

*   Ticket 客户端无法解密
    
*   服务器端通过解密 Ticket 解密 Server Session Key(Client info + Timestamp)
    
*   比较时间长度
    

校验通过后，认证成功，该票据会一直存在客户端内存中。

### 白银票据 (Silver Tickets)

白银票据特点:

*   1. 不需要与 KDC 进行交互
    
*   2. 需要目标服务的 NTLM Hash
    

在第三步认证中的 Ticket 的组成:

```
Ticket=Server Hash(Server Session Key+Client info+End Time)


```

当拥有 Server Hash 时，我们就可以伪造一个不经过 KDC 认证的一个 Ticket。

**PS**:Server Session Key 在未发送 Ticket 之前，服务器是不知道 Server Session Key 是什么的。 所以，一切凭据都来源于 Server Hash。

### 伪造白银票据 (Silver Tickets)

首先需要导出 Server Hash：

```
C:\files>mimikatz.exe "privilege::debug” "sekurlsa::logonpasswords" "exit" > log.txt


```

伪造票据:

```
mimikatz “kerberos::golden /domain:<域名> /sid:<域 SID> /target:<目标服务器主机名> /service:<服务类型> /rc4:<NTLM Hash> /user:<用户名> /ptt" exit


```

Other：

*   kerberos::list #列出票据
    
*   kerberos::purge # 清除票据
    

由于白银票据需要目标服务器的 Hash，所以没办法生成对应域内 所有服务器的票据，也不能通过 TGT 申请。因此只能针对服务器 上的某些服务去伪造，伪造的服务类型列表如下:

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image19.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image19.png)

### 白银票据 (Silver Tickets) 演示

https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-11-30/kerberos_stgt.mp4

### 白银票据 (Silver Tickets) 防御

*   1. 尽量保证服务器凭证不被窃取
    
*   2. 开启 PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC 主要是规定服务器将票据发送给 kerberos 服务，由 kerberos 服务验证票据是否有效。
    

开启方式:

将注册表中

```
HKEY_LOCAL_MACHINE\SYSTEM \ CurrentControlSet\Control\Lsa\Kerberos\Parameters


```

中的 ValidateKdcPacSignature 设置为 1。

### 黄金票据 (Golden Tickets)

黄金票据特点:

*   1. 需要与 DC 通信
    
*   2. 需要 krbtgt 用户的 hash
    

PS: 这里的 krbtgt hash 就是之前讲的 KDC Hash

### 黄金票据 (Golden Tickets)-MSF kiwi

使用 meterpreter 中的 kiwi 模块：

**load kiwi**

创建票据：

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image20.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image20.png)

注入到内存：

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image21.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image21.png)

使用 wmic 在目标服务器上创建一个进程：

[![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image22.png)](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/2019/01/image22.png)

### 黄金票据 (Golden Tickets) - 伪造

伪造票据:

```
mimikatz “kerberos::golden /domain:<域名> /sid:<域SID> /rc4:<KRBTGT NTLM Hash> /user:<任意用户名> /ptt" exit


```

### 黄金票据 (Golden Tickets) - 演示

https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-11-30/kerberos_gtgt.mp4

### Tickets 总结

*   黄金票据: 从攻击面来看，获取 krbtgt 用户的 hash 后，可以在域中 进行持久性的隐藏，并且日志无法溯源，但是需要拿到 DC 权限， 使用黄金票据能够在一个域环境中长时间控制整个域。
    
*   从防御角度来看，需要经常更新 krbtgt 的密码，才能够使得原有的 票据失效。最根本的办法是不允许域管账户登录其他服务器。
    
*   白银票据: 从攻击面来看，伪造白银票据的难度比伪造黄金票据的 难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储 Server。
    
*   从防御角度来看，需要开启 PAC 认证，但这会降低认证效率，增加 DC 的负担，最根本的还是要加固服务器本身对外的服务。
    

0x03 Windows Access Token
-------------------------

### Windows Access Token 简介

Windows Token 其实叫 Access Token(访问令牌)，它是一个描 述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个 Access Token，这个 Token 在用户创建进程或者线程 时会被使用，不断的拷贝，这也就解释了 A 用户创建一个进程而该 进程没有 B 用户的权限。

Access Token 种类：

*   主令牌
    
*   模拟令牌
    

一般情况下，用户双击运行一个程序，都会拷贝 “explorer.exe” 的 Access Token。

当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。

### Windows Access Token 组成

*   用户帐户的安全标识符 (SID)
    
*   用户所属的组的 SID
    
*   用于标识当前登录会话的登录 SID
    
*   用户或用户组所拥有的权限列表
    
*   所有者 SID
    
*   主要组的 SID
    
*   访问控制列表
    
*   访问令牌的来源
    
*   令牌是主要令牌还是模拟令牌
    
*   限制 SID 的可选列表
    
*   目前的模拟等级
    
*   其他统计数据
    

### Windows Access Token – SID (Security Identifiers) 安全标识符

安全标识符是一个唯一的字符串，它可以代表一个账户、一个用户 组、或者是一次登录。通常它还有一个 SID 固定列表，例如 Everyone 这种已经内置的账户，默认拥有[固定的 SID](https://docs.microsoft.com/zh-%20cn/windows/desktop/SecAuthZ/well-known-sids)。

SID 的表现形式:

*   域 SID - 用户 ID
    
*   计算机 SID - 用户 ID
    
*   SID 列表都会存储在域控的 AD 或者计算机本地账户数据库中。
    

### Windows Access Token 产生过程

每个进程创建时都会根据登录会话权限由 LSA(Local Security Authority) 分配一个 Token(如果 CreaetProcess 时自己指定了 Token, LSA 会用该 Token， 否则就用父进程 Token 的一份拷贝。

### Windows Access Token 令牌假冒实战

当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清 除，只有在重启机器后才会清除。

可以使用多种工具查看目前系统上存在的模拟令牌:

*   Incognito
    
*   Powershell - Invoke-TokenManipulation.ps1
    
*   Cobalt Strike - steal_token
    

案例 (针对某跨国企业的一次渗透测试 获取 DC 权限）: http://blog.360ec.net/archives/32/

### Windows Access Token 令牌假冒实战

```
meterpreter > getsystem
meterpreter > load incognito meterpreter > list_tokens –u
Delegation Tokens Available ============================== NT AUTHORITY\LOCAL SERVICENT AUTHORITY\NETWORK SERVICENT AUTHORITY\SYSTEM PAYLOADS\Administrator PAYLOADS\w7
meterpreter > impersonate_token "PAYLOADS\\Administrator”
[+] Delegation token available
[+] Successfully impersonated user PAYLOADS\Administrator


```

### Windows Access Token 令牌假冒防御

禁止 Domain Admins 登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从控制 DC。

如果想清除假冒，重启服务器即可。

0x04 知识点总结
----------

本次议题围绕着 Windows 认证分别讲解了 Pass The Hash、Silver Tickets、Golden Tickets、 Impersonation Token 的原理。 这些技术分别能够满足我们在渗透中持续的维持权限、提权。

可拓展:

域渗透技术 / 思路，SPN 扫描，Red/Blue team

*   https://lolbas-project.github.io/
    
*   https://gtfobins.github.io/
    
*   https://github.com/yeyintminthuhtut/Awesome-Red-Teaming
    

0x05 议题资料分享
-----------

技术分享议题 —《彻底理解 Windows 认证》

附 ppt、目录、演示视频、演讲视频，时长：1 小时 50 分钟左右（1080P 画质）

分享链接： https://yunpan.360.cn/surl_ymCtyG7w5wh (提取码: 46de)

**本文作者：[倾旋](https://www.secpulse.com/archives/newpage/author?author_id=13248)**

**本文为安全脉搏专栏作者发布，转载请注明：**[**https://www.secpulse.com/archives/94848.html**](https://www.secpulse.com/archives/94848.html)