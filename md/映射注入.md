<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ji7oV9OM3C8Z0gk5MXoiVA)

#### 本文所有代码回复 2023-12-26 获取。

#### 简介

针对于各大安全厂商对私有内存的监控，就是我们之前使用 VirtualAlloc/EX 来申请的内存，最后执行 shellcode 如下图是 RWX 的内存区域，里面是我们的 shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmyplLEXjpO7ekibS4HJia7EUSxuABd1J45iaUhmlKruwwk7Ic6yWIhnmPUQ/640?wx_fmt=png&from=appmsg)

#### 映射注入

由于各大安全厂商以及安全软件对分配私有内存有着高度监控，所以为了避免使用一些常见的 API 函数，比如 VirtualAlloc/EX，VirtualProtect/Ex，映射注入使用 Mapped 内存类型，并使用不同的 Win API 函数，例如 CreateFileMapping 和 MapViewOfFile。

需要注意的是 VirtualProtect 是无法更改更改映射内存的内存权限。

#### 创建文件映射

这里需要用到如下函数:

```
CreateFileMapping

```

经微软介绍 CreateFileMapping 函数可以创建或打开命名或未命名的文件映射对象，该对象通过内存映射技术对文件内容的访问，它允许进程创建虚拟内存空间，映射到磁盘上文件的内容或另一个内存位置。该函数返回文件映射对象的句柄。

```
HANDLE CreateFileMappingA(
  [in]           HANDLE                hFile,
  [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
  [in]           DWORD                 flProtect,
  [in]           DWORD                 dwMaximumSizeHigh,
  [in]           DWORD                 dwMaximumSizeLow,
  [in, optional] LPCSTR                lpName
);

```

hFile 用于创建文件映射对象的文件的句柄，由于在实现中不需要从文件中创建文件映射因此可以使用 INVALID_HANDLE_VALUE 标志来代替，微软对 INVALID_HANDLE_VALUE 的解释是:

_如果_ _hFile_ _为_ INVALID_HANDLE_VALUE，则调⽤进程还必须在 dwMaximumSizeHigh 和 dwMaximumSizeLow 参数中指定映射对象的大小，在这种情况下 CreateFileMappingA 创建指定大小的文件映射对象。设置此标志允许函数在不使用磁盘中的文件的情况下执行任务，而是在内存中创建文件映射对象，大小由 dwMaximumSizeHigh 和 dwMaximumSizeLow 参数来决定的。

flProtect 参数表示指定文件映射对象的权限，这里我们设置为 PAGE_EXECUTE_READWRITE 权限即可，这里并不会立即创建 RWX 的内存区域，而是稍后进行创建，我们如果设置 PAGE_READWRITE 的话，后续 shellcode 将无法执行。

#### MapViewOfFile

MapViewOfFile 函数会将文件映射的视图映射到调用进程的地址空间中，它获取文件映射对象的句柄和所需的访问权限，并返回指向进程地址空间中映射开头的指针。

```
LPVOID MapViewOfFile(
  [in] HANDLE hFileMappingObject,
  [in] DWORD  dwDesiredAccess,
  [in] DWORD  dwFileOffsetHigh,
  [in] DWORD  dwFileOffsetLow,
  [in] SIZE_T dwNumberOfBytesToMap
);

```

hFileMappingObject 参数表示文件映射对象的句柄，也就是上面我们通过 CreateFileMapping 创建的文件映射，dwDesiredAccess 参数表示文件映射的访问类型，这里我们将其设置为 FILE_MAP_EXECUTE 和 FILE_MAP_WRITE 标志来返回有效的可执行和可写的内存。

#### 代码编写

首先通过 CreateFileMapping 函数创建一个文件映射句柄。

这里的第一个参数我们上面说过了给他一个 INVALID_HANDLE_VALUE 标志，不需要从文件中创建文件映射，还有就是四个和第五个参数指定的就是映射对象的大小，这里我们第五个参数指定 shellcode 的大小即可，并且第三个参数我们需要指定 PAGE_EXECUTE_READWRITE 表示我们需要 RWX 的内存区域，但不是立即创建，而是稍后创建。

```
hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, shellcodeSize, NULL);

```

创建完成文件映射之后，接下来需要来将文件映射的视图映射到进程的地址空间中。

这里第一个参数是我们上面通过 CreateFileMapping 函数拿到的文件映射的句柄，第二个参数就是我们上面说过的，需要将其设置为 FILE_MAP_EXECUTE 和 FILE_MAP_WRITE 标志，来返回有效的可执行和可写的内存，最后一个参数就是 shellcode 的大小。

```
pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, NULL, NULL, shellcodeSize);

```

这前两步我们可以理解为 VirtualAlloc 这一类的函数。

创建完成之后，我们拿到了创建好内存的地址，然后通过 memcpy 将 shellcode 复制到创建好的内存地址中。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmynYib0oNoWJqstK3TrOzKd3jX1iaXc84xWbC8GPoEnVKryb9LQXcf3uog/640?wx_fmt=png&from=appmsg)

copy shellcode 到内存。

最后我们通过回调函数去执行即可，当然你也可以使用创建线程的方式，或者指针的方式都可以。

```
EnumChildWindows(NULL, (WNDENUMPROC)Address, NULL);

```

但是我们提前得把这块内存的地址给他带出来。

```
*ppAddress = Address;

```

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmyP6CrytkCRkiaErLFY3ibYyYCex1uwLCA5ib0QUp7iakHayvm0XYwEncuibQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmy9WzHXQTe27eHobEeo2pnxbMZp5ZVrsgGQ8jQNyfuVOkw24bOtEecBA/640?wx_fmt=png&from=appmsg)

#### UnmapviewOfFile

UnmapviewOfFile 函数用于取消映射先前映射的内存，这个一般我们在执行完 shellcode 之后再去调用，而不是正在运行中，UnmapviewOfFile 函数只需要取消映射的文件映射视图的基地址，也就是 Address。

我们来一步一步来跟一下:

首先将文件映射的视图映射到调用进程的地址空间，然后 copy shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmy7VRWHCXE2u8IRHFV62P4p8PGrDPVbPH5SBLfeZESlLMz5SpodhxMbw/640?wx_fmt=png&from=appmsg)

copy shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/ia1z64qxm2mpxy2XMTy3DBUgAUSzhjYmyBvySpwajH5QcnTqG1aGI4B8tjPxyQnW6JicaLLlWVX5P6XuqLuoPLdw/640?wx_fmt=png&from=appmsg)

最后通过回调函数执行。