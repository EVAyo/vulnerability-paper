<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/nPD5DmNmIMIH8uW_MKHQ9g)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKTuNjLMC6vUjdfMMgL4ScCZD7aH7z4BiaAuEvia3XvzjXAPBwu7ia9kib7g/640?wx_fmt=png)

**内存马初识**

**01 基础概念**

**内存与硬盘**

在程序运行时，硬盘和内存扮演着不同的角色：

*   硬盘用于存储程序的可执行文件、库文件、配置文件和其他必要的数据文件。当程序首次运行或在需要时，这些文件从硬盘加载到内存中。
    
*   内存用于存储程序的指令和数据，包括代码、变量、对象、堆栈等。当程序需要执行特定的指令或访问特定的数据时，CPU 从内存中读取这些内容进行处理。
    

因为内存的成本是很高的，所以内存的容量通常比硬盘小得多，但读取和写入速度更快。所以在运行程序将他放入内存，平时放在硬盘来节约内存空间。

**安全问题 - 内存马**

普通的木马是写入一个文件去访问，恶意代码是依靠于文件的。执行后就会在内存中被释放掉。但是内存马是依赖于程序本身的动态注册，会在内存中进行一个保存，视为程序的一部分。实现脱离文件后依旧可以运行。 

**02 Tomcat 内存马**

(此文章默认你已经了解 javaweb)

对于 Tomcat 内存马，我们首先要知道 Java 会将 JSP 文件翻译成一个 Servlet 的文件的。同时你会发现 JSP 是热部署的。即可以不停止整个 java 服务来添加新的 Jsp 页面。这对与 Java-web 开发来说是极为方便的，但是方便就容易带来安全的问题。结合 Servlet3 支持动态注册，我们就可以构造各种 Web 组件内存马。

**Listener 内存马**

**ServletRequestListener**

**调用链**

我们直接通过书写一个 Listener，然后进行调试即可发现调用链为：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK2zm4u9ib28oaAZTcqWzUXtNeiaZGMeiboiaWYTEzIGrZXtYarK9D6w0YqQ/640?wx_fmt=png)

我们的代码逻辑是记录在 requestInitialized 方法中的，那么我们就寻找是怎么调用的 requestInitialized 方法。

StandardContext：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK9nJzkyQSa7icuv0c1YOO96z9Qib9DWgl0IQdtw17ichfACkQgJrFy2xibA/640?wx_fmt=png)

我们可以看到是通过 listener.requestInitialized 这里进行的一个调用。而这个 listener 是通过 getApplicationEventListeners() 获取的。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKh6hu5zyb7CkvvPl39SwEbHG6tkrFLlhsDl6AQYia06N6y1oUbcJSibNw/640?wx_fmt=png)

那么关键就是这个 applicationEventListenersList 的内容了。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKzg8tW6dpldeexUgbYDiaAhiahRjibd3S3ozI0h8JsvicJ7kVF8mRKdtMyw/640?wx_fmt=png)

并且 StandardContext 类中提供了这么一个方法给我们添加。那么 StandardContext 类我们如何获取勒，查看调用链子简单寻找了下，StandardHostValve 类中存在对 StandardContext 的获取。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKbd2bRSDCiaXU6vHOOFzCeNHGyNJcWd1SoiasTegahJAZG5ricTECKfTcA/640?wx_fmt=png)

那么我们就要获取 request 类了，在 JSP 中是自带有 RequestFacade 类的。我们要获取的是 Request 类，所以我们直接通过反射来进行获取。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKVsMVRickdD1MpfQ4o3ddtFFUGPH2CTbfBGcGjbbJkrnhLNyCRPgUgGw/640?wx_fmt=png)

其中的 this.request 被传入了 Request 类，也就是 StandardHostValve 类中的 request。然后写入我们的 Listener 就可以了。

**思路总结**

Listener 是会检测任何数据的变化的，对于 ServletRequestListener 对象，对于每一个会话连接都要进行一个检测。那么就一定存在一个全局的存储位置。然后通过反射对这个变量进行更改即可实现 Listener 的建立。这里即为 StandardContext.applicationEventListenersList。

**POC**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKm9qFiawHsQdZibsLR2q7IIyWjovLWmDytcuQxUEhibVPbepChayrlehcg/640?wx_fmt=png)

**Filter 类型的创建**

**调用链**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKIgYNgZG1uvjfM5vtBAia0GalqwEQcE9kP7HGnnKsEuwLack0wc5ef0A/640?wx_fmt=png)

internalDoFilter:189.ApplicationFilterChain:

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKaTBQubW7pO3SIHeBmpxAibbscUBx7WMovFiaaZB0feBjOzKv0R7MQh6A/640?wx_fmt=png)

这里可以看出我们的 Filter 是由 filters 属性来进行存储的。那么我们寻找一下是如何进行初始化的。

invoke:197.StandardWrapperValve 中使用了 ApplicationFilterFactory.createFilterChain 来新建一个 ApplicationFilterChain 类。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKt7la5LicWZjRBygkDMQm3p3zTt2m0fbib0tjRsmoziaNtIrRv5dn7flOw/640?wx_fmt=png)

我们可以看到其中是通过读取 StandardContext 的属性来进行构建 ApplicationFilterChain 类的。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKwTw7ibVe7zickia4WpoIzRlMOoaHE6Q76S1zxC9vmgzrAUXD3z8IldRMw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKAicUISibhJzuPMNKsIKPwIeWJseIA6DmTtntZX2mXGz8mjhxaZJtDm2A/640?wx_fmt=png)

所以我们即对 StandardContext 的属性 filterConfigs 和 filterMap 进行设置即可。我们来查看是否有对应的属性设置的方法。

创建 filterMap：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKHPBSJ1cH58WJjLlibaM1O4ySiaZ5Ve1ZuMk3uB4kcyU7LDoE6VjMcIHg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKuTVbW8OEXrWuKt6gTltASRGsleN1zEHBMXTUzrE48cmhwCsYvCalicg/640?wx_fmt=png)

创建 filterConfigs：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK1pMlKNYOXFcib3Laoc0Xm1eUMMPKhn7SPFciaHrtj0pHFsHY632OxichA/640?wx_fmt=png)

filterConfigs 本质是个 Map，看看它是如何被赋值。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK1ibbNWKRWsWvajCn1LJ9WKdVf1Wz7pJTPibBQEicibSHMO2sdtXtsEryog/640?wx_fmt=png)

那么我们就要对 filterDefs 进行一个赋值:

filterDef。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKXnibWdZeHLZRoUDGD8h80pMkumGNWlKjicNV1hT7jKdaWX6bjaIve89Q/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK3icia6yUC1yNF3cpJ1XSAJ0Sg48sOAxlKy5sDWr8J7BuarL8CyJOgkibw/640?wx_fmt=png)

然后再对 filterConfigs 进行一个赋值：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKprUI5yE2iaslP1MUSlX6aicfhnB3ZXlbfib8qcfUkqteYribbVcQaZDKrA/640?wx_fmt=png)

**思路总结**

*   获取 StandardContext 对象;  
    
*   设置 StandardContext 中的 FilterMaps 对象;  
    
*   设置 filterDefs 对象，然后组装进 filterConfig，然后将 filterConfig 写入 filterConfigs 中。
    

**POC**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK8EZRh4jdxJ60CbkkEqgBzHJ7KJMGVWjwibxzpWDcaznvnkCWaib9DDibA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKqzDIWJDjkFwDNKx77FAkhibSp0Yhqb53st73cBib29497JuHDziagqtdw/640?wx_fmt=png)

**Servlet 型**

**调用链**

这个是较为简单的，应用一下大佬的调试链子。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKWGNSakwkb31TPBjA0ecUET9XnqlhmAiaibDE3AqTYWMJCztMODl1ibzSQ/640?wx_fmt=png)

通过 configureContext(webXml) 方法创建 StandWrapper 对象，并根据解析参数初始化 StandWrapper 对象。

Servlet 的所有信息是存储在 wrapper 中的。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKfTPkSep4Ea2ic4rPC8zic2Tj3H2cfGTmj4roaTyWHSgkOXnbj0Ttj4Cw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKGFJUqMoZibvbYQ011dLTD0g4J2Jy8bNIwdJk8OqlgDItlQQRibFicrbBg/640?wx_fmt=png)

**思路总结**

所以综上我们的思路就是：

*   老套路获取 StandardContext 对象;
    
*   然后通过 StandardContext.createWrapper() 创建 StandardWrapper 对象;
    
*   设置 StandardWrapper 对应的属性，并将 StandardWrapper 对象添加进 StandardContext 对象;
    
*   通过 StandardContext.addServletMappingDecoded() 添加对应的路径映射。
    

**POC**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKZtbIpxic10J0Vjks4moIGfibDln3XnRdfdccYzuoTWK2EOCsqgwr6xmg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKiaDLum7b5Apy4pvXPBLz9BiauYRQl4VWSbc4yxg8Eic7JNXLvQDEeMNeA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKFo5LmbvRaVeWOpUk4JcRib9ArfnXlfR5ibAAU4Nqm5VXjWUW7Y9EFX7g/640?wx_fmt=png)

**Valve**

(个人感觉这个是分析起来最简单的。)

管道机制主要涉及到两个名词，Pipeline(管道)和 Valve(阀门)。如果我们把请求比作管道 (Pipeline) 中流动的水，那么阀门 (Valve) 就可以用来在管道中实现各种功能，如控制流速等。因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑(即其中的 invoke 方法)。

即通过一个 Pipeline 类来维护一个通道，具体的逻辑是由 Valve 类来进行维护的。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgK1tll9kXshAJPfqeHEww1b9iaxvP8MPiaeLseOU2lbO85NdJsUibFsalMA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKDsQo7hG6L1vqiaoVs7atW2e9hKyBryrzEyrQ28TiahGT6icQB52MN8Xmw/640?wx_fmt=png)

其中的 invoke 方法即为我们的逻辑书写点。

**调用链**

直接使用 Filter 的调试。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKtgaoicPfgNutQUKoFm34oOP6b1y8Dh0PM3qRlficrWS80PbRO8lxO9yg/640?wx_fmt=png)

在 invoke:97.StandardContextValve(org.apache.catalina.core) 中调用了管道中的 Valve 的 invoke 方法。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKmByNxK0ZicKr6TH3aCMrutCRJicsuZiaRUmqt9FCgmskuPYDALEo0FIOA/640?wx_fmt=png)

**思路总结**

我们的思路即创建一个 Value 加入到管道 StandardPipeline 类中即可。

1.  获取 StandardContext 对象；  
    
2.  通过 StandardContext 对象获取 StandardPipeline；  
    
3.  编写恶意 Valve；  
    
4.  通过 StandardPipeline.addValve() 动态添加 Valve。
    

**POC**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKS1KM3M9Cf4swtMzkBia5F1iaKIkZ0ofcGrbICXJU4798yByBrIMDyibhw/640?wx_fmt=png)

**0****3 内存马的检测**

有攻击就有防，根据上文内存马的构造我们就可以写出相应的检测软件。

**Listener 内存马**

我们知道我们是对 StandardContext.applicationEventListenersList 属性进行更改来注册 Listener 内存马。那么我们就可以直接对 applicationEventListenersList 属性进行一个读取即可。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKOLyBZibAXT8hmgFDFtP519YA4Aok6a6icgWBJPMQAxkyKFKBH2CwgJeg/640?wx_fmt=png)

那么如何从这些类中去读取那些是内存马勒，我们可以直接去读取它的一个 class 文件。查询是否存在对于文件，如果不存在就可以初步判断他是一个内存马了。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKrw3nfKjquNTJKf75roM6SaAO3GibM2WKBSwPUta5hPqlZlCTkyDOrVA/640?wx_fmt=png)

代码：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKkMiaovoj73uAKzKzSNSnH6aN4hYswvhopgBcwPsrsMyPW6msavNaLaQ/640?wx_fmt=png)

**Filter 内存马**

前文我们是自己对 filterConfigs 的一个注册，我们对于他的一个检测就简单多了，只用考虑读取就是了。一样的套路使用反射对 StandardContext 类的属性进行一个读取。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKaBvxLic5Bk05MsFRQIJLDkGicySiawuxpNYpEv752siaJfJZ9o3cQez48A/640?wx_fmt=png)

然后核实这些类是否存在对于的 class 文件。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKEibxwRibBicH13YbvFjrEaeVPJCEM1e5wljRx7nUgm2upXadmE9M15XibA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKUMHw32yNwicFs8iaiauZZicrShoeENWy7YpoScYic0vwYia7Eib2JqiaUxPCdQ/640?wx_fmt=png)

**Servlet 内存马**

Servlet 是通过 standardContext.addChild 来对一个 Wrapper 进行添加的。那么我们直接去看看是否有其他的方法可以进行获取。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKsJQib8Tk7aJShs2syDD5d25seFA9VEpiaAQj19DRfjJtokeiaYXWTdryw/640?wx_fmt=png)

同时查找一下 Wrapper 对 servlet 的获取方式。通过 getServletClass() 对 servlet 的类名进行一个获取。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKdtAppNXblJ2aprzVJ7oVV1kLUxVHticWjHH1doW7e9xGsJV2lINHstQ/640?wx_fmt=png)

后面就是一个相同的思路了。查找对应的类名是否存在对应的类文件。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKN8v7MdEibD2WmEG9AM3JRrIHK3BXA9HMYpZdKOLgM0P9FQgpA3RAlzw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKicNMmROd1OhefiaEQL3ibibtQ6oQbD96KrW6PPzStHDqaBIlHmaibGGthPg/640?wx_fmt=png)

**Value 内存马**

StandardPipeline 类直接提供了对应的 getValves 方法，那么就很简单了。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKGCChLZhAhGEASQ0U0gdCbgD5nDPtNibRia9Xiaf4hsF3icRMgv6XpArxIQ/640?wx_fmt=png)

一样的思路去获取类后查找是否存在对应的 class 文件即可。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKHLPQ8pZPULFsib7sMxHZLZYpHITr7LiaK5ib5Gtoibb4PsMEXXODhmJoQA/640?wx_fmt=png)

**04** **原创检测工具**

基本原理上文已经提到了，就是进行一些整合和进行一些页面的美化。

源码地址 https://github.com/TvT-dog/Tomcat-memshell-find。希望大家点点 star。😊

**05 参考文章**

https://goodapple.top/archives/1355

https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Servlet%E5%9E%8B/

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZqQxQaaSFRPeYUHUlBcZazph7U2xMHgKM2ibbvfcctTqYtGTmVEkcrNoUaGmQqLVdLuuvjmFos3tUHEGc5iaMVuw/640?wx_fmt=jpeg)

**长按二维码关注**

**D0g3**

道格安全