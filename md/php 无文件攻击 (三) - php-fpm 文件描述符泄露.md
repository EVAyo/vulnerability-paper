<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_zfT9WdhPnbYB316Y0AuvA)

扫码领资料

获网安教程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSFbaUgVwdsriauB77CgQS8lyBNAxtx9IMqJQdhuuoITunu8A5Gp7kFjF7BvEXSaLMuDTYhnu7Nicghg/640?wx_fmt=other&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp)

  

本文分析了一种利用 php-fpm 文件描述符泄露实现的 php 内存马。

```
文章来源: https://forum.butian.net/share/105
文章作者：jweny
如有侵权请您联系我们，我们会进行删除并致歉

```

**php 无文件攻击 (三) - php-fpm 文件描述符泄露**
===================================

本文思路来源于 imbeee 师傅的文章 (膜膜膜) 

https://www.anquanke.com/post/id/163197

**一、写在前面**
----------

Linux 进程使用文件描述符（FD）来管理打开的文件。

**php-fpm 运行的 php 脚本里，使用 system() 等函数执行外部程序时，由于 php-fpm 没有使用 FD_CLOEXEC 处理 FD，导致 fork 出来的子进程会继承 php-fpm 进程的所有 FD。**

举个栗子：

这是当前 php-fpm work 的所有 FD：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69VetZ6P47rjJLhOaMT5iaZP53lYOJtthn1W49NGPg9eEhLUVg7yW55ic4g/640?wx_fmt=png&from=appmsg)

```
<?php  system("sleep 60");>


```

php-fpm 在执行该文件时，会 fork sleep 子进程。sleep 子进程会继承了父进程 php-fpm 的 FD，其中包括一个关键 FD：php-fpm 监听的 9000 端口的 socket ，这里是 5 号 FD。（原文中一直在声明是 0 号 FD，可能该值并不固定）

sleep 进程号为 1771，可见 sleep 进程继承了 5 号 FD：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69VRpdQCiaBysmnvCtO4gfmNPrlgPgupQrMbuxPFegGaETEOQD4JkbeLkg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69V47bXb7vUVazfyEMscjovUOQxJLfM1Ma8f3iaMMME2iccxhGUtYYmaYpQ/640?wx_fmt=png&from=appmsg)

在子进程里有了继承来的 socket FD，就可以直接使用 accept 函数直接从该 socket 接受一个连接。

测试下：

index.php

```
<?php
// t2.php
system("/tmp/test");


```

/tmp/test.c

```
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc, char *argv[])
{
     int sockfd, newsockfd, clilen;
     struct sockaddr_in cli_addr;
     clilen = sizeof(cli_addr);
     //直接使用5 fd作为socket句柄，原文中是fd号为0
     sockfd = 5;

     //这里accept会阻塞，接受连接后才会执行system()
     newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
     system("/bin/touch /tmp/lol");
     return 0;
}


```

编译后，访问 index.php。发现被阻塞了。此时访问 fpm 的任意文件，test 进程接收到 socket 连接，执行 system()。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69VAEP1EhAoRCQMFpBu5uYAwBoDxHJBJDRkrj5TbM2ianiblRO29RiaVjrqg/640?wx_fmt=png&from=appmsg)

**还有一点，test 进程在 / proc / 下面的文件所属用户是 www（php-fpm 的运行用户）而不是 root（php-fpm 的 master 进程所属用户为 root），也就是说子进程继承的 worker 的运行权限。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69VSmO9ZadIgwiamDJEb2UwHm2CgxpFoFyCHBlVJF0MVJwQ7OOhdpUPqicA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69VqDP7a9I92ZPHvIcV9DcG584woRM3N7zSicg5KJYictqx3XNszB7ZFM4Q/640?wx_fmt=png&from=appmsg)

**二、利用方式**
----------

**我们的终极目标是，在 php 中建立一个 socket，通过该 socket 操作 php-fpm 的 socket。**

测试一下，在 php 中建立一个 socket：

```
<?php
// t3.php
sleep(10);
$socket = socket_create( AF_INET, SOCK_STREAM, SOL_TCP );
sleep(10);


```

原本的 worker 只有 0 1 2 5 四个 FD。

php 脚本新建 socket 后，多了一个 3 号 FD（其实测试 socket 阻断那里就已经发现是 3 号 FD 了），也就是说我们通过一个子进程将 5 号 FD 复制到 3 号 FD，即可实现通过该 socket 接管 php-fpm 的 socket。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSHdXIG3sRhfyIxiag4ODw69Vk1RYp45YJru8jr6VSibZuRibgzFVibZuKCY4Vwmib8XFzDHKxCUfW2schw/640?wx_fmt=png&from=appmsg)

完成代码可见原文，这里不再赘述。下面分析下具体思路：

1.  php 脚本运行后先删除自身
    
2.  php 脚本创建一个 socket，并获取 FD 号。
    
3.  php 脚本调用 system() 建立一个子进程，该子进程会继承 worker 运行权限。
    
4.  子进程 attach 到父进程 (php-fpm worker)，向父进程中注入复制 FD 的 shellcode（shellcode 作用为调用 dup2 命令，将 php-fpm socket 的 FD 号，复制到 php 创建的 socket 的 FD 号（在我的测试中就是 5 号复制到 3 号）。
    
5.  子进程恢复 worker 进程状态后 detach，退出。
    

整个过程完成后，php 代码中的 socket 即可操作 php-fpm 的 socket。

如想完成 webshell 功能，可以解析请求 fast-cgi 请求，如果包含指令，拦截并执行。

否则正常转发到 9000 端口让正常的 worker 处理即可。

**三、总结**
--------

该方法虽然实现了对 php-fpm 的无文件攻击，但是个人觉得局限性较高，利用场景可能比较局限：

*   环境的限制：只能在 linux、php 版本 (5.x<5.6.35，7.0.x<7.0.29，7.1.x<7.1.16，7.2.x<7.2.4) 下利用。
    
*   攻击 php-fpm work 本身的限制：生产环境中 php-fpm 的 worker 进程众多，fast-cgi 请求能被污染后的 worker accept 接受到的概率很低。
    
*   php-fpm socket FD 号并不固定，个人觉得加个遍历比较好。
    

除此之外，子进程向 worker 进程注入 shellcode 的操作应该有更优雅的姿势，希望师傅们可以关注下。

相关代码完善后会同步至 github。

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！  

**如果你是一个网络安全爱好者，欢迎加入我的知识星球：zk 安全知识星球, 我们一起进步一起学习。星球不定期会分享一些前言漏洞，每周安全面试经验、SRC 实战纪实等文章分享，微信识别二维码，只需 25，即可加入，如不满意，72 小时内可在 App 内无条件自助退款。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGpTtick8dYImTUOcmaQWHRzkPIp7SwgncysYUIo0cKZAcHvXcMEBL5ZZEJCIpUP08SGOR8bnejDxQ/640?wx_fmt=other&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSE3xxjQrLXjiaAWoqibdM1AFZ0uePzzUOG049bSjeEkbft1NfIm833fQ0ibIbW5IoE2ftnWoS3YxRPLg/640?wx_fmt=other&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp)