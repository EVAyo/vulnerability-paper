<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/1dkxhwySQ6auHUAur8Zp-w)

_**免责声明：**_

_本公众号致力于安全研究和红队攻防技术分享等内容，本文中所有涉及的内容均不针对任何厂商或个人，同时由于传播、利用本公众号所发布的技术或工具造成的任何直接或者间接的后果及损失，均由使用者本人承担。请遵守中华人民共和国相关法律法规，切勿利用本公众号发布的技术或工具从事违法犯罪活动。最后，文中提及的图文若无意间导致了侵权问题，请在公众号后台私信联系作者，进行删除操作。_

**0x00 序言**

  

在 Java 安全中，Agent 的利用愈发重要，例如内存马技术、IAST 灰盒扫描、RASP 防御技术等都利用了 java agent 的特性，本系列将分两部分详细介绍 Java agent 的两种代理原理，分别为静态代理和动态代理，同时将用详细的代码 Demo 来进行实验。文中使用的完整实验代码将放到小密圈供下载，感兴趣的同学可加小密圈下载。

**0x01 Agent 简介**

  

在 Java 中，Agent 是一种可以在 Java 应用程序运行时修改或监视类和字节码的工具。Java Agent 可以通过两种方式加载：静态 Agent 加载和动态 Agent 加载。本文先从静态加载说起，静态 Agent 加载是一种将 Agent 注入到 Java 应用程序中的一种方式，它在应用程序启动之前加载 Agent。这种加载方式通常需要在应用程序启动命令中指定一些特殊参数，以便 JVM 在启动时加载 Agent。

*   静态 Agent 加载是在 Java 应用程序启动之前加载 Agent 的一种方式。它需要在启动应用程序的命令行中指定特殊的参数。
    
*   以下是一个使用静态 Agent 加载的示例命令行：
    

```
java -javaagent:/path/to/agent.jar -jar myapp.jar

```

*   _-javaagent 参数后面跟着代理程序的 JAR 文件路径。_
    
*   _-jar 参数后面是要运行的主应用程序的 JAR 文件。_
    

*   JVM 在启动时会加载指定的 Agent，并在应用程序运行期间执行 Agent 的代理操作
    
*   Agent 的作用分为下面几类
    

*   _类字节码转换：Agent 可以重定义或修改应用程序类的字节码，以实现功能增强或监控。_
    
*   _类加载监控：Agent 可以监控应用程序中的类加载事件，记录类加载信息。_
    
*   _方法拦截：Agent 可以在方法调用前后执行自定义代码，用于记录日志或执行其他操作。_
    
*   _性能分析：Agent 可以用于分析应用程序的性能，收集性能数据以进行优化。_
    

**0x02 静态 Agent**

  

要写一个静态 Agent，就必须实现一个公共的 premain 方法，该方法用于在 Java 应用程序启动时加载代理，并进行初始化。

```
public static void premain(String agentArgs, Instrumentation inst)

```

premain 方法是 Java 代理程序的入口点，它必须满足以下要求：

*   方法必须是 public、static、void 类型的。
    
*   方法名称必须是 premain。
    
*   方法必须接受一个参数，类型为 String。这个参数包含了代理程序的启动参数，通常是代理程序的 JAR 文件路径。
    
*   参数 agentArgs ：这是一个字符串参数，它允许你向代理程序传递配置或其他参数。你可以在代理程序中解析这个参数，并根据需要使用它来配置代理行为。
    
*   参数 Instrumentation inst ：这是一个 Instrumentation 对象，它是 Java Instrumentation API 的一部分。它允许代理程序与 Java 虚拟机（JVM）交互，进行字节码操作、类加载的监控等操作。
    

*   _使用 Instrumentation 对象，你可以在类加载之前或之后对类进行修改，比如在类加载之前添加字节码、修改类的字段、方法等。_
    
*   _通过 inst.addTransformer() 方法，你可以注册一个字节码转换器（ClassFileTransformer），用于在类加载时转换字节码。这允许你对指定的类进行字节码操作。_
    
*   _你可以使用 inst.retransformClasses() 方法来重新加载已经加载的类，以便重新转换它们的字节码。_
    
*   _通过 inst.getAllLoadedClasses() 方法，你可以获取当前已加载的所有类的列表，以便监控类加载情况。_
    

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybGKeiaE4d1q6lqxGWqAr6icpY84W61LGiczzibuiaoC4ZzE0ubmLeibJ1llC1M0iasaN8RB8WFHGGGA1S28A/640?wx_fmt=png)

基于上述 premain 的介绍本次 Demo 中可以有下面两种写法

写法一：

```
public static void premain(String agentArgs, Instrumentation inst) {
        System.out.println("agentArgs: " + agentArgs);
        inst.addTransformer(new DefineTransformer(), true);
    }
static class DefineTransformer implements ClassFileTransformer {
        @Override
        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
            System.out.println("premain load class: " + className);
            return classfileBuffer;
        }
    }

```

写法二：

```
 public static void premain(String agentArgs, Instrumentation inst) {
        System.out.println("agentArgs: " + agentArgs);
        inst.addTransformer(new MyClassTransformer(), true);
    }

```

**0x03 Demo**

  

有了上述的基础知识介绍后，我们需要写一个 Demo 来进行实验。本次使用的是 IDEA 创建的 maven 项目来管理的。

首先我们需要写一个 Java 主进程，该进程用来加载外部的 agent。

我们写的是一个简单的加法运算过程，其中调用了 add 方法进行运算并打印。  

主进程：

```
 public static void main( String[] args )
    {
        try{
            System.out.println( "main start!" );
            myTester test = new myTester();
            Date d = new Date();
            System.out.println(d.getTime());
            int x1 = 1;
            int x2 = 2;
            while(true){
                System.out.println(Integer.toString(test.add(x1, x2)));
                Thread.sleep(2000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            System.out.println("main end");
        }
    }
    private int add(int x1, int x2){
        return x1+x2;
    }

```

接下来我们需要写一个 Agent，在上面的介绍中我们提到了 premain 函数，我们需要在 premain 函数使用 Instrumentation 增加一个 transformer。当监控的 java 应用每次加载 class 的时候都会调用 transformer。下面例子中的 MyClassTransformer 是一个 transformer，是 ClassFileTransformer 的实现。在它的 transform 函数的入参中会给出当前加载的类名，类加载器等信息。

我们在加载时判断当前加载的类是否是我们的测试类，如果是的话，在上述主进程中修改 add 函数，将其中的相加过程修改为 {return $1 + $2 + 100;} 也就是多加 100。

```
  @Override
        public byte[] transform(final ClassLoader loader,
                                final String className,
                                final Class<?> classBeingRedefined,
                                final ProtectionDomain protectionDomain,
                                final byte[] classfileBuffer) {
            if ("com/test/agentTester/myTester".equals(className)) {
                try {
                    // 从ClassPool获得CtClass对象
                    System.out.println("start modify class bytes !!!!!!!!!!!!");
                    final ClassPool classPool = ClassPool.getDefault();
                    final CtClass clazz = classPool.get("com.test.agentTester.myTester");
                    System.out.println(clazz);
                    //打印App类中的所有成员函数
                    CtMethod[] methodList = clazz.getDeclaredMethods();
                    for(CtMethod method: methodList){
                        System.out.println("premain method: "+ method.getName());
                    }
                    // 获取add函数并替换，$1表示函数的第一个入参
                    CtMethod convertToAbbr = clazz.getDeclaredMethod("add");
                    String methodBody = "{return $1 + $2 + 100;}";
                    convertToAbbr.setBody(methodBody);
                    // 在add函数体之前增加一段代码，同理也可以在函数尾部添加
                    methodBody = "System.out.println(Integer.toString($1));\nSystem.out.println(Integer.toString($2));";
                    convertToAbbr.insertBefore(methodBody);
                    // 返回字节码，并且detachCtClass对象
                    byte[] byteCode = clazz.toBytecode();
                    //detach的意思是将内存中曾经被javassist加载过的Date对象移除，如果下次有需要在内存中找不到会重新走javassist加载
                    clazz.detach();
                    return byteCode;
                } catch (Throwable ex) {
                    System.out.println("something wrong??????????");
                    System.out.println(ex.getMessage());
                    ex.printStackTrace();
                }
            }
            // 如果返回null则字节码不会被修改
            return null;
        }

```

同时由于我们使用的是 pom.xml 进行配置，所以在编译前下面的配置非常重要，否则无法进行字节修改。

```
<manifestEntries>
       <bootclasspath>lib/javassist.jar</bootclasspath>
       //这个配置项指定了代理程序的入口类，即包含 premain 方法的类。在启动 Java 应用程序时，JVM 将加载并调用这个类的 premain 方法，从而加载代理程序。
       <Premain-Class>com.test.myagent.MyAgent</Premain-Class>
       //这两个配置项分别用于启用代理程序对类的重新定义（Redefine）和类的重新转换（Retransform）
       <Can-Redefine-Classes>true</Can-Redefine-Classes>
       <Can-Retransform-Classes>true</Can-Retransform-Classes>
</manifestEntries>

```

随后我们先将 Agent 的 jar 打包

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybGKeiaE4d1q6lqxGWqAr6icpYH5gLMyvAss2zRqIiaabunwdAMptPc08FUYQQwwk4cCXs7AO8xfJFVcA/640?wx_fmt=png)

最后在 Demo 主进程中配置 agent 启动路径，指向该 agent jar 包  

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybGKeiaE4d1q6lqxGWqAr6icpYywtKzNicYXHyvfj0I9ME2jNRjf61Vicpk4UUW7iaCGY1t4pGsGIuWTcHA/640?wx_fmt=png)

启动主进程，下图中虽然打印了传入的参数是 1 和 2，但是最后计算结果是 103，证明我们之前添加的多加 100 已经成功注入。

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybGKeiaE4d1q6lqxGWqAr6icpYEB219FwO2HmMb63Q6PNSVd2vCKNuHT2OzEtVf3hOEpfPnDk6xuG73A/640?wx_fmt=png)

### 以上就是静态 Agent 注入的全过程，完整 Demo 已经放小密圈，需要的小伙伴扫描下方二维码获取吧。  

**加入我们  
**

  

后台回复 “加群” 或“小助手”，或扫描下方二维码加入我们的付费圈子，一起进步吧

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybHZicZnvXwW5LnL1bzhuJAoQ7MpUsy3BY3Cibl6curYWucSMSpxJicscm7zwWDWQaaiapo57oc6L5YH2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFMdnMAXpcyiaNPdyoLppiaPO7glCdCXn1WctQuslCotWHfH709HdYlkyYRK3BcTTzIE5UCw1vS1LJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)