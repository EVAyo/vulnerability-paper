<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/O37hkXHm7841l0UIQRpYTg)

在 Linux 内核中，可以通过分配对象来对 UAF、OOB 等漏洞对象进行占位进行漏洞利用。内核中有许多可利用对象，某些对象有非常强大的利用原语，可以通过这些对象及其操作函数来实现权限提升。本文对 Linux 可利用的对象进行了统计和总结。总结表格如下：

<table><thead><tr><th>结构体 / 系统调用名称</th><th>cache</th><th>大小 (bytes)</th><th>可泄露内核地址</th><th>可泄露堆地址</th><th>可泄露栈地址</th><th>可劫持 RIP</th><th>读写</th></tr></thead><tbody><tr><td>signalfd_ctx</td><td>kmalloc-8</td><td>8</td><td>❌</td><td>☑️</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>setxattr 系统调用</td><td>大小可变</td><td>size &lt; 65536</td><td>❌</td><td>❌</td><td>❌</td><td>☑️</td><td>✅</td></tr><tr><td>ldt_struct</td><td>kmalloc-16</td><td>16</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>shm_file_data</td><td>kmalloc-32</td><td>32</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>seq_operations</td><td>kmalloc-32</td><td>32</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>user_key_payload</td><td>大小可变</td><td>0x18 &lt;size &lt; (0x7fff + 0x18)</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>msg_msg</td><td>大小可变</td><td>0x30 &lt; size &lt; 0x1000</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>sendmsg 系统调用</td><td>大小可变</td><td>44 &lt; size &lt; 0x7fffffff</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>subprocess_info</td><td>kmalloc-128</td><td>96</td><td>☑️</td><td>✅</td><td>❌</td><td>☑️</td><td>❌</td></tr><tr><td>file</td><td>kmalloc-256</td><td>232</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>timerfd_ctx</td><td>kmalloc-256</td><td>216</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>tty_struct</td><td>kmalloc-1k</td><td>0x290~0x2e0</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>pipe_buffer</td><td>大小可变</td><td>0x28 &lt; size &lt;= 0x1000</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>☑️</td></tr><tr><td>packet_sock</td><td>大小可变</td><td>1024 &lt; size &lt; 2048</td><td>☑️</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>sk_buff</td><td>大小可变</td><td>512 &lt;= size</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table>

此外，在 IDA 分析过程中，kmalloc_trace 的参数 kmalloc_caches 常见大小区间如下（详细见内核源码 mm/slab_common.cz 中 kmalloc_caches 定义）：

```
 kmalloc_caches[3] /* 8 */
 kmalloc_caches[4] /* 16 */
 kmalloc_caches[5] /* 24 ~ 32 */
 kmalloc_caches[5] /* 32 */
 kmalloc_caches[6] /* 40 ~ 64 */
 kmalloc_caches[1]   /* 72 ~ 96 */
 kmalloc_caches[7] /* 104 ~128 */
 kmalloc_caches[2] /* 136 ~ 192 */

```

signalfd、signalfd4
==================

内核对象：signalfd_ctx

size：8

内核基址：无法泄露

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：无法劫持

产生：系统调用 signalfd、signalfd4

释放：无

示例：无

setxattr 系统调用
=============

内核对象：xattr_ctx->kvalue

size：size < 65536

内核基址：无法泄露

堆地址：无法泄露

栈地址：无法泄露

劫持 RIP：可以通过写入功能向内核写入数据，改写某些函数指针，间接控制 RIP。

产生：setxattr 系统调用，例如：`setxattr("/etc/passwd", "user.test", addr, 0x400, 1)`

释放：函数内部会进行释放。

示例：SECCON 2020 kstack 题目，writeup1：https://roderickchan.github.io/zh-cn/2022-04-28-seccon-2020-kstack/ ，writeup2: https://www.anquanke.com/post/id/266898

其他说明：setxattr 在函数内部 kvmalloc 申请后使用后随即将对象进行释放，因此需要使用 userfaultfd 或 FUSE 等利用技术来对分配对象进行占位。

ldt_struct
==========

内核对象：`struct ldt_struct`

size：16

内核基址：无法泄露

堆地址：无法泄露

栈地址：无法泄露

劫持 RIP：无法劫持

产生：可通过 modify_ldt 系统调用的 write_ldt 功能来分配空间并写入数据，通过 read 功能，并控制`ldt->entries`成员，即可读取任意地址的数据。

释放：无。

示例：TCTF/0CTF 2021 FINAL kernote 题目, writeup: https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote

其他说明：通常在全局变量 page_offset_base + 0x9d000 的地方存储着 secondary_startup_64 函数的地址，因此可利用 read 任意读泄露内核基址。

shm_file_data
=============

内核对象：`struct shm_file_data`

size：32

内核基址：可通过结构中的 ns 和 vm_ops 泄露内核地址。

堆地址：可通过 file 成员泄露

栈地址：不可泄露

劫持 RIP：无法劫持

产生：`shmat`系统调用

释放：`shmdt`系统调用

示例：RWCTF 2023 PWN digging into kernel 3 题目，writeup: https://blingblingxuanxuan.github.io/2023/02/06/230206-rwctf2023-digging-into-kernel-3/#msg-msg-shm-file-data-gt - 泄露内核地址

其他说明：在用户态中我们可以通过 `shmget`、`shmat`、`shmctl`、`shmdt` 这四个系统调用操纵共享内存。

seq_operations
==============

内核对象：struct seq_operations

size：32

内核基址：可通过泄露此对象中的函数指针来泄露内核基址。

堆地址：不可泄露

栈地址：不可泄露

劫持 RIP：修改此对象中的`start`函数指针，并调用`read(seq_fd, NULL, 0)`劫持 RIP。

产生：通过`fd = open("/proc/self/stat", O_RDONLY)`来分配。

释放：`close(fd)`

示例：InCTF 2021 国际赛 kqueue 题目，writeup1: https://bbs.kanxue.com/thread-269031.htm, writeup2: https://www.anquanke.com/post/id/258160

add_key 系统调用
============

内核对象：`struct user_key_payload`

size：(0x7fff + 0x18) > size > 0x18

内核基址：可泄露

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：无法劫持

产生：add_key 系统调用产生

释放：keyctl 的 KEYCTL_REVOKE 标志位可以将对象释放。

示例：2024 强网拟态 ker 题目，writeup：https://blog.xmcve.com/2024/10/20 / 强网拟态 2024-Writeup/#title-9

其他说明：在使用 keyctl 系统调用时，KEYCTL_UPDATE 可以分配一个临时对象将用户数据拷贝至内核，随后释放。KEYCTL_READ 可以读取 payload 的内容，KEYCTL_UNLINK 可以释放整个 key。

msg_msg
=======

内核对象：`struct msg_msg`

size：0x1000 > size > 0x30

内核基址：无法泄露

堆地址：可通过 list 或 next 成员泄露

栈地址：无法泄露

劫持 RIP：通过篡改结构体 m_ts 成员值实现越界读写，堆风水间接控制 RIP。

产生：通过`msgget`创建消息队列，调用`msgsnd`生成 msg_msg 对象。

释放：通过`msgrcv`系统调用接收队列消息并释放对象。

示例：D^ 3CTF2022 d3kheap 题目，writeup：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/

其他说明：在 msgrcv 中使用 MSG_COPY 来读取队列消息但不进行释放，正好可以用于判断是否命中堆喷对象。

sendmsg
=======

内核对象：`unsigned char ctl[sizeof(struct cmsghdr) + 20] __aligned(sizeof(__kernel_size_t));`

size：0x7fffffff > size > 44

内核基址：无法泄露

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：无法直接劫持。

产生：`sendmsg`系统调用，数据放入 msg.msg_control 指针。

释放：与产生路径相同。

示例：https://blog.csdn.net/panhewu9919/article/details/100637619

其他说明：与`setxattr`相同，可与 userfaultfd 结合使用。

subprocess_info
===============

内核对象：subprocess_info

size：96

内核基址：由于没有任何内核与用户数据交互，需要通过竞争来泄露内核基址

堆地址：可泄露

栈地址：不可泄露

劫持 RIP：通过竞争来修改 cleanup 函数指针，然后触发执行`if (info->cleanup) info->cleanup(info)`

产生：创建一个未知协议（`socket(22, AF_INET, 0)`）时，便会创建一个 `subprocess_info` 结构体。

释放：在系统调用结束之后该结构体便会被立即释放。

示例：SCTF2021 - flying_kernel，writeup：https://www.anquanke.com/post/id/264563

file
====

内核对象：`struct file`

size：232

内核基址：可以通过 f_op 字段泄露内核地址

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：重写`f_op`中的`shmctl`来控制

产生：`shmget`创建共享内存

释放：`shmctl`

示例：无

timerfd_ctx
===========

内核对象：`struct timerfd_ctx`

size：kmalloc-256

内核基址：可以通过 timerfd_ctx 的 tmr 字段的 `function` 字段泄露内核地址

堆地址：可通过`base`成员泄露

栈地址：无法泄露

劫持 RIP：无法劫持

产生：通过 `timerfd_create` 系统调用来分配一个 `timerfd_ctx` 结构体

释放：无

示例：CUCTF 2020 Hotrod 题目，writeup：https://syst3mfailure.io/hotrod/

tty_struct
==========

内核对象：tty_struct

size：大小在 0x290~0x2e0 之间，不同版本的内核此结构体大小有变动。

内核基址：可通过`const struct tty_operations *ops` 成员泄露

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：通过劫持`const struct tty_operations *ops`中的函数指针实现

产生：打开一个控制终端，例如：`fd = open("/dev/ptmx", O_RDWR | O_NOCTTY)`

释放：`close(fd)`

示例：强网杯 2021-notebook

其他说明：tty_struct 的魔数为 `0x5401`，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体。

pipe_buffer
===========

内核对象：struct pipe_buffer

size： kmalloc-1k

内核基址：通过 pipe_buffer 的 pipe_buf_operations 泄露内核地址

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：在关闭管道时会调用`pipe_buffer->pipe_buffer_operations->release`函数指针，因此可劫持`release`来劫持 RIP

产生：pipe 和 pipe2 系统调用

释放：close 关闭管道

示例：D^ 3CTF2022 d3kheap 题目，writeup：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/

其他说明：pipe_buffer 大小并非固定的 1k，可以通过设置`F_SETPIPE_SZ` 来重新分配 pipe_buffer 并指定其数量。这一步骤可以通过`fcntl`系统调用重新分配单个 pipe 的 pipe_buffer 数量，从而实现近乎任意大小的对象分配 ，但需要是 `pipe_buffer` 结构体的 2 次幂倍。此外，若能够修改 `page` 指针，则我们便能完成对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作。

packet_sock
===========

内核对象：`struct packet_sock`

size：1024 < size < 2048，不同内核版本此结构体大小不同

内核基址：通过越界读写间接获取内核基址

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：packet_sock -> rx_ring -> prb_bdqc -> retire_blk_timer -> function。在 timeout 超时后调用，可传参，可用于执行 native_write_cr4(0x406e0) 来关闭 SMEP/SMAP。packet_socket -> xmit。在接收数据时调用。

产生：分配 packet_socksocket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP)); —— sock(AF_PACKET) -> packet_create -> sk_alloc，setsockopt(fd, SOL_PACKET, PACKET_RX_RING, (void*)&tp, sizeof(tp)); —— packet_set_ring()->init_prb_bdqc()->prb_setup_retire_blk_timer()->prb_init_blk_timer()。

释放：

示例：https://bsauce.github.io/2021/05/19/CVE-2017-7308/

sk_buff
=======

内核对象：`struct sk_buff`

size：size >= 512

内核基址：无法泄露

堆地址：可泄露

栈地址：无法泄露

劫持 RIP：无法直接劫持

产生：对 socket 一类的操作都会创建 socket，可以通过`socketpair`创建一对 socket，从一段发送，另一端读出。

释放：从 socket 读出数据以释放对象。

示例：D^ 3CTF2022 d3kheap 题目，writeup：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/

References
==========

https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628

https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II