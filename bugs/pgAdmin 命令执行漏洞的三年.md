<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/76erd_c0zFfpcTDWzqDxwg)

前几天看到 pgAdmin 发布了新漏洞，《**CVE-2024-3116 – Remote Code Execution Vulnerability in pgAdmin - PostgreSQL Tools (<=8.4): Detailed Analysis Report**》。看了这个漏洞利用的过程，我总感觉有所不对，我也在『代码审计』知识星球里发表了相关疑问。随后，我研究了一下这个漏洞的来龙去脉，简单写下这篇短文。

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGry08w5JBgEt86z3q4MxLhTAzaZLsCNoaoWaeGuxib1HQtHTvLmyPJF5Q/640?wx_fmt=png&from=appmsg)

CVE-2022-4223：pgAdmin <= 6.16 未授权命令执行漏洞
---------------------------------------

最新的 CVE-2024-3116 漏洞，其利用到了`/misc/validate_binary_path`这个 API。这个 API 出现问题不是第一次了，最远的追溯到几年前 CVE-2022-4223 这个未授权命令执行漏洞。

CVE-2022-4223 是一个非常简单的漏洞，我甚至觉得有可能是一个后门。

pgAdmin 支持在后台设置 psql、pg_dump、pg_restore 等 PostgreSQL 数据库工具所在的基础路径，在保存设置前，用户可以执行`validate_binary_path`这个 API 来检查路径是否合法。

检查的过程就是，用户传入路径，然后 pgAdmin 分别给这些路径拼接上 “psql”、“pg_dump” 等可执行文件名，并执行`psql --version`命令。如果返回结果是正常，则说明文件存在，用户路径合法；如果返回结果出错，则说明文件不存在，用户传入的路径不合法。

`validate_binary_path`API 代码如下：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrnr5kRXzic8m1F2dPaMNR4HJ573dgBYhBlxlcnFlk8L418NicyStYNEHw/640?wx_fmt=png&from=appmsg)

可见，这里用户传入的`utility_path`拼接上可执行文件名后，直接拼接进`subprocess.getoutput()`方法执行。这是一个非常简单的命令注入漏洞。

而且这个 API 没有增加`@login_required`修饰器，任意用户均可调用这个函数，导致了未授权命令执行漏洞。

漏洞复现的过程可以参考 Vulhub 中的环境：**https://github.com/vulhub/vulhub/tree/master/pgadmin/CVE-2022-4223**

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrMrDDh33ohq0sXuUB9UI8icicicMDKwvuYpX3wX4q4dnXFVAqmWhNWEcrw/640?wx_fmt=png&from=appmsg)

CVE-2023-5002：pgAdmin <= 7.6 后台命令执行漏洞
-------------------------------------

官方对于 CVE-2022-4223 漏洞，做了如下两个处理：

*   给`validate_binary_path`函数增加`@login_required`装饰器，限制未授权的用户访问相关接口
    
*   使用`os.path.exists()`检查用户传入的路径是否有效
    

`@login_required`装饰器是由 Flask-Login 这个第三方库提供的能力，并不存在绕过的问题，所以这个 API 后续就没法再无授权的情况下利用了。

对于使用`os.path.exists()`检查用户传入的路径是否存在，我们可以想到下面两个绕过方法：

*   使用`../`跳转到一个存在的目录，如：`/path/to/exist/folder/a";id;/../`
    
*   通过文件上传等功能创建一个文件名中包含 Payload 的文件
    

第一个问题其实是一个经典问题，在『代码审计』星球创建之初就讨论过：**https://t.zsxq.com/19Cfkp0b1**。当时虽然是使用 PHP 的做演示，但实际上答案在 Python 中是一致的：**判断文件存在时，Windows 会将路径 normalize 后再判断，Linux 会逐级判断文件夹是否存在**。

所以，表现出来的结果就是，下面代码在 Windows 环境下会返回 True：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrG8tIW6kWbIOT1hiaQuYT4XCK9yNQaWDWbiaj9ZxfOcOmugK7VsjaA9bA/640?wx_fmt=png&from=appmsg)

在 Linux 环境下会返回 False：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrnrX0PMWtUvtK45ey2RgCWyCknfGFmQjiaqGYfkGx22ZygMC96yxV6Jw/640?wx_fmt=png&from=appmsg)

所以对于 CVE-2022-4223 的补丁，在 Windows 环境下我们可以直接绕过`os.path.exists()`继续注入命令，但 Linux 下需要想想其他方法。

pgAdmin 后台提供了一个文件管理器，在菜单的 “Tools -> Storage Manager” 中：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrYEgZtUy0b8AKr8wqIPnzcAZwdmNBp0XibrOSwnVe5NfGv2usXeHIiaVw/640?wx_fmt=png&from=appmsg)

这个文件管理器具有上传、删除、创建目录等功能，用户上传的文件均位于其个人 storage 目录下，默认情况下这个基础目录是固定的。这个绝对目录可以通过上传文件来获取，随便上传一个文件，即可获取到完整路径，比如我这里是`/var/lib/pgadmin/storage/vulhub_example.com`：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrdQMh2Nf9F2WWibzW15HstcDZGiculVA36XUHe8ticYjDhIkUPOlEJAPfg/640?wx_fmt=png&from=appmsg)

然后创建或上传一个新文件，文件名是我们的 payload：`";id;#`：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGr8JJERSia4Tx4NrTMk53WaQ0kATEAdXwCeHWsKAdsy2nYFCbWqpnSoXQ/640?wx_fmt=png&from=appmsg)

最后拼接出的绝对路径为`/var/lib/pgadmin/storage/vulhub_example.com/";id;#`，这个文件存在可以绕过`os.path.exists()`，并传入`subprocess.getoutput()`执行的完整命令是：

```
"/var/lib/pgadmin/storage/vulhub_example.com/";id;#" --version


```

在设置中填写完整路径，并点击右侧的 “validate”：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGryooCX1fTMvaykCAowyIo2JH3SHdpp65r9iaBvBdRicWZnInOic11h5Ihw/640?wx_fmt=png&from=appmsg)

命令被成功执行：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrnS4m3efYMvUglpJR6MoCucicuNibJq1ZoXf5PjoaazjCxibAwQFGKOnwA/640?wx_fmt=png&from=appmsg)

这个漏洞的完整复现过程和环境也可以在 Vulhub 上找到：**https://github.com/vulhub/vulhub/tree/master/pgadmin/CVE-2023-5002**

CVE-2024-3116：pgAdmin <= 8.4 后台远程命令执行漏洞
---------------------------------------

那么说回到本文开头的漏洞，CVE-2024-3116 漏洞其实仍然是之前漏洞没有修复完成导致的。对于 CVE-2023-5002，pgAdmin 官方的修复方法还算比较正常，就是将`subprocess.getoutput()`改成`subprocess.run()`，且`shell=False`：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrBXILyOcVNHofP68Z1rf5lZ3L2O0HI5tSicxDek3WYjFAonib5r2QUKCw/640?wx_fmt=png&from=appmsg)

此时用户控制的就是`subprocess.run()`中命令列表的文件名位置，虽然无法继续进行命令注入了，但因为这里仍然执行了用户输入的文件，如果我们上传一个文件名是 “psql” 的可执行文件，是否可以仍然执行任意代码？

本文开头说的文章就是这个思路：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGr9OWItXzWfIswZk35HOeSrHYnROhI7NhR7cFYcZHZtKhgwMYvuTkZZA/640?wx_fmt=png&from=appmsg)

首先在本地编写一个恶意的 C 程序，并使用上一章中提到的方法将其上传到个人目录下，并改名为 psql。

接着在`validate_binary_path`API 中传入这个 psql 文件的绝对路径，进入`subprocess.run()`下执行，完成漏洞利用。

但这里没有提到的重要一点是，**可执行权限**。在 Linux 下，如果一个文件没有执行权限，是不能直接被执行的。所以，上述文章中给出的那个运行在 Linux 下的 C 程序（使用 curl 来验证漏洞是否存在），是肯定无法执行的，不知道作者是如何复现漏洞的。

当然，在部分 Windows 环境下没有非常严格的文件权限机制，上传一个 psql.exe 文件即可被执行。所以，这个漏洞其实只能影响 Windows 环境。

由于 CVE-2024-3116 这个漏洞的利用条件比较苛刻，我也没有制作 Vulhub 环境来复现。后来原文的作者好像也意识到了他文章中的问题，于是发布了新的文章《**CVE-2024-3116 – Remote Code Execution Vulnerability in pgAdmin - PostgreSQL Tools (<=8.4): Detailed Analysis Report**》，将其中 Linux 相关的内容改成了 Windows：

![](https://mmbiz.qpic.cn/mmbiz_png/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrg30lj3bibWHzKriclZwCXCQHHqD1Vf9LFnXnYmP26kE7B5bTdRITrk4Q/640?wx_fmt=png&from=appmsg)

有兴趣的同学可以参考他的文章做复现。

总结
--

最后总结一下，这个文章分析了 pgAdmin 在同一个 API 上跨越了三年的三个漏洞（CVE-2022-4223、CVE-2023-5002、CVE-2024-3116）。其中影响最大的也还是第一个未授权命令注入漏洞，可以让攻击者在无需任何权限的情况下在 pgAdmin 中执行任意命令。

![](https://mmbiz.qpic.cn/mmbiz_gif/5AsxricGekWg0wEf8JlicsnRdXxIxx9Kg12f9CnBF65ZlVab02ZDOcGibibibItR4ebCCeAsAZoVXibicwCBKttGZ4euA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&tp=webp)

喜欢这篇文章，点个**在看**再走吧~

加入「代码审计」，学习更多安全知识。**一次付费，终身学习免续费**。

![](https://mmbiz.qpic.cn/mmbiz_jpg/5AsxricGekWjhianqFicmRY8ePmeYyRZuGrknxzzGncGXvoo0BBOPLf83rKAxjlZBPyGfFJtRBaL6M8hhJEDSfVfA/640?wx_fmt=jpeg&from=appmsg)