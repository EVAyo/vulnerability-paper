<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/cPUaDQaCWpZiBEgZqbqvPg)

**一**

**前 言**

**WebAssembly（简称 wasm）是一种可移植、体积小、加载快并且能够在浏览器上运行的一种程序文件**。其能够在 JavaScript 通过接口进行调用执行。开发者们一直都比较关心 JS 的运行速度问题，V8 引擎在 JS 的运行速度方面做了巨大的优化，但是少数情况下我们进行大量本地运算的时候，仍然可能遇到性能瓶颈，这个时候 webassembly 的作用就凸显出来了。例如 AutoCAD 利用编译器将其沉淀了 30 多年的代码直接编译成 WebAssembly，同时性能基于之前的普通 Web 应用得到了很大的提升。

C/C++/Rust 源代码可以被编译为 WebAssembly 文件，然后 JS 层就可以对其进行调用。WebAssembly 文件中存储着字节码，位于 JavaScript 引擎中的 WebAssembly 虚拟机将会执行字节码。字节码的执行有两种方式，一种是在运行时边读取 opcode 边执行，另一种则是在执行前将整个 WebAssembly JIT 翻译为本地汇编代码，然后直接跳转到汇编代码执行。V8 采用的是第二种方式。

**二**

**WebAssembly 虚拟机**

WebAssembly 虚拟机是一种栈虚拟机，变量使用栈进行传递。WebAsse  mbly 虚拟机有两个栈，即**数据栈**和**指令栈**。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yr5LwNFZ0gBIouSc0ZHVnSHuibG4Ciaic31K0UPScgguYicGiblnUdzv8XicQA/640?wx_fmt=png&from=appmsg)

WebAssembly 的数据栈只用于存储数据，**不会存储任何指针**；指令栈只用于存储指令和数据在数据栈中的**下标**，**不会存储任何数据**，并且在执行 opcode 时会对取出的下标进行边界检查。由于 WebAssembly 将数据和程序流用栈给分隔开了，也就不会发生像汇编代码中的栈溢出劫持返回地址的漏洞利用手法。简而言之，WebAssembly 中的所有指令都无法操作指针，也就不存在任意地址读写。但是传统的漏洞仍然存在，只是不能直接劫持程序流了。

**三**

**WebAssembly 文件格式**

编译代码 emcc hello.c -s WASM=1 -o hello.html

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrhhACRsRyxcnFPePlKjtm8C8AiaEvI5ibRSAm8acy8Qa8aibkIPLjEIPzA/640?wx_fmt=png&from=appmsg)

将得到的 hello.wasm 使用 wabt 项目中的 wasm2wat 转为 S 表达式 `./wasm2wat hello.wasm > hello.wat` S- 表达式是一个非常简单的用来表示树的文本格式，跟 wasm 二进制文件是简单的对应关系。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yr38S5R0icCVGOEDsGP15NQ6XR3lpPXKU2ZiaDGI8ISo8NCWP4icnDASHJQ/640?wx_fmt=png&from=appmsg)

使用 010-Editor 打开 hello.wasm 文件，可以看到对应的结构：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrdnUwibLktTCcpER1XwPcr7tCl3YO3zZ2CliaibDuIch6hDhg9knOGnk6Q/640?wx_fmt=png&from=appmsg)

S 表达式和 WASM 二进制之间是简单的翻译关系。由于 S 表达式的比较容易理解，在逆向 WASM 时可以直接阅读 S 表达式。

**四**

**传统漏洞模式在 WebAssembly 中的变化**

**01**

**格式化字符串**

  

编译代码 emcc hello.c -s WASM=1 -o hello.html

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yribb0pc00dyo0lpXBX7JJicWOGOY5W7yp7Yhp6YuRk4rk6TKgptMJMRpA/640?wx_fmt=png&from=appmsg)

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrGXhOAC6rfeS9wicvRRatxIm0Vu62BkukVJ8UWBUDFNHjiclO6vSLPoRg/640?wx_fmt=png&from=appmsg)

编译后查看 S 表达式，我们重点关注一下 S 表达式的 import 表，这是 WASM 用于导入外部函数、库函数用的，有点类似于 ELF 的 GOT 表，不同的是 import 表即可以导入 WASM 虚拟机实现的内部的库函数，还能导入用户用 JS 写的函数。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrjCPXibaEice3oY0nSO8R53ibsdIKibFVhUvMWlIOTZ8GJ7XEEl9VGJAK0A/640?wx_fmt=png&from=appmsg)

在这里我们没有看到 printf，该函数被编译进了 WASM。通过测试，格式化字符串漏洞仍然存在，`%p%p%p%p%p%p%p%p%p%p%p`能够泄漏出一些数据，但是运行结果并未泄漏出栈上的 buf，这跟 printf 在不同的 WebAssembly 编译器中实现有关。

**02**

**堆溢出**

  

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQ7z9Fsfhp2P7cdx2aqgibuVSPMr4O8OqJiaJnWHciavb3aK9mbJwKlATaxV5cyXOeqUkDTroILokqdg/640?wx_fmt=png&from=appmsg)

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrBU7rEktglhibPkAKic6j0WeFDLIMI2iaaG81m6ic6s1RFx0FaF8XET1ibdw/640?wx_fmt=png&from=appmsg)

堆溢出仍然存在，可以覆盖堆中的数据。根据前面的介绍，WASM 数据区不可能存储指针，因此结构体中的 f 函数指针实际上是一个偏移值，可以利用溢出覆盖偏移值，进而能够去执行其他的 wasm 函数。但是这里无法像汇编那样能够跳转到任意函数以及 gadgets，这里只能跳转到在函数表 (func 表) 中存储的函数。

**03**

**栈溢出**

  

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrdUCVs766iayjlvu2fmvdlIJmibpic9pYP4uspmWwytXWemr0ADR5nl7nA/640?wx_fmt=png&from=appmsg)

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrQUSKlznPbLQkf14cjqkqfhzF2Vm8ZBq0kKzOHS8wm0Tg3lrRVbaBsg/640?wx_fmt=png&from=appmsg)

栈溢出与堆溢出类似，可以覆盖后方的一些数据结构，有函数指针的话可以覆盖函数的 index，但是返回地址没有保存在数据栈中，因此不影响程序的返回执行。与汇编不同的是，WASM 的栈空间溢出会把 **前面的变量覆盖**，这是因为 WASM 开辟栈时是按照代码顺序来的，遇到 node 时，先压栈，遇到 buf 时，再压栈，这也就会导致 buf 在 node 的内存前面，可以覆盖到。

**04**

**数组越界**

  

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrlBtoLhFSL3kRCarkyo274tqS2iajm4KHwsVDPj4ZfAHgAiahkdzOTn9A/640?wx_fmt=png&from=appmsg)

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrfQrTibTKF52N4nqsAsoE27gbXnTZDxalsktxyBzF4qGGdLXhbdOfc2A/640?wx_fmt=png&from=appmsg)

数组越界可以泄漏数据区的任何数据，但是只会限定在数据区，因为下标的上下限就是数据栈的边界，这种边界检查在对应的访存 opcode 的 handler 中会进行。

**五**

**WebAssembly 的一些利用思路**

**01**

**前端 XSS**

  

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrF87cALEDaWbARDu0jnVaqCzWpktexNtEWC86T78uiclACrR2Rpibv3GA/640?wx_fmt=png&from=appmsg)

输入`aaaaaaaaaaalert('hacked');`，可以将`emscripten_run_script`的参数覆盖，执行任意的 JS 代码。

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrUPwbWI9sULibM1kOic1hT96Y5Q9Lb5ibBvaHImN9eRWJMfiaUPn8Ej1wCw/640?wx_fmt=png&from=appmsg)

如结果所示，可以利用溢出覆盖一些能够执行 JS 脚本的函数的参数，当然也可以覆盖结构体中的函数偏移指向`emscripten_run_script`函数，并控制好参数去执行 JS 脚本。

**02**

**服务器端 RCE**

  

WebAssembly 不仅可以在浏览器中使用，还能够在服务器端被 nodejs 使用。与浏览器不同的是，nodejs 可以支持系统操作 API，例如`system`、`open`等函数，都能够在 nodejs 的`WebAssembly`中正常使用，那么就可以利用溢出等漏洞控制 **system 的参数**来达到命令执行 编译以下代码`emcc 1.c -o 1.js -s EXPORTED_FUNCTIONS="["_vuln"]" -s "EXTRA_EXPORTED_RUNTIME_METHODS=['ccall']"`。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrl72pcbwuXUJ0AY5zib5Hwy0L9GT1AvqqFPLX8ZzXHfLJicbjjbxQHv8w/640?wx_fmt=png&from=appmsg)

在 nodejs 中调用

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrOdz3odjVcsFVib1HcH7YWXDlzYwUrR7AsS5ongUjcAOgbjA48wy0FEA/640?wx_fmt=png&from=appmsg)

运行结果

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrqnekvTjcSkQAgEMUcylI4YLjgoWSdpyUWZtQibiaXptUnNjZuUvLW0lQ/640?wx_fmt=png&from=appmsg)

还可以利用漏洞改写函数偏移，指向 system 并控制好参数，主动执行命令。或者是 system 函数参数部分可控，则可以命令注入。

**03**

**思路总结**

  

首先需要关注 WebAssembly 附带的 js 文件，看看里面写了哪些导入和导出函数，如果是在 nodejs 中的 WebAssembly，要是导入函数中有一些能够操作系统的函数如 system、open 等，则重点关注，然后利用 wasm2wat 将 wasm 文件转换为 wat S 表达式，审计这些函数的参数是否存在或者可以注入等漏洞；要是有溢出漏洞，则看能否覆盖参数，或者覆盖函数偏移值。

**六**

**WebAssembly 虚拟机逃逸**

在 BlackHat USA 2022 的议题上我发表了一篇名为《Is WebAssembly Really Safe? - WasmVMEscape andRCEVulnerabilities Have Been Found in New Way》的议题，讲的就是 WebAssembly 的虚拟机逃逸。

WebAssembly 虚拟机逃逸漏洞重点关注三个方面：**字节码的执行漏洞、WASM 二进制结构解析漏洞、导入表库函数实现中的漏洞。** 这三个关注的是虚拟机的本身而不是位于虚拟机里的 WASM 代码，因此又可以回到传统漏洞模式的思路。

**01**

**CVE-2022-48503**

  

**漏洞信息**  

位于 Apple WebKit 的`Source/JavaScriptCore/wasm/WasmInstance.cpp`中，对 WebAssembly 进行加载解析时，`m_module->moduleInformation().dataSegmentsCount()`的值未检查大小，是直接从 WASM 文件中读取的，从而导致`dataSegmentIndex`可以越界。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrRfzMZIhR2SibmbRWURglibdAGXmXYUiaFKVIegnO0vhrJjuJwCjHESZEg/640?wx_fmt=png&from=appmsg)

**修复**

在`Source/JavaScriptCore/wasm /WasmSectionParser.cpp`文件中添加了一个`numberOfDataSegments > maxDataSegments`的检查。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrEic4mXUxWV0V3mVeqCCpvKngmF4VGOKqzY09czYOAORvxLP8WW2aFGg/640?wx_fmt=png&from=appmsg)

**02**

**CVE-2022-28990**

  

WebAssembly 的导入库函数是一个可研究的方向，导入函数可以从 wasm 转为 S 表达式后的`import`表中看到。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrsD1XN88yezBG5DkcuhzIWicLqB2Y4cRdTibvUvouIzGdNpw7UBf2SLNQ/640?wx_fmt=png&from=appmsg)

有的导入函数来自于 JS 层写的自定义函数，有的则来自于虚拟机自身实现的库函数。例如在上面我们看到`system`函数是从`env`导入的，而`fd_read`则是从`wasi_snapshot_preview1`导入的，对应的我们在 js 文件中看到。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrcPr9yeoxTFBvoD4LRqPVNGw4FzVngMicnw8V7RUBVl9Clh3xZcqV5kA/640?wx_fmt=png&from=appmsg)

可以看到 emcc 生成的 WASM JS 接口文件同时指定了`env`和`wasi_snapshot_preview1`表。实际上`wasi_snapshot_preview1`库是`WebAssembly System Interface(WASI)`标准的库，`WASI`是一套系统 API 接口，拥有像`fd_write`、`fd_read`、`sock_accept`等系统函数，某些 WebAssembly 虚拟机会在内部实现自己的一套 WASI，对于这种有自己实现 WASI 接口的 WebAssembly 虚拟机，在 JS 层就无需再去实现`wasi_snapshot_preview1`的导入函数。

Wasm3 是一款能够在嵌入式设备上运行的 WebAssembly 虚拟机，在嵌入式设备上使用 WebAssembly 的优点是可以做到类似于 Java 一样的**一次编译到处运行**，无需考虑嵌入式设备的底层适配。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrgd0BdkwxiaPkAndwic8FTOoyK8nRKYibMSgh76w7RsmmMGiafjTaHI5rxQ/640?wx_fmt=png&from=appmsg)

Wasm3 内部实现了`WASI`标准，而漏洞则出现在库函数`fd_write`、`fd_read`中。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrscHYkO2xUbxLmIkkVibDzajjibREeC7ZCVHCyia4Nr8reKAiaNibrEialr2w/640?wx_fmt=png&from=appmsg)

在函数`copy_iov_to_host`中，使用`m3ApiOffsetToPtr`对 WASM 字节码传过来的`offset`进行转换，即加上`_mem`的地址，得到要读取的目标地址，漏洞出现在没有对`offset`进行检查，可以传入任意的`offset`从而溢出`_mem`，实现任意地址写；同理，**fd_write 则可以实现任意地址读**如下的`POC`读取了`_mem + 0x10000`处的数据。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrTGsIqMKCNCVibwzC9618s27OEYC18GuTs7srmVRnlXhSjBTGv6IhRrA/640?wx_fmt=png&from=appmsg)

**03**

**Off by One in WasmEdge**

  

**漏洞分析**

WasmEdge 是另一款 WebAssembly 虚拟机。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yru2H1BxlpYTyzibDhMMUjI18h5cMKQaW0vJ5sgVkv8AzNvHdCYWe3UEQ/640?wx_fmt=png&from=appmsg)

在其迭代的开发版本中曾经出现过一个字节码的 off by one 漏洞。Executor::execute 函数是 WasmEdge 解释执行 WebAssembly 字节码的函数。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yruL4BdLK7G2sRpecFsvdqcx2A9uYQIqbNGQwCJWJCvIk3KRcK8zKziag/640?wx_fmt=png&from=appmsg)

重点关注`OpCode::Br`指令的实现。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrydxZ9ARj4fbkX43DKvAzeDS6spx2AKE5vSrQp0hc2Nr3yBeD5aOjgg/640?wx_fmt=png&from=appmsg)

branchToLabel 会把`PC`加上`PCOffset`，但是在`Executor::execute`的尾部还有一个`PC++`。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrkcXx4Jw7HKzjmUviaiatsqE4k72smRy7ibRJR8DOeZ6pzzQdLGRGzhrwg/640?wx_fmt=png&from=appmsg)

在某种情况下，`auto Res = Dispatch()`处理`Br`指令，将 PC 加上`PCOffset`，此时 PC 的值将等于`PCEnd`，但是循环还没结束，后面还有一条`PC++`语句，执行后，`PC == PCEnd + 1`，此后`while (PC != PCEnd)`将永远成立，那么就会继续读取`PCEnd + 1`处的数据结构来执行。

**漏洞利用**

WasmEdge 在运行 WASM 时首先会进行解析编译，构造出两个栈，一个执行栈`_pc stack`，另一个则是数据栈`_sp stack`，`_pc stack`是在解析时生成的，字节码无法操作`_pc stack`，只能操作数据栈`_sp stack`，正如 WebAssmebly 标准定义的那样。`_pc stack`中的所有数据，例如下标，都是在解析时检查通过的，如果某个下标能够溢出数据栈，将在解析时被检查到，从而终止 wasm 的解析，进而也不会执行。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrib3psCfNEkuhEMK9yFD0kUGmY1ciabslmgeDibOtTQ01hKlHicoRp7JpMg/640?wx_fmt=png&from=appmsg)

漏洞的情况表现如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrryI5iaxPFbiaBdO8aYVPL9Xy1AicgVyYt02x55T0iaTDuRZ3dN2DXMxFcg/640?wx_fmt=png&from=appmsg)

对于 WebAssmebly 虚拟机自己来说，PCEnd+1 在`_pc stack`这块堆内存之外，如果能够在`PCEnd + 1`处布置自定义的数据，漏洞将得以利用。这是因为前面提到，`PC`栈里的数据都是经过检查的，这里再补充一条就是在运行时，这些`Opcode`的处理函数`Handler`将不会再次检查参数。例如`global.set`指令的处理函数如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrpc9qFGONnJyufYMGmKxwK4FBMYzh6IAxGDViaPlVukhq39U491ic42Nw/640?wx_fmt=png&from=appmsg)

unsafeGetGlobal 直接使用了从 PC 栈中获取的下标来读取数据，并不检查下标是否越界，因为在 WASM 解析时就已经做过了下标边界的检查，无需再检查。现在由于漏洞溢出的原因，PC 将继续从后面的内存进行取值，而后面的内存我们是可以在一定程度上控制的，比如我们伪造一条`global.set`的指令结构体，并将 Idx 下标设置为我们想要的任意值，将能够实现**任意地址写**。

我们可以**使用 i64.const 来进行堆风水的布局**。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yr3az13FjQVibn8K5D9eQE6mTa8g5rYhYLABP5r4Elk3VibjUUoGXL0iaWw/640?wx_fmt=png&from=appmsg)

这是因为运行时，此类 opcode 的处理就是向 C++ 的`vector`中 push 一个新的数据，而`vector`是可以进行内存分配的，只要不断的压入数据，就能分配很多的内存。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrQV9qrMdR1Gblcichdtibq6mpkibPW6OVkOKvbyHEssibCGmsfLeK0SD3qQ/640?wx_fmt=png&from=appmsg)

因此我们在 POC 中写了很多的`i64.const`指令，最终的效果如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrsCHq0YjGVA2KLz0KJEAicCJWe8ia4PDYT5cK4tt3xzQpebag2oELz38g/640?wx_fmt=png&from=appmsg)

不幸的是 End 后面的内存并不完全可控，幸运的是我们能够控制`End + 1`的位置的第三个字段的值，查看指令结构体：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrkd3Y7jhYhicqg2Tgt4q2ibASbuV9cwmFWs6XBRjRZJEBOmrDPPIkU04g/640?wx_fmt=png&from=appmsg)

可控位置正好对应了指令结构体中的`Code`成员，也就是 opcode 能够任意指定，能够跳转到任何的 opcode 的 handler 中去执行，但是相关参数不可控制。一个好的思路是看能否执行某条`Opcode Handler`，将 PC 指向完全可控区。其中一条`Else`指令可以被利用。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrzakl5S85faOEg1IM6dzblLXI0CtDpf43tmkheVW8BGMBhBrtQRpzcQ/640?wx_fmt=png&from=appmsg)

处理 Else 指令时，会将 PC 加上`getJumpEnd()`。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yribJGLEdVGcTFkGJW2ic6QBh4icOhdKX182IZibSgiahm7pqcacj3B5RAC3g/640?wx_fmt=png&from=appmsg)

在内存中看到对应`JumpEnd`的位置数据为`0x154`，意味着我们可以让`PC += 0x154`，这已经足够让我们将 PC 指向可控区了。

由于`Instruction`结构体的大小为 32 字节，而数据栈中的 32 字节的数据类型有`v128.const i64x2`，因此我们可以用`v128.const i64x2`来伪造整个`Instruction`结构体。最终的效果如下，在`PCEnd+1`处伪造一条`Else`指令，将 PC 转移到数据栈中，并执行伪造的一系列指令。

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrWsQEHcdsibZYZAMCCwibGzYHW4PnnOY3kPPxaiavIEyticvTIXnzt3Pbew/640?wx_fmt=png&from=appmsg)

例如`global.get`和`global.set`的伪造如下：

![](https://mmbiz.qpic.cn/mmbiz_png/9EP6QFMcTmQBxUaeAp5DM164kPfW03yriaEPNA7b5MrDsbLd49ibgmZEaYa0PBU4As8DPsmL2kqGVMQ3GoFAic44Q/640?wx_fmt=png&from=appmsg)

通过设置 index，能够实现任意地址读写，进而构造后续 RCE。

**七**

**总 结**

目前还很少爆出 WebAssmebly 相关产品的漏洞，或许未来会有更多使用 WebAssmebly 的产品，本文为其研究提供了一种思路。

对代码本身的漏洞，在 WebAssmebly 里会受到限制进而导致传统漏洞模式变得难以利用，但是仍然具有挖掘的方面。

对于 WebAssmebly 虚拟机，不同的厂商可能实现不一样，可以针对其中的**数据结构解析、指令执行、导入函数的底层实现**入手，挖掘虚拟机本身的漏洞进而达到虚拟机逃逸控制主机的目的。

  

  

  

  

【版权说明】

本作品著作权归 **ha1vk** 所有

未经作者同意，不得转载

![](https://mmbiz.qpic.cn/mmbiz_jpg/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrIxUG4GhPS67zceVlhPDia0wsmtFDVxSY2QibZ2vQYqZf4kSbL33pfUMw/640?wx_fmt=jpeg&from=appmsg)

**ha1vk**

  

二进制安全研究员，BlackHat USA 2022 WASM 演讲者，专注 IOT、硬件、内核等方面的研究。

  

**JOIN US**

**天工实验室招贤纳士中……** 

奇安信天工实验室，专注于漏洞攻防领域技术研究，面向互联网基础设施，以操作系统平台、基础软件应用、网络通信协议、关键网络设备为目标，研究漏洞挖掘、利用、检测等关键技术。漏洞研究成果连续在 GeekPwn、天府杯等漏洞破解赛事中斩获奖项，漏洞挖掘方法发表于 ACM CCS、Usenix、EuroS&P、BlackHat、HITB 等国际重量级会议。

**招聘详情请戳** ➜ [天工实验室招贤纳士中！南京 / 北京 / 成都 / 西安开设岗位](http://mp.weixin.qq.com/s?__biz=Mzk0OTU2ODQ4Mw==&mid=2247484553&idx=1&sn=8e74606a2840d98bf815543f7cfee1c5&chksm=c3571205f4209b134931b4a5ec5868055300dd9affef6edcb212293ef73ea5cca2701ffc66d8&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_jpg/9EP6QFMcTmQBxUaeAp5DM164kPfW03yrX5ygtufia09CvWpfYO4J23Tgf6FLfBRVDy6MkIsWR5pBEEx8SgYUiccw/640?wx_fmt=jpeg&from=appmsg)

扫码投递简历

  

  

![](https://mmbiz.qpic.cn/mmbiz_png/oJZWTpJpiae90UpibicIKeZgQTNjebiaOwStfe6MJ5J6RC7F9JDFdX2kaEwibFz7GewNtNyDek6SdENJrXjf0KXA2kg/640?wx_fmt=png)

**每周三更新一篇技术文章  点击关注我们吧！**